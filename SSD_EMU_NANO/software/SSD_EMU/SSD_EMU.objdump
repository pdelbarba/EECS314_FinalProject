
SSD_EMU.elf:     file format elf32-littlenios2
SSD_EMU.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x040201b4

Program Header:
    LOAD off    0x00001000 vaddr 0x04020000 paddr 0x04020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x04020020 paddr 0x04020020 align 2**12
         filesz 0x0000dbdc memsz 0x0000dbdc flags r-x
    LOAD off    0x0000ebfc vaddr 0x0402dbfc paddr 0x0402f5d4 align 2**12
         filesz 0x000019d8 memsz 0x000019d8 flags rw-
    LOAD off    0x00010fac vaddr 0x04030fac paddr 0x04030fac align 2**12
         filesz 0x00000000 memsz 0x00000668 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  04020000  04020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000194  04020020  04020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000d090  040201b4  040201b4  000011b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000009b8  0402d244  0402d244  0000e244  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000019d8  0402dbfc  0402f5d4  0000ebfc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000668  04030fac  04030fac  00010fac  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  000105d4  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000009b8  00000000  00000000  000105f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000017eb  00000000  00000000  00010fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00016d88  00000000  00000000  0001279b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00005911  00000000  00000000  00029523  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000f1a3  00000000  00000000  0002ee34  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001664  00000000  00000000  0003dfd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001f9f  00000000  00000000  0003f63c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000045b9  00000000  00000000  000415db  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000060  00000000  00000000  00045b94  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00001458  00000000  00000000  00045bf8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0004a709  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  0004a70c  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0004a718  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0004a719  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0004a71a  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0004a71e  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0004a722  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   0000000b  00000000  00000000  0004a726  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    0000000b  00000000  00000000  0004a731  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   0000000b  00000000  00000000  0004a73c  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 00000006  00000000  00000000  0004a747  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 0000002d  00000000  00000000  0004a74d  2**0
                  CONTENTS, READONLY
 29 .jdi          00023bf0  00000000  00000000  0004a77a  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
04020000 l    d  .entry	00000000 .entry
04020020 l    d  .exceptions	00000000 .exceptions
040201b4 l    d  .text	00000000 .text
0402d244 l    d  .rodata	00000000 .rodata
0402dbfc l    d  .rwdata	00000000 .rwdata
04030fac l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
040201fc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 DES.c
0402d50c l     O .rodata	00000038 map8to7.1507
0402d244 l     O .rodata	00000038 KeyPermuteMap
0402d27c l     O .rodata	00000010 KeyRotation
0402d28c l     O .rodata	00000030 KeyCompression
0402d2bc l     O .rodata	00000030 DataExpansion
0402d30c l     O .rodata	00000200 SBox
0402d2ec l     O .rodata	00000020 PBox
00000000 l    df *ABS*	00000000 aes.c
00000000 l    df *ABS*	00000000 cpu_energy_test.c
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
04026558 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 lib2-divtable.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
04027604 l     F .text	00000080 print_repeat
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
0402e1a4 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_load.c
04028424 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0402f5ac l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
04028738 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0402e284 l     O .rwdata	000000d8 cfi_flash_0
0402e35c l     O .rwdata	00001060 jtag_uart_0
0402885c l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
04028930 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
04029720 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0402a7ac l     F .text	00000228 altera_avalon_jtag_uart_irq
0402a9d4 l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0402b288 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_ts.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
0402b88c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0402b9a8 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0402ba88 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0402be78 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0402bfb4 l     F .text	000000dc alt_file_locked
0402c218 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0402c840 l     F .text	000000bc alt_write_word_amd
0402c71c l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0402caf4 l     F .text	0000018c alt_unlock_block_intel
0402cc80 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0402d020 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
0402d1e0 l     F .text	00000040 alt_sim_halt
040274ac g     F .text	0000001c putchar
04022af0 g     F .text	000000ac aes_shiftrows
04028490 g     F .text	0000005c alt_main
040274d0 g     F .text	00000090 _puts_r
040291e0 g     F .text	00000048 alt_read_query_entry_32bit
04031514 g     O .bss	00000100 alt_irq
04028968 g     F .text	000002c0 alt_flash_cfi_write
0402f5d4 g       *ABS*	00000000 __flash_rwdata_start
04024854 g     F .text	00000738 fir_testbench
04031614 g       *ABS*	00000000 __alt_heap_start
04027414 g     F .text	00000054 printf
0402f564 g     O .rwdata	00000008 b
040256c4 g     F .text	00000008 reset_power_tick
04030fb4 g     O .bss	00000004 t_sch_rd_end
0402850c g     F .text	00000020 __malloc_unlock
04030fb8 g     O .bss	00000004 t_ci_run_end
04030fbc g     O .bss	00000004 t_spi_xmit_end
04030fc0 g     O .bss	00000004 o1
04026204 g     F .text	00000174 __divsf3
0403109c g     O .bss	00000004 altera_avalon_timer_ts_freq
04026378 g     F .text	00000094 __fixsfsi
0402411c g     F .text	000002e8 aes_alloc_ctx
00000000  w      *UND*	00000000 __errno
0402936c g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
04020000 g     F .entry	0000001c __reset
04030fc4 g     O .bss	00000004 t_sch_cfg_end
04021064 g     F .text	000001e8 aes_addroundkey
04020020 g       *ABS*	00000000 __flash_exceptions_start
04028e84 g     F .text	000002d8 alt_flash_program_block
040314e4 g     O .bss	00000010 mbc_header
04031088 g     O .bss	00000004 errno
04026520 g     F .text	00000038 __make_dp
04030fc8 g     O .bss	00000004 t_fl_open_begin
04030fcc g     O .bss	00000004 t_lut_cfg
04031090 g     O .bss	00000004 alt_argv
04037564 g       *ABS*	00000000 _gp
040285e8 g     F .text	00000030 usleep
0402124c g     F .text	0000010c aes_invsubbytes
0402f3e4 g     O .rwdata	00000180 alt_fd_list
04030fd0 g     O .bss	00000004 t_lut_rd
040274c8 g     F .text	00000008 _putchar_r
0402bae8 g     F .text	00000094 alt_find_dev
04020f58 g     F .text	0000010c aes_subbytes
040273c8 g     F .text	0000002c memcpy
04030fd4 g     O .bss	00000004 t_fl_open_end
04024f8c g     F .text	0000025c aes_testbench
04030fd8 g     O .bss	00000004 t_fl_rd_kh_end
04030fdc g     O .bss	00000004 t_lut_cfg_begin
0402bf3c g     F .text	00000078 alt_io_redirect
04020f08 g     F .text	00000050 aes_mul_manual
04027560 g     F .text	00000014 puts
04030fe0 g     O .bss	00000004 t_des_run
0402f56c g     O .rwdata	00000008 g
0402abec g     F .text	00000224 altera_avalon_jtag_uart_read
04026c74 g     F .text	00000014 malloc
04027468 g     F .text	00000044 _printf_r
04020000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
04026694 g     F .text	00000008 __udivsi3
04030fe4 g     O .bss	00000004 t_hdr_parse_end
04024404 g     F .text	00000038 csleep
0402cf34 g     F .text	00000090 alt_icache_flush
0403107c g     O .bss	00000004 __malloc_top_pad
04030fe8 g     O .bss	00000004 t_fir_run_begin
04023718 g     F .text	00000a04 aes_decrypt
04030fec g     O .bss	00000004 t_mbc_cfg_begin
04027574 g     F .text	00000070 _sbrk_r
0402c8fc g     F .text	00000084 alt_program_intel
04020ca8 g     F .text	00000260 aes_keyexpansion
04030fac g     O .bss	00000008 dst
040251e8 g     F .text	00000060 spi_tx_char
0402b8ec g     F .text	00000078 alt_dcache_flush
04030ff0 g     O .bss	00000004 t_fl_rd_kh
0402f5c0 g     O .rwdata	00000004 alt_max_fd
0402915c g     F .text	00000040 alt_read_query_entry_8bit
0402c980 g     F .text	00000174 alt_erase_block_intel
04031080 g     O .bss	00000004 __malloc_max_sbrked_mem
0402640c g     F .text	00000054 __extendsfdf2
04030ff4 g     O .bss	00000004 t_spi_xmit_begin
0402443c g     F .text	00000054 spi_pow_testbench
0402f5a0 g     O .rwdata	00000004 _global_impure_ptr
04031614 g       *ABS*	00000000 __bss_end
0402bd80 g     F .text	000000f8 alt_iic_isr_register
0402c370 g     F .text	0000010c alt_tick
040246f4 g     F .text	00000160 des_testbench
04030ff8 g     O .bss	00000004 t_hdr_parse_begin
0402032c g     F .text	00000900 auth_DEShash
04025b94 g     F .text	000004a8 measure_power
0402bd38 g     F .text	00000048 alt_ic_irq_enabled
0402c2d8 g     F .text	00000098 alt_alarm_stop
040310a0 g     O .bss	00000004 alt_irq_active
04030ffc g     O .bss	00000004 t_init
040310e4 g     O .bss	00000100 g_aes_ilogt
04031000 g     O .bss	00000004 t_hdr_parse
040200ec g     F .exceptions	000000c8 alt_irq_handler
0402f3bc g     O .rwdata	00000028 alt_dev_null
04031004 g     O .bss	00000004 t_mbc_run_end
04026884 g     F .text	000000c8 __unpack_f
04029674 g     F .text	000000ac alt_set_flash_algorithm_func
0402b964 g     F .text	00000044 alt_dcache_flush_all
04021b5c g     F .text	000000ac aes_invshiftrows
0402f574 g     O .rwdata	00000008 r
04029228 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
0402f5d4 g       *ABS*	00000000 __ram_rwdata_end
0402f5b8 g     O .rwdata	00000008 alt_dev_list
04028618 g     F .text	00000120 write
040281e8 g     F .text	00000074 _putc_r
0402b4c8 g     F .text	00000028 alt_timestamp_freq
0402dbfc g       *ABS*	00000000 __ram_rodata_end
04031008 g     O .bss	00000004 t_aes_run_end
0402a4c8 g     F .text	000000dc alt_check_primary_table
0402669c g     F .text	00000008 __umodsi3
04028cb8 g     F .text	00000068 alt_flash_cfi_read
040293fc g     F .text	00000034 alt_write_native_8bit
04031614 g       *ABS*	00000000 end
04026724 g     F .text	00000160 __pack_f
04029264 g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
0402979c g     F .text	00000580 alt_read_cfi_table
0402a6ec g     F .text	000000c0 altera_avalon_jtag_uart_init
04038000 g       *ABS*	00000000 __alt_stack_pointer
0402b2f8 g     F .text	00000090 alt_avalon_timer_sc_init
040266a4 g     F .text	00000080 __clzsi2
0402ae10 g     F .text	00000240 altera_avalon_jtag_uart_write
04020c88 g     F .text	00000020 aes_rotword
04028894 g     F .text	0000009c alt_flash_cfi_init
04027684 g     F .text	000005d4 ___vfprintf_internal_r
00000000 g       *ABS*	00000000 __alt_mem_cfi_flash_0
04027da8 g     F .text	00000314 _free_r
0402d024 g     F .text	000001bc __call_exitprocs
0402f598 g     O .rwdata	00000004 __malloc_sbrk_base
040201b4 g     F .text	0000004c _start
040310a4 g     O .bss	00000004 _alt_tick_rate
0402b050 g     F .text	00000238 alt_avalon_spi_command
040310a8 g     O .bss	00000004 _alt_nticks
040287cc g     F .text	00000090 alt_sys_init
0403100c g     O .bss	00000004 t_sch_cfg_begin
04021358 g     F .text	00000004 aes_free_ctx
0402919c g     F .text	00000044 alt_read_query_entry_16bit
0402aa84 g     F .text	00000074 altera_avalon_jtag_uart_close
0402dbfc g       *ABS*	00000000 __ram_rwdata_start
0402d244 g       *ABS*	00000000 __ram_rodata_start
040310bc g     O .bss	00000028 __malloc_current_mallinfo
04029494 g     F .text	000001e0 alt_set_flash_width_func
04031010 g     O .bss	00000004 t_fir_run
04031014 g     O .bss	00000004 t_fl_rd_kids_end
04020200 g     F .text	0000012c auth_DESkey8to7
0402a5a4 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
0402ce7c g     F .text	000000b8 alt_get_fd
0402b644 g     F .text	0000014c alt_busy_sleep
0402c504 g     F .text	00000218 alt_erase_block_amd
0402cfe4 g     F .text	0000003c memcmp
0402a654 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
04031614 g       *ABS*	00000000 __alt_stack_base
040314f4 g     O .bss	00000010 ctext
0402a69c g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
040311e4 g     O .bss	00000100 g_aes_isbox
04029d1c g     F .text	000007ac alt_read_cfi_width
04031078 g     O .bss	00000004 tick
0402dd9c g     O .rwdata	00000408 __malloc_av_
04031018 g     O .bss	00000004 t_lut_rd_begin
0402daa4 g     O .rodata	00000010 __thenan_sf
0402cd5c g     F .text	00000120 alt_find_file
0402b9d4 g     F .text	000000b4 alt_dev_llist_insert
040284ec g     F .text	00000020 __malloc_lock
0402852c g     F .text	000000bc sbrk
0402f5a4 g     O .rwdata	00000008 alt_flash_dev_list
040246ac g     F .text	00000048 mbc_testbench
04029328 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
040280bc g     F .text	000000bc __sfvwrite_small_dev
0402dc9c g     O .rwdata	00000100 __divsi3_table
04030fac g       *ABS*	00000000 __bss_start
0402f58d g     O .rwdata	00000004 data
040273f4 g     F .text	00000020 memset
04025248 g     F .text	0000047c main
0403101c g     O .bss	00000004 t_ci_run
04031094 g     O .bss	00000004 alt_envp
04031084 g     O .bss	00000004 __malloc_max_total_mem
0402a5fc g     F .text	00000058 altera_avalon_jtag_uart_write_fd
04025a14 g     F .text	00000180 POWER_Read
04022b9c g     F .text	0000022c init_aes
040312e4 g     O .bss	00000100 g_aes_sbox
04038000 g       *ABS*	00000000 __alt_heap_limit
0402b388 g     F .text	000000a4 alt_timestamp_start
04026c88 g     F .text	00000740 _malloc_r
04024490 g     F .text	0000021c ci_testbench
04021c08 g     F .text	00000ee8 aes_mixcolumns
0402f5c4 g     O .rwdata	00000004 alt_errno
040256cc g     F .text	00000348 POWER_SPI_RW
040293b4 g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
04031020 g     O .bss	00000004 t_des_run_end
0402dbfc g     O .rwdata	00000010 key
04028d20 g     F .text	00000164 alt_write_value_to_flash
04029430 g     F .text	00000034 alt_write_native_16bit
04028178 g     F .text	00000070 putc
04031024 g     O .bss	00000004 t_fl_rd_kids
040265d4 g     F .text	00000060 __divsi3
04027c7c g     F .text	0000012c _malloc_trim_r
0402603c g     F .text	000001c8 __mulsf3
04031028 g     O .bss	00000004 t_fl_rd_kh_begin
0402d244 g       *ABS*	00000000 __flash_rodata_start
0403102c g     O .bss	00000004 o0
04028798 g     F .text	00000034 alt_irq_init
040313e4 g     O .bss	00000100 g_aes_logt
0402c278 g     F .text	00000060 alt_release_fd
0402dab4 g     O .rodata	00000100 __clz_tab
04031030 g     O .bss	00000004 t_mbc_cfg_end
0402825c g     F .text	00000078 _write_r
04031034 g     O .bss	00000004 t_lut_rd_end
0402f59c g     O .rwdata	00000004 _impure_ptr
0403108c g     O .bss	00000004 alt_argc
04031098 g     O .bss	00000004 altera_avalon_timer_ts_base
04031038 g     O .bss	00000004 t_mbc_run
0403103c g     O .bss	00000004 t_ci_run_begin
04020c2c g     F .text	0000005c aes_subword
04020020 g       .exceptions	00000000 alt_irq_entry
04031040 g     O .bss	00000004 t_sch_rd_begin
0402dc5c g     O .rwdata	00000040 in0
0402f5b0 g     O .rwdata	00000008 alt_fs_list
040292e0 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
04031044 g     O .bss	00000004 t_fl_rd_kids_begin
04020020 g       *ABS*	00000000 __ram_exceptions_start
0402b42c g     F .text	0000009c alt_timestamp
04031048 g     O .bss	00000004 t_aes_run_begin
0402bbac g     F .text	00000050 alt_ic_isr_register
0402f584 g     O .rwdata	00000008 src
0402f5d4 g       *ABS*	00000000 _edata
0403104c g     O .bss	00000004 t_fir_run_end
04031614 g       *ABS*	00000000 _end
040282d4 g     F .text	0000007c alt_flash_open_dev
0402135c g     F .text	00000800 aes_invmixcolumns
04031050 g     O .bss	00000004 t_lut_cfg_end
040201b4 g       *ABS*	00000000 __ram_exceptions_end
0402aaf8 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
0402f57c g     O .rwdata	00000008 key2
0402bc98 g     F .text	000000a0 alt_ic_irq_disable
0402f594 g     O .rwdata	00000004 __malloc_trim_threshold
0402dc0c g     O .rwdata	00000010 ptext
0402c47c g     F .text	00000020 altera_nios2_qsys_irq_init
0402cfc4 g     F .text	00000020 exit
04026460 g     F .text	000000c0 __floatunsisf
04031054 g     O .bss	00000004 t_mbc_run_begin
04028350 g     F .text	00000054 alt_flash_close_dev
04031058 g     O .bss	00000004 t_fl_open
04026634 g     F .text	00000060 __modsi3
0403105c g     O .bss	00000004 t_spi_xmit
04038000 g       *ABS*	00000000 __alt_data_end
04020020 g     F .exceptions	00000000 alt_exception
04031060 g     O .bss	00000004 overhead
0402d220 g     F .text	00000020 _exit
0402b4f0 g     F .text	00000154 alt_alarm_start
04029464 g     F .text	00000030 alt_write_native_32bit
040275e4 g     F .text	00000020 strlen
04031064 g     O .bss	00000004 t_sch_cfg
0402c090 g     F .text	00000188 open
04028c28 g     F .text	00000090 alt_flash_cfi_get_info
0402bb7c g     F .text	00000030 alt_icache_flush_all
04031068 g     O .bss	00000004 t_sch_rd
0402f5c8 g     O .rwdata	00000004 alt_priority_mask
0402f58c g     O .rwdata	00000001 len
0402bbfc g     F .text	0000009c alt_ic_irq_enable
04027c58 g     F .text	00000024 __vfprintf_internal
0402dc1c g     O .rwdata	00000040 co0
0402f5cc g     O .rwdata	00000008 alt_alarm_list
040310ac g     O .bss	00000010 sum0
0402b790 g     F .text	000000fc close
0402c49c g     F .text	00000068 alt_program_amd
040283a4 g     F .text	00000080 alt_load
0402694c g     F .text	00000314 __pack_d
0403106c g     O .bss	00000004 t_aes_run
04026c60 g     F .text	00000014 free
04031504 g     O .bss	00000010 decptext
04022dc8 g     F .text	00000950 aes_encrypt
04031070 g     O .bss	00000004 t_mbc_cfg
04031074 g     O .bss	00000004 t_des_run_begin



Disassembly of section .entry:

04020000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 4020000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 4020004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 4020008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 402000c:	00bffd16 	blt	zero,r2,4020004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 4020010:	004100b4 	movhi	at,1026
    ori r1, r1, %lo(_start)
 4020014:	08406d14 	ori	at,at,436
    jmp r1
 4020018:	0800683a 	jmp	at
 402001c:	00000000 	call	0 <__alt_mem_cfi_flash_0>

Disassembly of section .exceptions:

04020020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 4020020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 4020024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 4020028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 402002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 4020030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 4020034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 4020038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 402003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 4020040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 4020044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 4020048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 402004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 4020050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 4020054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 4020058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 402005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 4020060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 4020064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 4020068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 402006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4020070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4020074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4020078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 402007c:	10000326 	beq	r2,zero,402008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 4020080:	20000226 	beq	r4,zero,402008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4020084:	40200ec0 	call	40200ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4020088:	00000306 	br	4020098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 402008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 4020090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 4020094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 4020098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 402009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40200a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40200a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40200a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40200ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 40200b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 40200b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 40200b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 40200bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 40200c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 40200c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 40200c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 40200cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 40200d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 40200d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 40200d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 40200dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 40200e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 40200e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 40200e8:	ef80083a 	eret

040200ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 40200ec:	defff904 	addi	sp,sp,-28
 40200f0:	dfc00615 	stw	ra,24(sp)
 40200f4:	df000515 	stw	fp,20(sp)
 40200f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 40200fc:	0005313a 	rdctl	r2,ipending
 4020100:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4020104:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 4020108:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 402010c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4020110:	00800044 	movi	r2,1
 4020114:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 4020118:	e0ffff17 	ldw	r3,-4(fp)
 402011c:	e0bffe17 	ldw	r2,-8(fp)
 4020120:	1884703a 	and	r2,r3,r2
 4020124:	1005003a 	cmpeq	r2,r2,zero
 4020128:	1000161e 	bne	r2,zero,4020184 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 402012c:	e0bffd17 	ldw	r2,-12(fp)
 4020130:	00c100f4 	movhi	r3,1027
 4020134:	18c54504 	addi	r3,r3,5396
 4020138:	100490fa 	slli	r2,r2,3
 402013c:	10c5883a 	add	r2,r2,r3
 4020140:	11400017 	ldw	r5,0(r2)
 4020144:	e0bffd17 	ldw	r2,-12(fp)
 4020148:	00c100f4 	movhi	r3,1027
 402014c:	18c54504 	addi	r3,r3,5396
 4020150:	100490fa 	slli	r2,r2,3
 4020154:	10c5883a 	add	r2,r2,r3
 4020158:	10800104 	addi	r2,r2,4
 402015c:	11000017 	ldw	r4,0(r2)
 4020160:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4020164:	0005313a 	rdctl	r2,ipending
 4020168:	e0bffb15 	stw	r2,-20(fp)

  return active;
 402016c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 4020170:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 4020174:	e0bfff17 	ldw	r2,-4(fp)
 4020178:	1004c03a 	cmpne	r2,r2,zero
 402017c:	103fe31e 	bne	r2,zero,402010c <alt_irq_handler+0x20>
 4020180:	00000706 	br	40201a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 4020184:	e0bffe17 	ldw	r2,-8(fp)
 4020188:	1085883a 	add	r2,r2,r2
 402018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 4020190:	e0bffd17 	ldw	r2,-12(fp)
 4020194:	10800044 	addi	r2,r2,1
 4020198:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 402019c:	003fde06 	br	4020118 <alt_irq_handler+0x2c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 40201a0:	e037883a 	mov	sp,fp
 40201a4:	dfc00117 	ldw	ra,4(sp)
 40201a8:	df000017 	ldw	fp,0(sp)
 40201ac:	dec00204 	addi	sp,sp,8
 40201b0:	f800283a 	ret

Disassembly of section .text:

040201b4 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 40201b4:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 40201b8:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 40201bc:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 40201c0:	00bffd16 	blt	zero,r2,40201b8 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 40201c4:	06c100f4 	movhi	sp,1027
    ori sp, sp, %lo(__alt_stack_pointer)
 40201c8:	dee00014 	ori	sp,sp,32768

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 40201cc:	068100f4 	movhi	gp,1027
    ori gp, gp, %lo(_gp)
 40201d0:	d69d5914 	ori	gp,gp,30052
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 40201d4:	008100f4 	movhi	r2,1027
    ori r2, r2, %lo(__bss_start)
 40201d8:	1083eb14 	ori	r2,r2,4012

    movhi r3, %hi(__bss_end)
 40201dc:	00c100f4 	movhi	r3,1027
    ori r3, r3, %lo(__bss_end)
 40201e0:	18c58514 	ori	r3,r3,5652

    beq r2, r3, 1f
 40201e4:	10c00326 	beq	r2,r3,40201f4 <_start+0x40>

0:
    stw zero, (r2)
 40201e8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 40201ec:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 40201f0:	10fffd36 	bltu	r2,r3,40201e8 <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 40201f4:	40283a40 	call	40283a4 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 40201f8:	40284900 	call	4028490 <alt_main>

040201fc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 40201fc:	003fff06 	br	40201fc <alt_after_alt_main>

04020200 <auth_DESkey8to7>:
 * Functions:
 */

uchar *auth_DESkey8to7(uchar *dst, const uchar *key)

{
 4020200:	defffe04 	addi	sp,sp,-8
 4020204:	2017883a 	mov	r11,r4
	static const uint8_t map8to7[56] = { 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12,
			13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 32,
			33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51,
			52, 53, 54, 56, 57, 58, 59, 60, 61, 62 };

	if ((null == dst) || (null == key))
 4020208:	2000031e 	bne	r4,zero,4020218 <auth_DESkey8to7+0x18>
	Permute(tmp, key, map8to7, 7);
	for (i = 0; i < 7; i++)
		dst[i] = tmp[i];

	return (dst);
} /* auth_DESkey8to7 */
 402020c:	5805883a 	mov	r2,r11
 4020210:	dec00204 	addi	sp,sp,8
 4020214:	f800283a 	ret
	static const uint8_t map8to7[56] = { 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12,
			13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 32,
			33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51,
			52, 53, 54, 56, 57, 58, 59, 60, 61, 62 };

	if ((null == dst) || (null == key))
 4020218:	28004226 	beq	r5,zero,4020324 <auth_DESkey8to7+0x124>
	int i;

	/* Clear all bits in the destination.
	 */
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;
 402021c:	000f883a 	mov	r7,zero
 4020220:	020100f4 	movhi	r8,1027
 4020224:	42354304 	addi	r8,r8,-10996
 4020228:	034001c4 	movi	r13,7
 402022c:	03000044 	movi	r12,1
 4020230:	02a00034 	movhi	r10,32768
 4020234:	528001c4 	addi	r10,r10,7
 4020238:	03bffe04 	movi	r14,-8
 402023c:	02400e04 	movi	r9,56
 4020240:	d8000005 	stb	zero,0(sp)
 4020244:	d8000045 	stb	zero,1(sp)
 4020248:	d8000085 	stb	zero,2(sp)
 402024c:	d80000c5 	stb	zero,3(sp)
 4020250:	d8000105 	stb	zero,4(sp)
 4020254:	d8000145 	stb	zero,5(sp)
 4020258:	d8000185 	stb	zero,6(sp)
 402025c:	00000a06 	br	4020288 <auth_DESkey8to7+0x88>

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
			SETBIT( dst, i );
 4020260:	1805d0fa 	srai	r2,r3,3
 4020264:	d889883a 	add	r4,sp,r2
 4020268:	30001916 	blt	r6,zero,40202d0 <auth_DESkey8to7+0xd0>
 402026c:	6985c83a 	sub	r2,r13,r6
 4020270:	20c00003 	ldbu	r3,0(r4)
 4020274:	6084983a 	sll	r2,r12,r2
 4020278:	10c4b03a 	or	r2,r2,r3
 402027c:	20800005 	stb	r2,0(r4)
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 4020280:	39c00044 	addi	r7,r7,1
 4020284:	3a401626 	beq	r7,r9,40202e0 <auth_DESkey8to7+0xe0>
		if (GETBIT( src, map[i] ))
 4020288:	41000003 	ldbu	r4,0(r8)
			SETBIT( dst, i );
 402028c:	3a8c703a 	and	r6,r7,r10
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 4020290:	42000044 	addi	r8,r8,1
		if (GETBIT( src, map[i] ))
 4020294:	2006d0fa 	srli	r3,r4,3
 4020298:	0108303a 	nor	r4,zero,r4
 402029c:	210001cc 	andi	r4,r4,7
 40202a0:	28c7883a 	add	r3,r5,r3
 40202a4:	18800003 	ldbu	r2,0(r3)
			SETBIT( dst, i );
 40202a8:	3807883a 	mov	r3,r7
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
 40202ac:	1105d83a 	sra	r2,r2,r4
 40202b0:	1080004c 	andi	r2,r2,1
 40202b4:	1005003a 	cmpeq	r2,r2,zero
 40202b8:	103ff11e 	bne	r2,zero,4020280 <auth_DESkey8to7+0x80>
			SETBIT( dst, i );
 40202bc:	383fe80e 	bge	r7,zero,4020260 <auth_DESkey8to7+0x60>
 40202c0:	38c001c4 	addi	r3,r7,7
 40202c4:	1805d0fa 	srai	r2,r3,3
 40202c8:	d889883a 	add	r4,sp,r2
 40202cc:	303fe70e 	bge	r6,zero,402026c <auth_DESkey8to7+0x6c>
 40202d0:	31bfffc4 	addi	r6,r6,-1
 40202d4:	338cb03a 	or	r6,r6,r14
 40202d8:	31800044 	addi	r6,r6,1
 40202dc:	003fe306 	br	402026c <auth_DESkey8to7+0x6c>
	if ((null == dst) || (null == key))
		return (null);

	Permute(tmp, key, map8to7, 7);
	for (i = 0; i < 7; i++)
		dst[i] = tmp[i];
 40202e0:	d8800003 	ldbu	r2,0(sp)
 40202e4:	58800005 	stb	r2,0(r11)
 40202e8:	d8c00043 	ldbu	r3,1(sp)
 40202ec:	58c00045 	stb	r3,1(r11)
 40202f0:	d8800083 	ldbu	r2,2(sp)
 40202f4:	58800085 	stb	r2,2(r11)
 40202f8:	d8c000c3 	ldbu	r3,3(sp)
 40202fc:	58c000c5 	stb	r3,3(r11)
 4020300:	d8800103 	ldbu	r2,4(sp)
 4020304:	58800105 	stb	r2,4(r11)
 4020308:	d8c00143 	ldbu	r3,5(sp)
 402030c:	58c00145 	stb	r3,5(r11)
 4020310:	d8800183 	ldbu	r2,6(sp)
 4020314:	58800185 	stb	r2,6(r11)

	return (dst);
} /* auth_DESkey8to7 */
 4020318:	5805883a 	mov	r2,r11
 402031c:	dec00204 	addi	sp,sp,8
 4020320:	f800283a 	ret
	static const uint8_t map8to7[56] = { 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12,
			13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 32,
			33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51,
			52, 53, 54, 56, 57, 58, 59, 60, 61, 62 };

	if ((null == dst) || (null == key))
 4020324:	0017883a 	mov	r11,zero
 4020328:	003fb806 	br	402020c <auth_DESkey8to7+0xc>

0402032c <auth_DEShash>:
#define IP_FP_ON
#undef IP_FP_ON

uchar *auth_DEShash(uchar *dst, const uchar *key, const uchar *src)

{
 402032c:	deffec04 	addi	sp,sp,-80
 4020330:	dd801215 	stw	r22,72(sp)
 4020334:	ddc01315 	stw	r23,76(sp)
 4020338:	dd401115 	stw	r21,68(sp)
 402033c:	dd001015 	stw	r20,64(sp)
 4020340:	dcc00f15 	stw	r19,60(sp)
 4020344:	dc800e15 	stw	r18,56(sp)
 4020348:	dc400d15 	stw	r17,52(sp)
 402034c:	dc000c15 	stw	r16,48(sp)
 4020350:	202d883a 	mov	r22,r4
	static const uint8_t map8to7[56] = { 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12,
			13, 14, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 32,
			33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51,
			52, 53, 54, 56, 57, 58, 59, 60, 61, 62 };

	if ((null == dst) || (null == key))
 4020354:	28004026 	beq	r5,zero,4020458 <auth_DEShash+0x12c>
	int i;

	/* Clear all bits in the destination.
	 */
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;
 4020358:	0011883a 	mov	r8,zero
 402035c:	024100f4 	movhi	r9,1027
 4020360:	4a754304 	addi	r9,r9,-10996
 4020364:	038001c4 	movi	r14,7
 4020368:	03000044 	movi	r12,1
 402036c:	db4005c4 	addi	r13,sp,23
 4020370:	02e00034 	movhi	r11,32768
 4020374:	5ac001c4 	addi	r11,r11,7
 4020378:	03fffe04 	movi	r15,-8
 402037c:	02800e04 	movi	r10,56
 4020380:	d80005c5 	stb	zero,23(sp)
 4020384:	d8000605 	stb	zero,24(sp)
 4020388:	d8000645 	stb	zero,25(sp)
 402038c:	d8000685 	stb	zero,26(sp)
 4020390:	d80006c5 	stb	zero,27(sp)
 4020394:	d8000705 	stb	zero,28(sp)
 4020398:	d8000745 	stb	zero,29(sp)
 402039c:	00000a06 	br	40203c8 <auth_DEShash+0x9c>

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
			SETBIT( dst, i );
 40203a0:	1805d0fa 	srai	r2,r3,3
 40203a4:	6889883a 	add	r4,r13,r2
 40203a8:	38001916 	blt	r7,zero,4020410 <auth_DEShash+0xe4>
 40203ac:	71c5c83a 	sub	r2,r14,r7
 40203b0:	20c00003 	ldbu	r3,0(r4)
 40203b4:	6084983a 	sll	r2,r12,r2
 40203b8:	10c4b03a 	or	r2,r2,r3
 40203bc:	20800005 	stb	r2,0(r4)
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 40203c0:	42000044 	addi	r8,r8,1
 40203c4:	42801626 	beq	r8,r10,4020420 <auth_DEShash+0xf4>
		if (GETBIT( src, map[i] ))
 40203c8:	49000003 	ldbu	r4,0(r9)
			SETBIT( dst, i );
 40203cc:	42ce703a 	and	r7,r8,r11
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 40203d0:	4a400044 	addi	r9,r9,1
		if (GETBIT( src, map[i] ))
 40203d4:	2006d0fa 	srli	r3,r4,3
 40203d8:	0108303a 	nor	r4,zero,r4
 40203dc:	210001cc 	andi	r4,r4,7
 40203e0:	28c7883a 	add	r3,r5,r3
 40203e4:	18800003 	ldbu	r2,0(r3)
			SETBIT( dst, i );
 40203e8:	4007883a 	mov	r3,r8
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
 40203ec:	1105d83a 	sra	r2,r2,r4
 40203f0:	1080004c 	andi	r2,r2,1
 40203f4:	1005003a 	cmpeq	r2,r2,zero
 40203f8:	103ff11e 	bne	r2,zero,40203c0 <auth_DEShash+0x94>
			SETBIT( dst, i );
 40203fc:	403fe80e 	bge	r8,zero,40203a0 <auth_DEShash+0x74>
 4020400:	40c001c4 	addi	r3,r8,7
 4020404:	1805d0fa 	srai	r2,r3,3
 4020408:	6889883a 	add	r4,r13,r2
 402040c:	383fe70e 	bge	r7,zero,40203ac <auth_DEShash+0x80>
 4020410:	39ffffc4 	addi	r7,r7,-1
 4020414:	3bceb03a 	or	r7,r7,r15
 4020418:	39c00044 	addi	r7,r7,1
 402041c:	003fe306 	br	40203ac <auth_DEShash+0x80>
	if ((null == dst) || (null == key))
		return (null);

	Permute(tmp, key, map8to7, 7);
	for (i = 0; i < 7; i++)
		dst[i] = tmp[i];
 4020420:	d88005c3 	ldbu	r2,23(sp)
 4020424:	d8c00603 	ldbu	r3,24(sp)
 4020428:	d8800405 	stb	r2,16(sp)
 402042c:	d8800643 	ldbu	r2,25(sp)
 4020430:	d8c00445 	stb	r3,17(sp)
 4020434:	d8c00683 	ldbu	r3,26(sp)
 4020438:	d8800485 	stb	r2,18(sp)
 402043c:	d88006c3 	ldbu	r2,27(sp)
 4020440:	d8c004c5 	stb	r3,19(sp)
 4020444:	d8c00703 	ldbu	r3,28(sp)
 4020448:	d8800505 	stb	r2,20(sp)
 402044c:	d8800743 	ldbu	r2,29(sp)
 4020450:	d8c00545 	stb	r3,21(sp)
 4020454:	d8800585 	stb	r2,22(sp)
	int i;

	/* Clear all bits in the destination.
	 */
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;
 4020458:	000f883a 	mov	r7,zero
 402045c:	020100f4 	movhi	r8,1027
 4020460:	42349104 	addi	r8,r8,-11708
 4020464:	dac00404 	addi	r11,sp,16
 4020468:	dbc00784 	addi	r15,sp,30
 402046c:	030001c4 	movi	r12,7
 4020470:	03400044 	movi	r13,1
 4020474:	02a00034 	movhi	r10,32768
 4020478:	528001c4 	addi	r10,r10,7
 402047c:	03bffe04 	movi	r14,-8
 4020480:	02400e04 	movi	r9,56
 4020484:	d8000785 	stb	zero,30(sp)
 4020488:	d80007c5 	stb	zero,31(sp)
 402048c:	d8000805 	stb	zero,32(sp)
 4020490:	d8000845 	stb	zero,33(sp)
 4020494:	d8000885 	stb	zero,34(sp)
 4020498:	d80008c5 	stb	zero,35(sp)
 402049c:	d8000905 	stb	zero,36(sp)
 40204a0:	00000a06 	br	40204cc <auth_DEShash+0x1a0>

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
			SETBIT( dst, i );
 40204a4:	1805d0fa 	srai	r2,r3,3
 40204a8:	7889883a 	add	r4,r15,r2
 40204ac:	28001916 	blt	r5,zero,4020514 <auth_DEShash+0x1e8>
 40204b0:	6145c83a 	sub	r2,r12,r5
 40204b4:	20c00003 	ldbu	r3,0(r4)
 40204b8:	6884983a 	sll	r2,r13,r2
 40204bc:	10c4b03a 	or	r2,r2,r3
 40204c0:	20800005 	stb	r2,0(r4)
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 40204c4:	39c00044 	addi	r7,r7,1
 40204c8:	3a401626 	beq	r7,r9,4020524 <auth_DEShash+0x1f8>
		if (GETBIT( src, map[i] ))
 40204cc:	41000003 	ldbu	r4,0(r8)
			SETBIT( dst, i );
 40204d0:	3a8a703a 	and	r5,r7,r10
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 40204d4:	42000044 	addi	r8,r8,1
		if (GETBIT( src, map[i] ))
 40204d8:	2006d0fa 	srli	r3,r4,3
 40204dc:	0108303a 	nor	r4,zero,r4
 40204e0:	210001cc 	andi	r4,r4,7
 40204e4:	58c7883a 	add	r3,r11,r3
 40204e8:	18800003 	ldbu	r2,0(r3)
			SETBIT( dst, i );
 40204ec:	3807883a 	mov	r3,r7
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
 40204f0:	1105d83a 	sra	r2,r2,r4
 40204f4:	1080004c 	andi	r2,r2,1
 40204f8:	1005003a 	cmpeq	r2,r2,zero
 40204fc:	103ff11e 	bne	r2,zero,40204c4 <auth_DEShash+0x198>
			SETBIT( dst, i );
 4020500:	383fe80e 	bge	r7,zero,40204a4 <auth_DEShash+0x178>
 4020504:	38c001c4 	addi	r3,r7,7
 4020508:	1805d0fa 	srai	r2,r3,3
 402050c:	7889883a 	add	r4,r15,r2
 4020510:	283fe70e 	bge	r5,zero,40204b0 <auth_DEShash+0x184>
 4020514:	297fffc4 	addi	r5,r5,-1
 4020518:	2b8ab03a 	or	r5,r5,r14
 402051c:	29400044 	addi	r5,r5,1
 4020520:	003fe306 	br	40204b0 <auth_DEShash+0x184>
	Permute( D, src, InitialPermuteMap, 8 );
#else
	int temp = 0;
	for (temp = 0; temp < 8; temp = temp + 1)
	{
		D[temp] = src[temp];
 4020524:	328001c3 	ldbu	r10,7(r6)
 4020528:	31400003 	ldbu	r5,0(r6)
 402052c:	31c00043 	ldbu	r7,1(r6)
 4020530:	32000083 	ldbu	r8,2(r6)
 4020534:	324000c3 	ldbu	r9,3(r6)
 4020538:	30800103 	ldbu	r2,4(r6)
 402053c:	31000143 	ldbu	r4,5(r6)
 4020540:	30c00183 	ldbu	r3,6(r6)
 4020544:	054100f4 	movhi	r21,1027
 4020548:	ad749f04 	addi	r21,r21,-11652
 402054c:	d9400945 	stb	r5,37(sp)
 4020550:	d9c00985 	stb	r7,38(sp)
 4020554:	da0009c5 	stb	r8,39(sp)
 4020558:	da400a05 	stb	r9,40(sp)
 402055c:	d8800a45 	stb	r2,41(sp)
 4020560:	d9000a85 	stb	r4,42(sp)
 4020564:	d8c00ac5 	stb	r3,43(sp)
 4020568:	da800b05 	stb	r10,44(sp)
 402056c:	dcc00944 	addi	r19,sp,37
 4020570:	db800104 	addi	r14,sp,4
 4020574:	adc00404 	addi	r23,r21,16
 4020578:	dd000284 	addi	r20,sp,10
		uchar Rn[4]; /* New value of R, as we manipulate it.         */
		uchar SubK[6]; /* The 48-bit subkey.                           */

		/* Generate the subkey for this round.
		 */
		KeyShift(K, KeyRotation[i]);
 402057c:	aa000003 	ldbu	r8,0(r21)

static void KeyShift(uchar *key, const int numbits)

{
	int i;
	uchar keep = key[0]; /* Copy the highest order bits of the key. */
 4020580:	d9800783 	ldbu	r6,30(sp)

	/* Repeat the shift process <numbits> times.
	 */
	for (i = 0; i < numbits; i++) {
 4020584:	40003326 	beq	r8,zero,4020654 <auth_DEShash+0x328>
	dst[2] = D[6];
	dst[3] = D[7];
	dst[4] = D[0];
	dst[5] = D[1];
	dst[6] = D[2];
	dst[7] = D[3];
 4020588:	000f883a 	mov	r7,zero
		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
			if (j && (key[j] & 0x80)) /* If the top bit of this byte is set. */
				key[j - 1] |= 0x01; /* ...shift it to last byte's low bit. */
			key[j] <<= 1; /* Then left-shift the whole byte.     */
 402058c:	78800003 	ldbu	r2,0(r15)
	for (i = 0; i < numbits; i++) {
		int j;

		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
 4020590:	01400044 	movi	r5,1
 4020594:	0009883a 	mov	r4,zero
			if (j && (key[j] & 0x80)) /* If the top bit of this byte is set. */
				key[j - 1] |= 0x01; /* ...shift it to last byte's low bit. */
			key[j] <<= 1; /* Then left-shift the whole byte.     */
 4020598:	1085883a 	add	r2,r2,r2
 402059c:	78800005 	stb	r2,0(r15)
	int i;
	uchar keep = key[0]; /* Copy the highest order bits of the key. */

	/* Repeat the shift process <numbits> times.
	 */
	for (i = 0; i < numbits; i++) {
 40205a0:	7907883a 	add	r3,r15,r4
 40205a4:	2809883a 	mov	r4,r5
 40205a8:	18c00044 	addi	r3,r3,1
		int j;

		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
			if (j && (key[j] & 0x80)) /* If the top bit of this byte is set. */
 40205ac:	20001b26 	beq	r4,zero,402061c <auth_DEShash+0x2f0>
 40205b0:	7907883a 	add	r3,r15,r4
 40205b4:	18800007 	ldb	r2,0(r3)
 40205b8:	10001d16 	blt	r2,zero,4020630 <auth_DEShash+0x304>
				key[j - 1] |= 0x01; /* ...shift it to last byte's low bit. */
			key[j] <<= 1; /* Then left-shift the whole byte.     */
 40205bc:	18800003 	ldbu	r2,0(r3)
	for (i = 0; i < numbits; i++) {
		int j;

		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
 40205c0:	21400044 	addi	r5,r4,1
			if (j && (key[j] & 0x80)) /* If the top bit of this byte is set. */
				key[j - 1] |= 0x01; /* ...shift it to last byte's low bit. */
			key[j] <<= 1; /* Then left-shift the whole byte.     */
 40205c4:	1085883a 	add	r2,r2,r2
 40205c8:	18800005 	stb	r2,0(r3)
	for (i = 0; i < numbits; i++) {
		int j;

		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
 40205cc:	00c00184 	movi	r3,6
 40205d0:	197ff30e 	bge	r3,r5,40205a0 <auth_DEShash+0x274>
		/* Now move the high-order bits of each 28-bit half-key to their
		 * correct locations.
		 * Bit 27 is the lowest order bit of the first half-key.
		 * Before the shift, it was the highest order bit of the 2nd half-key.
		 */
		if (GETBIT( key, 27 )) /* If bit 27 is set... */
 40205d4:	d8c00843 	ldbu	r3,33(sp)
 40205d8:	1804d13a 	srli	r2,r3,4
 40205dc:	1080004c 	andi	r2,r2,1
 40205e0:	1005003a 	cmpeq	r2,r2,zero
 40205e4:	1000051e 	bne	r2,zero,40205fc <auth_DEShash+0x2d0>
		{
			CLRBIT( key, 27 ); /* ...clear bit 27. */
			SETBIT( key, 55 ); /* ...set lowest order bit of 2nd half-key. */
 40205e8:	d8800903 	ldbu	r2,36(sp)
		 * Bit 27 is the lowest order bit of the first half-key.
		 * Before the shift, it was the highest order bit of the 2nd half-key.
		 */
		if (GETBIT( key, 27 )) /* If bit 27 is set... */
		{
			CLRBIT( key, 27 ); /* ...clear bit 27. */
 40205ec:	18c03bcc 	andi	r3,r3,239
 40205f0:	d8c00845 	stb	r3,33(sp)
			SETBIT( key, 55 ); /* ...set lowest order bit of 2nd half-key. */
 40205f4:	10800054 	ori	r2,r2,1
 40205f8:	d8800905 	stb	r2,36(sp)
		}

		/* We kept the highest order bit of the first half-key in <keep>.
		 * If it's set, copy it to bit 27.
		 */
		if (keep & 0x80)
 40205fc:	30803fcc 	andi	r2,r6,255
 4020600:	1080201c 	xori	r2,r2,128
 4020604:	10bfe004 	addi	r2,r2,-128
 4020608:	10000d16 	blt	r2,zero,4020640 <auth_DEShash+0x314>
	int i;
	uchar keep = key[0]; /* Copy the highest order bits of the key. */

	/* Repeat the shift process <numbits> times.
	 */
	for (i = 0; i < numbits; i++) {
 402060c:	39c00044 	addi	r7,r7,1
 4020610:	41c01026 	beq	r8,r7,4020654 <auth_DEShash+0x328>
			SETBIT( key, 27 );

		/* Rotate the <keep> byte too, in case <numbits> is 2 and there's
		 * a second round coming.
		 */
		keep <<= 1;
 4020614:	318d883a 	add	r6,r6,r6
 4020618:	003fdc06 	br	402058c <auth_DEShash+0x260>
		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
			if (j && (key[j] & 0x80)) /* If the top bit of this byte is set. */
				key[j - 1] |= 0x01; /* ...shift it to last byte's low bit. */
			key[j] <<= 1; /* Then left-shift the whole byte.     */
 402061c:	18800003 	ldbu	r2,0(r3)
 4020620:	01000044 	movi	r4,1
 4020624:	1085883a 	add	r2,r2,r2
 4020628:	18800005 	stb	r2,0(r3)
 402062c:	003fde06 	br	40205a8 <auth_DEShash+0x27c>

		/* Shift the entire thing, byte by byte.
		 */
		for (j = 0; j < 7; j++) {
			if (j && (key[j] & 0x80)) /* If the top bit of this byte is set. */
				key[j - 1] |= 0x01; /* ...shift it to last byte's low bit. */
 4020630:	18bfffc3 	ldbu	r2,-1(r3)
 4020634:	10800054 	ori	r2,r2,1
 4020638:	18bfffc5 	stb	r2,-1(r3)
 402063c:	003fdf06 	br	40205bc <auth_DEShash+0x290>

		/* We kept the highest order bit of the first half-key in <keep>.
		 * If it's set, copy it to bit 27.
		 */
		if (keep & 0x80)
			SETBIT( key, 27 );
 4020640:	d8800843 	ldbu	r2,33(sp)
	int i;
	uchar keep = key[0]; /* Copy the highest order bits of the key. */

	/* Repeat the shift process <numbits> times.
	 */
	for (i = 0; i < numbits; i++) {
 4020644:	39c00044 	addi	r7,r7,1

		/* We kept the highest order bit of the first half-key in <keep>.
		 * If it's set, copy it to bit 27.
		 */
		if (keep & 0x80)
			SETBIT( key, 27 );
 4020648:	10800414 	ori	r2,r2,16
 402064c:	d8800845 	stb	r2,33(sp)
	int i;
	uchar keep = key[0]; /* Copy the highest order bits of the key. */

	/* Repeat the shift process <numbits> times.
	 */
	for (i = 0; i < numbits; i++) {
 4020650:	41fff01e 	bne	r8,r7,4020614 <auth_DEShash+0x2e8>
	int i;

	/* Clear all bits in the destination.
	 */
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;
 4020654:	000d883a 	mov	r6,zero
 4020658:	01c100f4 	movhi	r7,1027
 402065c:	39f4a304 	addi	r7,r7,-11636
 4020660:	02c001c4 	movi	r11,7
 4020664:	02800044 	movi	r10,1
 4020668:	02600034 	movhi	r9,32768
 402066c:	4a4001c4 	addi	r9,r9,7
 4020670:	033ffe04 	movi	r12,-8
 4020674:	02000c04 	movi	r8,48
 4020678:	d8000285 	stb	zero,10(sp)
 402067c:	d80002c5 	stb	zero,11(sp)
 4020680:	d8000305 	stb	zero,12(sp)
 4020684:	d8000345 	stb	zero,13(sp)
 4020688:	d8000385 	stb	zero,14(sp)
 402068c:	d80003c5 	stb	zero,15(sp)
 4020690:	00000a06 	br	40206bc <auth_DEShash+0x390>

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
			SETBIT( dst, i );
 4020694:	1805d0fa 	srai	r2,r3,3
 4020698:	a089883a 	add	r4,r20,r2
 402069c:	28001916 	blt	r5,zero,4020704 <auth_DEShash+0x3d8>
 40206a0:	5945c83a 	sub	r2,r11,r5
 40206a4:	20c00003 	ldbu	r3,0(r4)
 40206a8:	5084983a 	sll	r2,r10,r2
 40206ac:	10c4b03a 	or	r2,r2,r3
 40206b0:	20800005 	stb	r2,0(r4)
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 40206b4:	31800044 	addi	r6,r6,1
 40206b8:	32001626 	beq	r6,r8,4020714 <auth_DEShash+0x3e8>
		if (GETBIT( src, map[i] ))
 40206bc:	39000003 	ldbu	r4,0(r7)
			SETBIT( dst, i );
 40206c0:	324a703a 	and	r5,r6,r9
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 40206c4:	39c00044 	addi	r7,r7,1
		if (GETBIT( src, map[i] ))
 40206c8:	2006d0fa 	srli	r3,r4,3
 40206cc:	0108303a 	nor	r4,zero,r4
 40206d0:	210001cc 	andi	r4,r4,7
 40206d4:	78c7883a 	add	r3,r15,r3
 40206d8:	18800003 	ldbu	r2,0(r3)
			SETBIT( dst, i );
 40206dc:	3007883a 	mov	r3,r6
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
 40206e0:	1105d83a 	sra	r2,r2,r4
 40206e4:	1080004c 	andi	r2,r2,1
 40206e8:	1005003a 	cmpeq	r2,r2,zero
 40206ec:	103ff11e 	bne	r2,zero,40206b4 <auth_DEShash+0x388>
			SETBIT( dst, i );
 40206f0:	303fe80e 	bge	r6,zero,4020694 <auth_DEShash+0x368>
 40206f4:	30c001c4 	addi	r3,r6,7
 40206f8:	1805d0fa 	srai	r2,r3,3
 40206fc:	a089883a 	add	r4,r20,r2
 4020700:	283fe70e 	bge	r5,zero,40206a0 <auth_DEShash+0x374>
 4020704:	297fffc4 	addi	r5,r5,-1
 4020708:	2b0ab03a 	or	r5,r5,r12
 402070c:	29400044 	addi	r5,r5,1
 4020710:	003fe306 	br	40206a0 <auth_DEShash+0x374>
	int i;

	/* Clear all bits in the destination.
	 */
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;
 4020714:	000d883a 	mov	r6,zero
 4020718:	01c100f4 	movhi	r7,1027
 402071c:	39f4af04 	addi	r7,r7,-11588
 4020720:	02c001c4 	movi	r11,7
 4020724:	02800044 	movi	r10,1
 4020728:	02600034 	movhi	r9,32768
 402072c:	4a4001c4 	addi	r9,r9,7
 4020730:	033ffe04 	movi	r12,-8
 4020734:	02000c04 	movi	r8,48
 4020738:	d8000105 	stb	zero,4(sp)
 402073c:	d8000145 	stb	zero,5(sp)
 4020740:	d8000185 	stb	zero,6(sp)
 4020744:	d80001c5 	stb	zero,7(sp)
 4020748:	d8000205 	stb	zero,8(sp)
 402074c:	d8000245 	stb	zero,9(sp)
 4020750:	00000a06 	br	402077c <auth_DEShash+0x450>

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
			SETBIT( dst, i );
 4020754:	1805d0fa 	srai	r2,r3,3
 4020758:	7089883a 	add	r4,r14,r2
 402075c:	28001916 	blt	r5,zero,40207c4 <auth_DEShash+0x498>
 4020760:	5945c83a 	sub	r2,r11,r5
 4020764:	20c00003 	ldbu	r3,0(r4)
 4020768:	5084983a 	sll	r2,r10,r2
 402076c:	10c4b03a 	or	r2,r2,r3
 4020770:	20800005 	stb	r2,0(r4)
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 4020774:	31800044 	addi	r6,r6,1
 4020778:	32001626 	beq	r6,r8,40207d4 <auth_DEShash+0x4a8>
		if (GETBIT( src, map[i] ))
 402077c:	39000003 	ldbu	r4,0(r7)
			SETBIT( dst, i );
 4020780:	324a703a 	and	r5,r6,r9
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 4020784:	39c00044 	addi	r7,r7,1
		if (GETBIT( src, map[i] ))
 4020788:	2006d0fa 	srli	r3,r4,3
 402078c:	0108303a 	nor	r4,zero,r4
 4020790:	210001cc 	andi	r4,r4,7
 4020794:	98c7883a 	add	r3,r19,r3
 4020798:	18800103 	ldbu	r2,4(r3)
			SETBIT( dst, i );
 402079c:	3007883a 	mov	r3,r6
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
 40207a0:	1105d83a 	sra	r2,r2,r4
 40207a4:	1080004c 	andi	r2,r2,1
 40207a8:	1005003a 	cmpeq	r2,r2,zero
 40207ac:	103ff11e 	bne	r2,zero,4020774 <auth_DEShash+0x448>
			SETBIT( dst, i );
 40207b0:	303fe80e 	bge	r6,zero,4020754 <auth_DEShash+0x428>
 40207b4:	30c001c4 	addi	r3,r6,7
 40207b8:	1805d0fa 	srai	r2,r3,3
 40207bc:	7089883a 	add	r4,r14,r2
 40207c0:	283fe70e 	bge	r5,zero,4020760 <auth_DEShash+0x434>
 40207c4:	297fffc4 	addi	r5,r5,-1
 40207c8:	2b0ab03a 	or	r5,r5,r12
 40207cc:	29400044 	addi	r5,r5,1
 40207d0:	003fe306 	br	4020760 <auth_DEShash+0x434>

{
	int i;

	for (i = 0; i < count; i++)
		dst[i] = a[i] ^ b[i];
 40207d4:	da000103 	ldbu	r8,4(sp)
 40207d8:	d8800283 	ldbu	r2,10(sp)
 40207dc:	d9c00143 	ldbu	r7,5(sp)
 40207e0:	d9800183 	ldbu	r6,6(sp)
 40207e4:	4090f03a 	xor	r8,r8,r2
 40207e8:	d88002c3 	ldbu	r2,11(sp)
 40207ec:	d94001c3 	ldbu	r5,7(sp)
 40207f0:	d9000203 	ldbu	r4,8(sp)
 40207f4:	388ef03a 	xor	r7,r7,r2
 40207f8:	d8800303 	ldbu	r2,12(sp)
 40207fc:	d8c00243 	ldbu	r3,9(sp)
 4020800:	044100f4 	movhi	r17,1027
 4020804:	8c74c304 	addi	r17,r17,-11508
 4020808:	308cf03a 	xor	r6,r6,r2
 402080c:	d8800343 	ldbu	r2,13(sp)
 4020810:	d9c00145 	stb	r7,5(sp)
	int i;

	/* Clear the destination array.
	 */
	for (i = 0; i < 4; i++)
		dst[i] = 0;
 4020814:	001b883a 	mov	r13,zero

{
	int i;

	for (i = 0; i < count; i++)
		dst[i] = a[i] ^ b[i];
 4020818:	288af03a 	xor	r5,r5,r2
 402081c:	d8800383 	ldbu	r2,14(sp)
	int i;

	/* Clear the destination array.
	 */
	for (i = 0; i < 4; i++)
		dst[i] = 0;
 4020820:	000f883a 	mov	r7,zero
 4020824:	04bffe04 	movi	r18,-8

{
	int i;

	for (i = 0; i < count; i++)
		dst[i] = a[i] ^ b[i];
 4020828:	2088f03a 	xor	r4,r4,r2
 402082c:	d88003c3 	ldbu	r2,15(sp)
 4020830:	8821883a 	mov	r16,r17
 4020834:	da000105 	stb	r8,4(sp)
 4020838:	1886f03a 	xor	r3,r3,r2
 402083c:	d9800185 	stb	r6,6(sp)
 4020840:	d94001c5 	stb	r5,7(sp)
 4020844:	d9000205 	stb	r4,8(sp)
 4020848:	d8c00245 	stb	r3,9(sp)
	int i;

	/* Clear the destination array.
	 */
	for (i = 0; i < 4; i++)
		dst[i] = 0;
 402084c:	d8000005 	stb	zero,0(sp)
 4020850:	d8000045 	stb	zero,1(sp)
 4020854:	d8000085 	stb	zero,2(sp)
 4020858:	d80000c5 	stb	zero,3(sp)
 402085c:	00001006 	br	40208a0 <auth_DEShash+0x574>
		/* Find the correct value in the correct SBox[]
		 * and copy it into the destination.
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
			dst[i / 2] |= ((SBox[i][Snum]) << 4);
 4020860:	6804d7fa 	srli	r2,r13,31
 4020864:	8107883a 	add	r3,r16,r4
 4020868:	19000003 	ldbu	r4,0(r3)
 402086c:	1345883a 	add	r2,r2,r13
 4020870:	1005d07a 	srai	r2,r2,1
 4020874:	2008913a 	slli	r4,r4,4
	for (i = 0; i < 4; i++)
		dst[i] = 0;

	/* For each set of six input bits...
	 */
	for (i = 0; i < 8; i++) {
 4020878:	6b400044 	addi	r13,r13,1
		/* Find the correct value in the correct SBox[]
		 * and copy it into the destination.
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
			dst[i / 2] |= ((SBox[i][Snum]) << 4);
 402087c:	d88b883a 	add	r5,sp,r2
 4020880:	28c00003 	ldbu	r3,0(r5)
	for (i = 0; i < 4; i++)
		dst[i] = 0;

	/* For each set of six input bits...
	 */
	for (i = 0; i < 8; i++) {
 4020884:	00800204 	movi	r2,8
 4020888:	84001004 	addi	r16,r16,64
		/* Find the correct value in the correct SBox[]
		 * and copy it into the destination.
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
			dst[i / 2] |= ((SBox[i][Snum]) << 4);
 402088c:	20c8b03a 	or	r4,r4,r3
 4020890:	29000005 	stb	r4,0(r5)
	for (i = 0; i < 4; i++)
		dst[i] = 0;

	/* For each set of six input bits...
	 */
	for (i = 0; i < 8; i++) {
 4020894:	8c401004 	addi	r17,r17,64
 4020898:	39c00184 	addi	r7,r7,6
 402089c:	68805f26 	beq	r13,r2,4020a1c <auth_DEShash+0x6f0>
	int i;

	/* Clear the destination array.
	 */
	for (i = 0; i < 4; i++)
		dst[i] = 0;
 40208a0:	39000044 	addi	r4,r7,1
 40208a4:	39800084 	addi	r6,r7,2
 40208a8:	3a0000c4 	addi	r8,r7,3
 40208ac:	3a400104 	addi	r9,r7,4
 40208b0:	3a800144 	addi	r10,r7,5
		/* Extract the 6-bit integer from the source.
		 * This will be the lookup key within the SBox[i] array.
		 */
		for (Snum = j = 0, bitnum = (i * 6); j < 6; j++, bitnum++) {
			Snum <<= 1;
			Snum |= GETBIT( src, bitnum );
 40208b4:	3805883a 	mov	r2,r7
 40208b8:	3800a816 	blt	r7,zero,4020b5c <auth_DEShash+0x830>
 40208bc:	1005d0fa 	srai	r2,r2,3
 40208c0:	03200034 	movhi	r12,32768
 40208c4:	630001c4 	addi	r12,r12,7
 40208c8:	3b06703a 	and	r3,r7,r12
 40208cc:	7085883a 	add	r2,r14,r2
 40208d0:	11400003 	ldbu	r5,0(r2)
 40208d4:	18009d16 	blt	r3,zero,4020b4c <auth_DEShash+0x820>
 40208d8:	02c001c4 	movi	r11,7
 40208dc:	58c5c83a 	sub	r2,r11,r3
 40208e0:	2885d83a 	sra	r2,r5,r2
 40208e4:	2007883a 	mov	r3,r4
 40208e8:	1080004c 	andi	r2,r2,1
 40208ec:	108b883a 	add	r5,r2,r2
 40208f0:	20009416 	blt	r4,zero,4020b44 <auth_DEShash+0x818>
 40208f4:	1805d0fa 	srai	r2,r3,3
 40208f8:	2306703a 	and	r3,r4,r12
 40208fc:	7085883a 	add	r2,r14,r2
 4020900:	11000003 	ldbu	r4,0(r2)
 4020904:	18008b16 	blt	r3,zero,4020b34 <auth_DEShash+0x808>
 4020908:	58c5c83a 	sub	r2,r11,r3
 402090c:	2085d83a 	sra	r2,r4,r2
 4020910:	3007883a 	mov	r3,r6
 4020914:	1080004c 	andi	r2,r2,1
 4020918:	2884b03a 	or	r2,r5,r2
 402091c:	108b883a 	add	r5,r2,r2
 4020920:	30008216 	blt	r6,zero,4020b2c <auth_DEShash+0x800>
 4020924:	1805d0fa 	srai	r2,r3,3
 4020928:	3306703a 	and	r3,r6,r12
 402092c:	7085883a 	add	r2,r14,r2
 4020930:	11000003 	ldbu	r4,0(r2)
 4020934:	18007916 	blt	r3,zero,4020b1c <auth_DEShash+0x7f0>
 4020938:	58c5c83a 	sub	r2,r11,r3
 402093c:	2085d83a 	sra	r2,r4,r2
 4020940:	4007883a 	mov	r3,r8
 4020944:	1080004c 	andi	r2,r2,1
 4020948:	2884b03a 	or	r2,r5,r2
 402094c:	108b883a 	add	r5,r2,r2
 4020950:	40007016 	blt	r8,zero,4020b14 <auth_DEShash+0x7e8>
 4020954:	1805d0fa 	srai	r2,r3,3
 4020958:	4306703a 	and	r3,r8,r12
 402095c:	7085883a 	add	r2,r14,r2
 4020960:	11000003 	ldbu	r4,0(r2)
 4020964:	18006716 	blt	r3,zero,4020b04 <auth_DEShash+0x7d8>
 4020968:	58c5c83a 	sub	r2,r11,r3
 402096c:	2085d83a 	sra	r2,r4,r2
 4020970:	4807883a 	mov	r3,r9
 4020974:	1080004c 	andi	r2,r2,1
 4020978:	2884b03a 	or	r2,r5,r2
 402097c:	108b883a 	add	r5,r2,r2
 4020980:	48005e16 	blt	r9,zero,4020afc <auth_DEShash+0x7d0>
 4020984:	1805d0fa 	srai	r2,r3,3
 4020988:	4b06703a 	and	r3,r9,r12
 402098c:	7085883a 	add	r2,r14,r2
 4020990:	11000003 	ldbu	r4,0(r2)
 4020994:	18005516 	blt	r3,zero,4020aec <auth_DEShash+0x7c0>
 4020998:	58c5c83a 	sub	r2,r11,r3
 402099c:	2085d83a 	sra	r2,r4,r2
 40209a0:	5007883a 	mov	r3,r10
 40209a4:	1080004c 	andi	r2,r2,1
 40209a8:	2884b03a 	or	r2,r5,r2
 40209ac:	108b883a 	add	r5,r2,r2
 40209b0:	50004c16 	blt	r10,zero,4020ae4 <auth_DEShash+0x7b8>
 40209b4:	1805d0fa 	srai	r2,r3,3
 40209b8:	5306703a 	and	r3,r10,r12
 40209bc:	7085883a 	add	r2,r14,r2
 40209c0:	11000003 	ldbu	r4,0(r2)
 40209c4:	18004316 	blt	r3,zero,4020ad4 <auth_DEShash+0x7a8>
 40209c8:	58c5c83a 	sub	r2,r11,r3
 40209cc:	2085d83a 	sra	r2,r4,r2

		/* Find the correct value in the correct SBox[]
		 * and copy it into the destination.
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
 40209d0:	68c0004c 	andi	r3,r13,1
		/* Extract the 6-bit integer from the source.
		 * This will be the lookup key within the SBox[i] array.
		 */
		for (Snum = j = 0, bitnum = (i * 6); j < 6; j++, bitnum++) {
			Snum <<= 1;
			Snum |= GETBIT( src, bitnum );
 40209d4:	1080004c 	andi	r2,r2,1
 40209d8:	2888b03a 	or	r4,r5,r2

		/* Find the correct value in the correct SBox[]
		 * and copy it into the destination.
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
 40209dc:	183fa026 	beq	r3,zero,4020860 <auth_DEShash+0x534>
			dst[i / 2] |= ((SBox[i][Snum]) << 4);
		else
			dst[i / 2] |= SBox[i][Snum];
 40209e0:	6806d7fa 	srli	r3,r13,31
 40209e4:	8905883a 	add	r2,r17,r4
 40209e8:	11400003 	ldbu	r5,0(r2)
 40209ec:	1b47883a 	add	r3,r3,r13
 40209f0:	1807d07a 	srai	r3,r3,1
	for (i = 0; i < 4; i++)
		dst[i] = 0;

	/* For each set of six input bits...
	 */
	for (i = 0; i < 8; i++) {
 40209f4:	6b400044 	addi	r13,r13,1
 40209f8:	84001004 	addi	r16,r16,64
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
			dst[i / 2] |= ((SBox[i][Snum]) << 4);
		else
			dst[i / 2] |= SBox[i][Snum];
 40209fc:	d8c9883a 	add	r4,sp,r3
 4020a00:	20800003 	ldbu	r2,0(r4)
	for (i = 0; i < 4; i++)
		dst[i] = 0;

	/* For each set of six input bits...
	 */
	for (i = 0; i < 8; i++) {
 4020a04:	8c401004 	addi	r17,r17,64
 4020a08:	39c00184 	addi	r7,r7,6
		 * Left shift the nibble four bytes for even values of <i>.
		 */
		if (0 == (i % 2))
			dst[i / 2] |= ((SBox[i][Snum]) << 4);
		else
			dst[i / 2] |= SBox[i][Snum];
 4020a0c:	1144b03a 	or	r2,r2,r5
 4020a10:	20800005 	stb	r2,0(r4)
	for (i = 0; i < 4; i++)
		dst[i] = 0;

	/* For each set of six input bits...
	 */
	for (i = 0; i < 8; i++) {
 4020a14:	00800204 	movi	r2,8
 4020a18:	68bfa11e 	bne	r13,r2,40208a0 <auth_DEShash+0x574>
	int i;

	/* Clear all bits in the destination.
	 */
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;
 4020a1c:	000f883a 	mov	r7,zero
 4020a20:	020100f4 	movhi	r8,1027
 4020a24:	4234bb04 	addi	r8,r8,-11540
 4020a28:	030001c4 	movi	r12,7
 4020a2c:	02c00044 	movi	r11,1
 4020a30:	02a00034 	movhi	r10,32768
 4020a34:	528001c4 	addi	r10,r10,7
 4020a38:	037ffe04 	movi	r13,-8
 4020a3c:	02400804 	movi	r9,32
 4020a40:	d8000105 	stb	zero,4(sp)
 4020a44:	d8000145 	stb	zero,5(sp)
 4020a48:	d8000185 	stb	zero,6(sp)
 4020a4c:	d80001c5 	stb	zero,7(sp)
 4020a50:	00000a06 	br	4020a7c <auth_DEShash+0x750>

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
			SETBIT( dst, i );
 4020a54:	1805d0fa 	srai	r2,r3,3
 4020a58:	7089883a 	add	r4,r14,r2
 4020a5c:	30001916 	blt	r6,zero,4020ac4 <auth_DEShash+0x798>
 4020a60:	6185c83a 	sub	r2,r12,r6
 4020a64:	20c00003 	ldbu	r3,0(r4)
 4020a68:	5884983a 	sll	r2,r11,r2
 4020a6c:	10c4b03a 	or	r2,r2,r3
 4020a70:	20800005 	stb	r2,0(r4)
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 4020a74:	39c00044 	addi	r7,r7,1
 4020a78:	3a403a26 	beq	r7,r9,4020b64 <auth_DEShash+0x838>
		if (GETBIT( src, map[i] ))
 4020a7c:	41000003 	ldbu	r4,0(r8)
			SETBIT( dst, i );
 4020a80:	3a8c703a 	and	r6,r7,r10
	for (i = 0; i < mapsize; i++)
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
 4020a84:	42000044 	addi	r8,r8,1
		if (GETBIT( src, map[i] ))
 4020a88:	200ad0fa 	srli	r5,r4,3
 4020a8c:	0108303a 	nor	r4,zero,r4
 4020a90:	210001cc 	andi	r4,r4,7
 4020a94:	d947883a 	add	r3,sp,r5
 4020a98:	18800003 	ldbu	r2,0(r3)
			SETBIT( dst, i );
 4020a9c:	3807883a 	mov	r3,r7
		dst[i] = 0;

	/* Set destination bit if the mapped source bit it set. */
	bitcount = mapsize * 8;
	for (i = 0; i < bitcount; i++) {
		if (GETBIT( src, map[i] ))
 4020aa0:	1105d83a 	sra	r2,r2,r4
 4020aa4:	1080004c 	andi	r2,r2,1
 4020aa8:	1005003a 	cmpeq	r2,r2,zero
 4020aac:	103ff11e 	bne	r2,zero,4020a74 <auth_DEShash+0x748>
			SETBIT( dst, i );
 4020ab0:	383fe80e 	bge	r7,zero,4020a54 <auth_DEShash+0x728>
 4020ab4:	38c001c4 	addi	r3,r7,7
 4020ab8:	1805d0fa 	srai	r2,r3,3
 4020abc:	7089883a 	add	r4,r14,r2
 4020ac0:	303fe70e 	bge	r6,zero,4020a60 <auth_DEShash+0x734>
 4020ac4:	31bfffc4 	addi	r6,r6,-1
 4020ac8:	334cb03a 	or	r6,r6,r13
 4020acc:	31800044 	addi	r6,r6,1
 4020ad0:	003fe306 	br	4020a60 <auth_DEShash+0x734>
		/* Extract the 6-bit integer from the source.
		 * This will be the lookup key within the SBox[i] array.
		 */
		for (Snum = j = 0, bitnum = (i * 6); j < 6; j++, bitnum++) {
			Snum <<= 1;
			Snum |= GETBIT( src, bitnum );
 4020ad4:	18ffffc4 	addi	r3,r3,-1
 4020ad8:	1c86b03a 	or	r3,r3,r18
 4020adc:	18c00044 	addi	r3,r3,1
 4020ae0:	003fb906 	br	40209c8 <auth_DEShash+0x69c>
 4020ae4:	50c001c4 	addi	r3,r10,7
 4020ae8:	003fb206 	br	40209b4 <auth_DEShash+0x688>
 4020aec:	18ffffc4 	addi	r3,r3,-1
 4020af0:	1c86b03a 	or	r3,r3,r18
 4020af4:	18c00044 	addi	r3,r3,1
 4020af8:	003fa706 	br	4020998 <auth_DEShash+0x66c>
 4020afc:	38c002c4 	addi	r3,r7,11
 4020b00:	003fa006 	br	4020984 <auth_DEShash+0x658>
 4020b04:	18ffffc4 	addi	r3,r3,-1
 4020b08:	1c86b03a 	or	r3,r3,r18
 4020b0c:	18c00044 	addi	r3,r3,1
 4020b10:	003f9506 	br	4020968 <auth_DEShash+0x63c>
 4020b14:	38c00284 	addi	r3,r7,10
 4020b18:	003f8e06 	br	4020954 <auth_DEShash+0x628>
 4020b1c:	18ffffc4 	addi	r3,r3,-1
 4020b20:	1c86b03a 	or	r3,r3,r18
 4020b24:	18c00044 	addi	r3,r3,1
 4020b28:	003f8306 	br	4020938 <auth_DEShash+0x60c>
 4020b2c:	38c00244 	addi	r3,r7,9
 4020b30:	003f7c06 	br	4020924 <auth_DEShash+0x5f8>
 4020b34:	18ffffc4 	addi	r3,r3,-1
 4020b38:	1c86b03a 	or	r3,r3,r18
 4020b3c:	18c00044 	addi	r3,r3,1
 4020b40:	003f7106 	br	4020908 <auth_DEShash+0x5dc>
 4020b44:	38c00204 	addi	r3,r7,8
 4020b48:	003f6a06 	br	40208f4 <auth_DEShash+0x5c8>
 4020b4c:	18ffffc4 	addi	r3,r3,-1
 4020b50:	1c86b03a 	or	r3,r3,r18
 4020b54:	18c00044 	addi	r3,r3,1
 4020b58:	003f5f06 	br	40208d8 <auth_DEShash+0x5ac>
 4020b5c:	388001c4 	addi	r2,r7,7
 4020b60:	003f5606 	br	40208bc <auth_DEShash+0x590>

{
	int i;

	for (i = 0; i < count; i++)
		dst[i] = a[i] ^ b[i];
 4020b64:	d9400943 	ldbu	r5,37(sp)
 4020b68:	d8800103 	ldbu	r2,4(sp)
 4020b6c:	d9c00983 	ldbu	r7,38(sp)
 4020b70:	da0009c3 	ldbu	r8,39(sp)
 4020b74:	2884f03a 	xor	r2,r5,r2
 4020b78:	da400a03 	ldbu	r9,40(sp)
 4020b7c:	d8800005 	stb	r2,0(sp)
 4020b80:	d9000143 	ldbu	r4,5(sp)
 4020b84:	d8c00183 	ldbu	r3,6(sp)
 4020b88:	d88001c3 	ldbu	r2,7(sp)
 4020b8c:	3908f03a 	xor	r4,r7,r4
 4020b90:	40c6f03a 	xor	r3,r8,r3
 4020b94:	4884f03a 	xor	r2,r9,r2

		/* The previous R becomes the new L,
		 * and Rn is moved into R ready for the next round.
		 */
		for (j = 0; j < 4; j++) {
			L[j] = R[j];
 4020b98:	d9400a43 	ldbu	r5,41(sp)
 4020b9c:	d9c00a83 	ldbu	r7,42(sp)
 4020ba0:	da000ac3 	ldbu	r8,43(sp)
 4020ba4:	da400b03 	ldbu	r9,44(sp)
			R[j] = Rn[j];
 4020ba8:	d9800003 	ldbu	r6,0(sp)
 4020bac:	ad400044 	addi	r21,r21,1
 4020bb0:	d9000a85 	stb	r4,42(sp)
 4020bb4:	d8c00ac5 	stb	r3,43(sp)
 4020bb8:	d8800b05 	stb	r2,44(sp)

{
	int i;

	for (i = 0; i < count; i++)
		dst[i] = a[i] ^ b[i];
 4020bbc:	d9000045 	stb	r4,1(sp)
 4020bc0:	d8c00085 	stb	r3,2(sp)
 4020bc4:	d88000c5 	stb	r2,3(sp)

		/* The previous R becomes the new L,
		 * and Rn is moved into R ready for the next round.
		 */
		for (j = 0; j < 4; j++) {
			L[j] = R[j];
 4020bc8:	d9400945 	stb	r5,37(sp)
			R[j] = Rn[j];
 4020bcc:	d9800a45 	stb	r6,41(sp)

		/* The previous R becomes the new L,
		 * and Rn is moved into R ready for the next round.
		 */
		for (j = 0; j < 4; j++) {
			L[j] = R[j];
 4020bd0:	d9c00985 	stb	r7,38(sp)
 4020bd4:	da0009c5 	stb	r8,39(sp)
 4020bd8:	da400a05 	stb	r9,40(sp)
#endif

	/* DES encryption proceeds in 16 rounds.
	 * The stuff inside the loop is known in the literature as "function f".
	 */
	for (i = 0; i < 16; i++)
 4020bdc:	adfe671e 	bne	r21,r23,402057c <auth_DEShash+0x250>
#else
	// since not doing FP these must be swapped
	dst[0] = D[4];
	dst[1] = D[5];
	dst[2] = D[6];
	dst[3] = D[7];
 4020be0:	b08000c5 	stb	r2,3(r22)
		printf("%02x ", dst[j]);
	}
	printf("\n");
#endif
	return (dst);
} /* auth_DEShash */
 4020be4:	b005883a 	mov	r2,r22
	// Skipping FP
#ifdef IP_FP_ON
	Permute( dst, D, FinalPermuteMap, 8 );
#else
	// since not doing FP these must be swapped
	dst[0] = D[4];
 4020be8:	b1800005 	stb	r6,0(r22)
	dst[1] = D[5];
 4020bec:	b1000045 	stb	r4,1(r22)
	dst[2] = D[6];
 4020bf0:	b0c00085 	stb	r3,2(r22)
	dst[3] = D[7];
	dst[4] = D[0];
 4020bf4:	b1400105 	stb	r5,4(r22)
	dst[5] = D[1];
 4020bf8:	b1c00145 	stb	r7,5(r22)
	dst[6] = D[2];
 4020bfc:	b2000185 	stb	r8,6(r22)
	dst[7] = D[3];
 4020c00:	b24001c5 	stb	r9,7(r22)
		printf("%02x ", dst[j]);
	}
	printf("\n");
#endif
	return (dst);
} /* auth_DEShash */
 4020c04:	ddc01317 	ldw	r23,76(sp)
 4020c08:	dd801217 	ldw	r22,72(sp)
 4020c0c:	dd401117 	ldw	r21,68(sp)
 4020c10:	dd001017 	ldw	r20,64(sp)
 4020c14:	dcc00f17 	ldw	r19,60(sp)
 4020c18:	dc800e17 	ldw	r18,56(sp)
 4020c1c:	dc400d17 	ldw	r17,52(sp)
 4020c20:	dc000c17 	ldw	r16,48(sp)
 4020c24:	dec01404 	addi	sp,sp,80
 4020c28:	f800283a 	ret

04020c2c <aes_subword>:

	return ctx;
}

inline unsigned long aes_subword(unsigned long w)
{
 4020c2c:	20bfc00c 	andi	r2,r4,65280
 4020c30:	20c03fec 	andhi	r3,r4,255
 4020c34:	200ed63a 	srli	r7,r4,24
 4020c38:	1004d23a 	srli	r2,r2,8
 4020c3c:	1806d43a 	srli	r3,r3,16
 4020c40:	014100f4 	movhi	r5,1027
 4020c44:	2944b904 	addi	r5,r5,4836
 4020c48:	1145883a 	add	r2,r2,r5
 4020c4c:	394f883a 	add	r7,r7,r5
 4020c50:	1947883a 	add	r3,r3,r5
 4020c54:	12400003 	ldbu	r9,0(r2)
 4020c58:	19800003 	ldbu	r6,0(r3)
 4020c5c:	3a000003 	ldbu	r8,0(r7)
 4020c60:	21003fcc 	andi	r4,r4,255
 4020c64:	2149883a 	add	r4,r4,r5
 4020c68:	20800003 	ldbu	r2,0(r4)
 4020c6c:	4812923a 	slli	r9,r9,8
 4020c70:	4010963a 	slli	r8,r8,24
 4020c74:	300c943a 	slli	r6,r6,16
 4020c78:	1244b03a 	or	r2,r2,r9
 4020c7c:	320cb03a 	or	r6,r6,r8
	return g_aes_sbox[w & 0x000000ff] |
		(g_aes_sbox[(w & 0x0000ff00) >> 8] << 8) |
		(g_aes_sbox[(w & 0x00ff0000) >> 16] << 16) |
		(g_aes_sbox[(w & 0xff000000) >> 24] << 24);
}
 4020c80:	1184b03a 	or	r2,r2,r6
 4020c84:	f800283a 	ret

04020c88 <aes_rotword>:

inline unsigned long aes_rotword(unsigned long w)
{
 4020c88:	20ffc00c 	andi	r3,r4,65280
 4020c8c:	1806d23a 	srli	r3,r3,8
 4020c90:	20bfffec 	andhi	r2,r4,65535
 4020c94:	2008963a 	slli	r4,r4,24
 4020c98:	1004d23a 	srli	r2,r2,8
 4020c9c:	20c8b03a 	or	r4,r4,r3
	// Should not depend on architecture, but this is only a POC
	return ((w & 0x000000ff) << 24) |
		((w & 0x0000ff00) >> 8) |
		((w & 0x00ff0000) >> 8) |
		((w & 0xff000000) >> 8);
}
 4020ca0:	2084b03a 	or	r2,r4,r2
 4020ca4:	f800283a 	ret

04020ca8 <aes_keyexpansion>:
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020ca8:	20800517 	ldw	r2,20(r4)
		((w & 0x00ff0000) >> 8) |
		((w & 0xff000000) >> 8);
}

void aes_keyexpansion(aes_ctx_t *ctx)
{
 4020cac:	defff704 	addi	sp,sp,-36
 4020cb0:	dc400115 	stw	r17,4(sp)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020cb4:	1085883a 	add	r2,r2,r2
 4020cb8:	24400417 	ldw	r17,16(r4)
 4020cbc:	1085883a 	add	r2,r2,r2
 4020cc0:	11400104 	addi	r5,r2,4
		((w & 0x00ff0000) >> 8) |
		((w & 0xff000000) >> 8);
}

void aes_keyexpansion(aes_ctx_t *ctx)
{
 4020cc4:	dd000415 	stw	r20,16(sp)
 4020cc8:	dfc00815 	stw	ra,32(sp)
 4020ccc:	ddc00715 	stw	r23,28(sp)
 4020cd0:	dd800615 	stw	r22,24(sp)
 4020cd4:	dd400515 	stw	r21,20(sp)
 4020cd8:	dcc00315 	stw	r19,12(sp)
 4020cdc:	dc800215 	stw	r18,8(sp)
 4020ce0:	dc000015 	stw	r16,0(sp)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020ce4:	8829883a 	mov	r20,r17
 4020ce8:	8940782e 	bgeu	r17,r5,4020ecc <aes_keyexpansion+0x224>
 4020cec:	88ffff24 	muli	r3,r17,-4
 4020cf0:	8c45883a 	add	r2,r17,r17
 4020cf4:	1085883a 	add	r2,r2,r2
 4020cf8:	1907883a 	add	r3,r3,r4
 4020cfc:	10c7883a 	add	r3,r2,r3
 4020d00:	10800504 	addi	r2,r2,20
 4020d04:	20a7883a 	add	r19,r4,r2
 4020d08:	282f883a 	mov	r23,r5
 4020d0c:	1d400604 	addi	r21,r3,24
 4020d10:	04800044 	movi	r18,1
 4020d14:	058100f4 	movhi	r22,1027
 4020d18:	b584b904 	addi	r22,r22,4836
 4020d1c:	00004206 	br	4020e28 <aes_keyexpansion+0x180>
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
 4020d20:	8804913a 	slli	r2,r17,4
 4020d24:	00c100f4 	movhi	r3,1027
 4020d28:	18f72704 	addi	r3,r3,-9060
 4020d2c:	1504b03a 	or	r2,r2,r20
 4020d30:	10c5883a 	add	r2,r2,r3
 4020d34:	10800003 	ldbu	r2,0(r2)
 4020d38:	1505383a 	mul	r2,r2,r20
 4020d3c:	8887c83a 	sub	r3,r17,r2
 4020d40:	1800431e 	bne	r3,zero,4020e50 <aes_keyexpansion+0x1a8>
inline unsigned long aes_rotword(unsigned long w)
{
	// May seem a bit different from the spec
	// It was changed because unsigned long is represented with little-endian convention on x86
	// Should not depend on architecture, but this is only a POC
	return ((w & 0x000000ff) << 24) |
 4020d44:	80ffc00c 	andi	r3,r16,65280
 4020d48:	813fffec 	andhi	r4,r16,65535
 4020d4c:	1806d23a 	srli	r3,r3,8
 4020d50:	8004963a 	slli	r2,r16,24
 4020d54:	2008d23a 	srli	r4,r4,8
 4020d58:	10c4b03a 	or	r2,r2,r3
 4020d5c:	1104b03a 	or	r2,r2,r4

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
 4020d60:	10ffc00c 	andi	r3,r2,65280
 4020d64:	11003fec 	andhi	r4,r2,255
 4020d68:	100ad63a 	srli	r5,r2,24
 4020d6c:	1806d23a 	srli	r3,r3,8
 4020d70:	2008d43a 	srli	r4,r4,16
 4020d74:	2d8b883a 	add	r5,r5,r22
 4020d78:	1d87883a 	add	r3,r3,r22
 4020d7c:	2589883a 	add	r4,r4,r22
 4020d80:	1a000003 	ldbu	r8,0(r3)
 4020d84:	21800003 	ldbu	r6,0(r4)
 4020d88:	29c00003 	ldbu	r7,0(r5)
 4020d8c:	10803fcc 	andi	r2,r2,255
 4020d90:	1585883a 	add	r2,r2,r22
 4020d94:	10c00003 	ldbu	r3,0(r2)
 4020d98:	4010923a 	slli	r8,r8,8
 4020d9c:	300c943a 	slli	r6,r6,16
 4020da0:	380e963a 	slli	r7,r7,24
 4020da4:	1a06b03a 	or	r3,r3,r8
 4020da8:	31ccb03a 	or	r6,r6,r7
 4020dac:	1986b03a 	or	r3,r3,r6
 4020db0:	1ca0f03a 	xor	r16,r3,r18
			rcon = aes_mul(rcon, 2);
 4020db4:	90001526 	beq	r18,zero,4020e0c <aes_keyexpansion+0x164>
 4020db8:	010100f4 	movhi	r4,1027
 4020dbc:	2104f904 	addi	r4,r4,5092
 4020dc0:	9105883a 	add	r2,r18,r4
 4020dc4:	11400003 	ldbu	r5,0(r2)
 4020dc8:	20c00083 	ldbu	r3,2(r4)
 4020dcc:	008003c4 	movi	r2,15
 4020dd0:	28e5883a 	add	r18,r5,r3
 4020dd4:	91003fd4 	ori	r4,r18,255
 4020dd8:	11004736 	bltu	r2,r4,4020ef8 <aes_keyexpansion+0x250>
 4020ddc:	9004913a 	slli	r2,r18,4
 4020de0:	00c100f4 	movhi	r3,1027
 4020de4:	18f72704 	addi	r3,r3,-9060
 4020de8:	10803fd4 	ori	r2,r2,255
 4020dec:	10c5883a 	add	r2,r2,r3
 4020df0:	10800003 	ldbu	r2,0(r2)
 4020df4:	10c03fe4 	muli	r3,r2,255
 4020df8:	008100f4 	movhi	r2,1027
 4020dfc:	10843904 	addi	r2,r2,4324
 4020e00:	90c7c83a 	sub	r3,r18,r3
 4020e04:	10c5883a 	add	r2,r2,r3
 4020e08:	14800003 	ldbu	r18,0(r2)
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4020e0c:	a8800017 	ldw	r2,0(r21)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020e10:	8c400044 	addi	r17,r17,1
 4020e14:	ad400104 	addi	r21,r21,4
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4020e18:	8084f03a 	xor	r2,r16,r2
 4020e1c:	98800115 	stw	r2,4(r19)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020e20:	9cc00104 	addi	r19,r19,4
 4020e24:	8dc0292e 	bgeu	r17,r23,4020ecc <aes_keyexpansion+0x224>
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
 4020e28:	8d06b03a 	or	r3,r17,r20
 4020e2c:	008003c4 	movi	r2,15
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
 4020e30:	9c000017 	ldw	r16,0(r19)
		if(!(i%ctx->kcol)) {
 4020e34:	10ffba2e 	bgeu	r2,r3,4020d20 <aes_keyexpansion+0x78>
 4020e38:	8809883a 	mov	r4,r17
 4020e3c:	a00b883a 	mov	r5,r20
 4020e40:	40265d40 	call	40265d4 <__divsi3>
 4020e44:	1505383a 	mul	r2,r2,r20
 4020e48:	8887c83a 	sub	r3,r17,r2
 4020e4c:	183fbd26 	beq	r3,zero,4020d44 <aes_keyexpansion+0x9c>
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
 4020e50:	00800184 	movi	r2,6
 4020e54:	153fed0e 	bge	r2,r20,4020e0c <aes_keyexpansion+0x164>
 4020e58:	00800104 	movi	r2,4
 4020e5c:	18bfeb1e 	bne	r3,r2,4020e0c <aes_keyexpansion+0x164>
	return ctx;
}

inline unsigned long aes_subword(unsigned long w)
{
	return g_aes_sbox[w & 0x000000ff] |
 4020e60:	80bfc00c 	andi	r2,r16,65280
 4020e64:	80c03fec 	andhi	r3,r16,255
 4020e68:	800ad63a 	srli	r5,r16,24
 4020e6c:	1004d23a 	srli	r2,r2,8
 4020e70:	1806d43a 	srli	r3,r3,16
 4020e74:	2d8b883a 	add	r5,r5,r22
 4020e78:	1585883a 	add	r2,r2,r22
 4020e7c:	1d87883a 	add	r3,r3,r22
 4020e80:	11c00003 	ldbu	r7,0(r2)
 4020e84:	19000003 	ldbu	r4,0(r3)
 4020e88:	29800003 	ldbu	r6,0(r5)
 4020e8c:	80803fcc 	andi	r2,r16,255
 4020e90:	1585883a 	add	r2,r2,r22
 4020e94:	10c00003 	ldbu	r3,0(r2)
 4020e98:	380e923a 	slli	r7,r7,8
 4020e9c:	2008943a 	slli	r4,r4,16
 4020ea0:	300c963a 	slli	r6,r6,24
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4020ea4:	a8800017 	ldw	r2,0(r21)
	return ctx;
}

inline unsigned long aes_subword(unsigned long w)
{
	return g_aes_sbox[w & 0x000000ff] |
 4020ea8:	19c6b03a 	or	r3,r3,r7
 4020eac:	2188b03a 	or	r4,r4,r6
 4020eb0:	1920b03a 	or	r16,r3,r4
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4020eb4:	8084f03a 	xor	r2,r16,r2
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020eb8:	8c400044 	addi	r17,r17,1
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4020ebc:	98800115 	stw	r2,4(r19)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4020ec0:	ad400104 	addi	r21,r21,4
 4020ec4:	9cc00104 	addi	r19,r19,4
 4020ec8:	8dffd736 	bltu	r17,r23,4020e28 <aes_keyexpansion+0x180>
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
	}
}
 4020ecc:	dfc00817 	ldw	ra,32(sp)
 4020ed0:	ddc00717 	ldw	r23,28(sp)
 4020ed4:	dd800617 	ldw	r22,24(sp)
 4020ed8:	dd400517 	ldw	r21,20(sp)
 4020edc:	dd000417 	ldw	r20,16(sp)
 4020ee0:	dcc00317 	ldw	r19,12(sp)
 4020ee4:	dc800217 	ldw	r18,8(sp)
 4020ee8:	dc400117 	ldw	r17,4(sp)
 4020eec:	dc000017 	ldw	r16,0(sp)
 4020ef0:	dec00904 	addi	sp,sp,36
 4020ef4:	f800283a 	ret
	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
 4020ef8:	9009883a 	mov	r4,r18
 4020efc:	01403fc4 	movi	r5,255
 4020f00:	40265d40 	call	40265d4 <__divsi3>
 4020f04:	003fbb06 	br	4020df4 <aes_keyexpansion+0x14c>

04020f08 <aes_mul_manual>:
	register unsigned short ac;
	register unsigned char ret;

	ac = a;
	ret = 0;
	while(b) {
 4020f08:	29403fcc 	andi	r5,r5,255
 4020f0c:	28001026 	beq	r5,zero,4020f50 <aes_mul_manual+0x48>
inline unsigned char aes_mul_manual(unsigned char a, unsigned char b)
{
	register unsigned short ac;
	register unsigned char ret;

	ac = a;
 4020f10:	21003fcc 	andi	r4,r4,255
 4020f14:	000d883a 	mov	r6,zero
	ret = 0;
	while(b) {
		if(b & 0x01)
 4020f18:	2880004c 	andi	r2,r5,1
 4020f1c:	1005003a 	cmpeq	r2,r2,zero
			ret ^= ac;
		ac <<= 1;
 4020f20:	2107883a 	add	r3,r4,r4
	register unsigned char ret;

	ac = a;
	ret = 0;
	while(b) {
		if(b & 0x01)
 4020f24:	1000011e 	bne	r2,zero,4020f2c <aes_mul_manual+0x24>
			ret ^= ac;
 4020f28:	310cf03a 	xor	r6,r6,r4
		ac <<= 1;
 4020f2c:	1809883a 	mov	r4,r3
		b >>= 1;
		if(ac & 0x0100)
 4020f30:	2080400c 	andi	r2,r4,256
	ret = 0;
	while(b) {
		if(b & 0x01)
			ret ^= ac;
		ac <<= 1;
		b >>= 1;
 4020f34:	280ad07a 	srli	r5,r5,1
		if(ac & 0x0100)
 4020f38:	10000126 	beq	r2,zero,4020f40 <aes_mul_manual+0x38>
			ac ^= AES_RPOL;
 4020f3c:	190046dc 	xori	r4,r3,283
	register unsigned short ac;
	register unsigned char ret;

	ac = a;
	ret = 0;
	while(b) {
 4020f40:	29403fcc 	andi	r5,r5,255
 4020f44:	283ff41e 	bne	r5,zero,4020f18 <aes_mul_manual+0x10>
 4020f48:	30803fcc 	andi	r2,r6,255
		if(ac & 0x0100)
			ac ^= AES_RPOL;
	}

	return ret;
}
 4020f4c:	f800283a 	ret
	register unsigned short ac;
	register unsigned char ret;

	ac = a;
	ret = 0;
	while(b) {
 4020f50:	0005883a 	mov	r2,zero
 4020f54:	f800283a 	ret

04020f58 <aes_subbytes>:
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4020f58:	20800003 	ldbu	r2,0(r4)
 4020f5c:	014100f4 	movhi	r5,1027
 4020f60:	2944b904 	addi	r5,r5,4836
 4020f64:	20c00103 	ldbu	r3,4(r4)
 4020f68:	1145883a 	add	r2,r2,r5
 4020f6c:	11800003 	ldbu	r6,0(r2)
 4020f70:	1947883a 	add	r3,r3,r5
 4020f74:	20800203 	ldbu	r2,8(r4)
 4020f78:	21800005 	stb	r6,0(r4)
 4020f7c:	19c00003 	ldbu	r7,0(r3)
 4020f80:	1145883a 	add	r2,r2,r5
 4020f84:	20c00303 	ldbu	r3,12(r4)
 4020f88:	21c00105 	stb	r7,4(r4)
 4020f8c:	11800003 	ldbu	r6,0(r2)
 4020f90:	1947883a 	add	r3,r3,r5
 4020f94:	20800043 	ldbu	r2,1(r4)
 4020f98:	21800205 	stb	r6,8(r4)
 4020f9c:	19c00003 	ldbu	r7,0(r3)
 4020fa0:	1145883a 	add	r2,r2,r5
 4020fa4:	20c00143 	ldbu	r3,5(r4)
 4020fa8:	21c00305 	stb	r7,12(r4)
 4020fac:	11800003 	ldbu	r6,0(r2)
 4020fb0:	1947883a 	add	r3,r3,r5
 4020fb4:	20800243 	ldbu	r2,9(r4)
 4020fb8:	21800045 	stb	r6,1(r4)
 4020fbc:	19c00003 	ldbu	r7,0(r3)
 4020fc0:	1145883a 	add	r2,r2,r5
 4020fc4:	20c00343 	ldbu	r3,13(r4)
 4020fc8:	21c00145 	stb	r7,5(r4)
 4020fcc:	11800003 	ldbu	r6,0(r2)
 4020fd0:	1947883a 	add	r3,r3,r5
 4020fd4:	20800083 	ldbu	r2,2(r4)
 4020fd8:	21800245 	stb	r6,9(r4)
 4020fdc:	19c00003 	ldbu	r7,0(r3)
 4020fe0:	1145883a 	add	r2,r2,r5
 4020fe4:	20c00183 	ldbu	r3,6(r4)
 4020fe8:	21c00345 	stb	r7,13(r4)
 4020fec:	11800003 	ldbu	r6,0(r2)
 4020ff0:	1947883a 	add	r3,r3,r5
 4020ff4:	20800283 	ldbu	r2,10(r4)
 4020ff8:	21800085 	stb	r6,2(r4)
 4020ffc:	19c00003 	ldbu	r7,0(r3)
 4021000:	1145883a 	add	r2,r2,r5
 4021004:	20c00383 	ldbu	r3,14(r4)
 4021008:	21c00185 	stb	r7,6(r4)
 402100c:	11800003 	ldbu	r6,0(r2)
 4021010:	1947883a 	add	r3,r3,r5
 4021014:	21800285 	stb	r6,10(r4)
 4021018:	18800003 	ldbu	r2,0(r3)
 402101c:	20c000c3 	ldbu	r3,3(r4)
 4021020:	220002c3 	ldbu	r8,11(r4)
 4021024:	20800385 	stb	r2,14(r4)
 4021028:	1947883a 	add	r3,r3,r5
 402102c:	19c00003 	ldbu	r7,0(r3)
 4021030:	208001c3 	ldbu	r2,7(r4)
 4021034:	4151883a 	add	r8,r8,r5
 4021038:	21c000c5 	stb	r7,3(r4)
 402103c:	1145883a 	add	r2,r2,r5
 4021040:	11800003 	ldbu	r6,0(r2)
 4021044:	20c003c3 	ldbu	r3,15(r4)
 4021048:	218001c5 	stb	r6,7(r4)
 402104c:	41c00003 	ldbu	r7,0(r8)
 4021050:	1947883a 	add	r3,r3,r5
 4021054:	21c002c5 	stb	r7,11(r4)
 4021058:	18800003 	ldbu	r2,0(r3)
 402105c:	208003c5 	stb	r2,15(r4)
	}
}
 4021060:	f800283a 	ret

04021064 <aes_addroundkey>:

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 4021064:	294b883a 	add	r5,r5,r5
 4021068:	294b883a 	add	r5,r5,r5
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 402106c:	28c00044 	addi	r3,r5,1
 4021070:	29800084 	addi	r6,r5,2
 4021074:	29c000c4 	addi	r7,r5,3
 4021078:	18c7883a 	add	r3,r3,r3
 402107c:	318d883a 	add	r6,r6,r6
 4021080:	294b883a 	add	r5,r5,r5
 4021084:	39cf883a 	add	r7,r7,r7
 4021088:	294b883a 	add	r5,r5,r5
 402108c:	18c7883a 	add	r3,r3,r3
 4021090:	318d883a 	add	r6,r6,r6
 4021094:	00800604 	movi	r2,24
 4021098:	290b883a 	add	r5,r5,r4
 402109c:	1907883a 	add	r3,r3,r4
 40210a0:	310d883a 	add	r6,r6,r4
 40210a4:	39cf883a 	add	r7,r7,r7
 40210a8:	288b883a 	add	r5,r5,r2
 40210ac:	1887883a 	add	r3,r3,r2
 40210b0:	308d883a 	add	r6,r6,r2
 40210b4:	390f883a 	add	r7,r7,r4
 40210b8:	2a000017 	ldw	r8,0(r5)
 40210bc:	1a400017 	ldw	r9,0(r3)
 40210c0:	32800017 	ldw	r10,0(r6)
 40210c4:	388f883a 	add	r7,r7,r2
 40210c8:	3ac00017 	ldw	r11,0(r7)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 40210cc:	defff704 	addi	sp,sp,-36
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40210d0:	00ffc014 	movui	r3,65280
 40210d4:	01403ff4 	movhi	r5,255

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 40210d8:	dcc00315 	stw	r19,12(sp)
 40210dc:	dc800215 	stw	r18,8(sp)
 40210e0:	dc400115 	stw	r17,4(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40210e4:	48da703a 	and	r13,r9,r3
 40210e8:	40a2d83a 	srl	r17,r8,r2
 40210ec:	48a4d83a 	srl	r18,r9,r2
 40210f0:	50a6d83a 	srl	r19,r10,r2
 40210f4:	00803fc4 	movi	r2,255

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 40210f8:	dc000015 	stw	r16,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40210fc:	40ce703a 	and	r7,r8,r3
 4021100:	58e0703a 	and	r16,r11,r3
 4021104:	4158703a 	and	r12,r8,r5
 4021108:	495c703a 	and	r14,r9,r5
 402110c:	515e703a 	and	r15,r10,r5
 4021110:	588c703a 	and	r6,r11,r2
 4021114:	50c6703a 	and	r3,r10,r3
 4021118:	4090703a 	and	r8,r8,r2
 402111c:	4892703a 	and	r9,r9,r2
 4021120:	5094703a 	and	r10,r10,r2
 4021124:	681ad23a 	srli	r13,r13,8
 4021128:	20800143 	ldbu	r2,5(r4)
 402112c:	701cd43a 	srli	r14,r14,16
 4021130:	1806d23a 	srli	r3,r3,8
 4021134:	689af03a 	xor	r13,r13,r2
 4021138:	20800243 	ldbu	r2,9(r4)
 402113c:	781ed43a 	srli	r15,r15,16

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 4021140:	df000815 	stw	fp,32(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4021144:	709cf03a 	xor	r14,r14,r2
 4021148:	20800343 	ldbu	r2,13(r4)
 402114c:	27000043 	ldbu	fp,1(r4)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 4021150:	ddc00715 	stw	r23,28(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4021154:	90a4f03a 	xor	r18,r18,r2
 4021158:	20800083 	ldbu	r2,2(r4)
 402115c:	25c00303 	ldbu	r23,12(r4)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 4021160:	dd800615 	stw	r22,24(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4021164:	5094f03a 	xor	r10,r10,r2
 4021168:	20800183 	ldbu	r2,6(r4)
 402116c:	25800203 	ldbu	r22,8(r4)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 4021170:	dd400515 	stw	r21,20(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4021174:	1886f03a 	xor	r3,r3,r2
 4021178:	20800283 	ldbu	r2,10(r4)
 402117c:	25400103 	ldbu	r21,4(r4)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_addroundkey(aes_ctx_t *ctx, int round)
{
 4021180:	dd000415 	stw	r20,16(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4021184:	789ef03a 	xor	r15,r15,r2
 4021188:	20800383 	ldbu	r2,14(r4)
 402118c:	25000003 	ldbu	r20,0(r4)
 4021190:	380ed23a 	srli	r7,r7,8
 4021194:	98a6f03a 	xor	r19,r19,r2
 4021198:	208000c3 	ldbu	r2,3(r4)
 402119c:	6018d43a 	srli	r12,r12,16
 40211a0:	8020d23a 	srli	r16,r16,8
 40211a4:	308cf03a 	xor	r6,r6,r2
 40211a8:	208001c3 	ldbu	r2,7(r4)
 40211ac:	4510f03a 	xor	r8,r8,r20
 40211b0:	3d4ef03a 	xor	r7,r7,r21
 40211b4:	6598f03a 	xor	r12,r12,r22
 40211b8:	8de2f03a 	xor	r17,r17,r23
 40211bc:	4f12f03a 	xor	r9,r9,fp
 40211c0:	594a703a 	and	r5,r11,r5
 40211c4:	22000005 	stb	r8,0(r4)
 40211c8:	21c00105 	stb	r7,4(r4)
 40211cc:	23000205 	stb	r12,8(r4)
 40211d0:	24400305 	stb	r17,12(r4)
 40211d4:	22400045 	stb	r9,1(r4)
 40211d8:	23400145 	stb	r13,5(r4)
 40211dc:	23800245 	stb	r14,9(r4)
 40211e0:	80a0f03a 	xor	r16,r16,r2
 40211e4:	218000c5 	stb	r6,3(r4)
 40211e8:	208003c3 	ldbu	r2,15(r4)
 40211ec:	218002c3 	ldbu	r6,11(r4)
 40211f0:	280ad43a 	srli	r5,r5,16
 40211f4:	5816d63a 	srli	r11,r11,24
 40211f8:	24800345 	stb	r18,13(r4)
 40211fc:	298af03a 	xor	r5,r5,r6
 4021200:	5896f03a 	xor	r11,r11,r2
 4021204:	22800085 	stb	r10,2(r4)
 4021208:	20c00185 	stb	r3,6(r4)
 402120c:	23c00285 	stb	r15,10(r4)
 4021210:	24c00385 	stb	r19,14(r4)
 4021214:	240001c5 	stb	r16,7(r4)
 4021218:	214002c5 	stb	r5,11(r4)
 402121c:	22c003c5 	stb	r11,15(r4)
			((ctx->keysched[round*4+y] & (0xff << (x*8))) >> (x*8));
	}
}
 4021220:	df000817 	ldw	fp,32(sp)
 4021224:	ddc00717 	ldw	r23,28(sp)
 4021228:	dd800617 	ldw	r22,24(sp)
 402122c:	dd400517 	ldw	r21,20(sp)
 4021230:	dd000417 	ldw	r20,16(sp)
 4021234:	dcc00317 	ldw	r19,12(sp)
 4021238:	dc800217 	ldw	r18,8(sp)
 402123c:	dc400117 	ldw	r17,4(sp)
 4021240:	dc000017 	ldw	r16,0(sp)
 4021244:	dec00904 	addi	sp,sp,36
 4021248:	f800283a 	ret

0402124c <aes_invsubbytes>:
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 402124c:	20800003 	ldbu	r2,0(r4)
 4021250:	014100f4 	movhi	r5,1027
 4021254:	29447904 	addi	r5,r5,4580
 4021258:	20c00103 	ldbu	r3,4(r4)
 402125c:	1145883a 	add	r2,r2,r5
 4021260:	11800003 	ldbu	r6,0(r2)
 4021264:	1947883a 	add	r3,r3,r5
 4021268:	20800203 	ldbu	r2,8(r4)
 402126c:	21800005 	stb	r6,0(r4)
 4021270:	19c00003 	ldbu	r7,0(r3)
 4021274:	1145883a 	add	r2,r2,r5
 4021278:	20c00303 	ldbu	r3,12(r4)
 402127c:	21c00105 	stb	r7,4(r4)
 4021280:	11800003 	ldbu	r6,0(r2)
 4021284:	1947883a 	add	r3,r3,r5
 4021288:	20800043 	ldbu	r2,1(r4)
 402128c:	21800205 	stb	r6,8(r4)
 4021290:	19c00003 	ldbu	r7,0(r3)
 4021294:	1145883a 	add	r2,r2,r5
 4021298:	20c00143 	ldbu	r3,5(r4)
 402129c:	21c00305 	stb	r7,12(r4)
 40212a0:	11800003 	ldbu	r6,0(r2)
 40212a4:	1947883a 	add	r3,r3,r5
 40212a8:	20800243 	ldbu	r2,9(r4)
 40212ac:	21800045 	stb	r6,1(r4)
 40212b0:	19c00003 	ldbu	r7,0(r3)
 40212b4:	1145883a 	add	r2,r2,r5
 40212b8:	20c00343 	ldbu	r3,13(r4)
 40212bc:	21c00145 	stb	r7,5(r4)
 40212c0:	11800003 	ldbu	r6,0(r2)
 40212c4:	1947883a 	add	r3,r3,r5
 40212c8:	20800083 	ldbu	r2,2(r4)
 40212cc:	21800245 	stb	r6,9(r4)
 40212d0:	19c00003 	ldbu	r7,0(r3)
 40212d4:	1145883a 	add	r2,r2,r5
 40212d8:	20c00183 	ldbu	r3,6(r4)
 40212dc:	21c00345 	stb	r7,13(r4)
 40212e0:	11800003 	ldbu	r6,0(r2)
 40212e4:	1947883a 	add	r3,r3,r5
 40212e8:	20800283 	ldbu	r2,10(r4)
 40212ec:	21800085 	stb	r6,2(r4)
 40212f0:	19c00003 	ldbu	r7,0(r3)
 40212f4:	1145883a 	add	r2,r2,r5
 40212f8:	20c00383 	ldbu	r3,14(r4)
 40212fc:	21c00185 	stb	r7,6(r4)
 4021300:	11800003 	ldbu	r6,0(r2)
 4021304:	1947883a 	add	r3,r3,r5
 4021308:	21800285 	stb	r6,10(r4)
 402130c:	18800003 	ldbu	r2,0(r3)
 4021310:	20c000c3 	ldbu	r3,3(r4)
 4021314:	220002c3 	ldbu	r8,11(r4)
 4021318:	20800385 	stb	r2,14(r4)
 402131c:	1947883a 	add	r3,r3,r5
 4021320:	19c00003 	ldbu	r7,0(r3)
 4021324:	208001c3 	ldbu	r2,7(r4)
 4021328:	4151883a 	add	r8,r8,r5
 402132c:	21c000c5 	stb	r7,3(r4)
 4021330:	1145883a 	add	r2,r2,r5
 4021334:	11800003 	ldbu	r6,0(r2)
 4021338:	20c003c3 	ldbu	r3,15(r4)
 402133c:	218001c5 	stb	r6,7(r4)
 4021340:	41c00003 	ldbu	r7,0(r8)
 4021344:	1947883a 	add	r3,r3,r5
 4021348:	21c002c5 	stb	r7,11(r4)
 402134c:	18800003 	ldbu	r2,0(r3)
 4021350:	208003c5 	stb	r2,15(r4)
	}
}
 4021354:	f800283a 	ret

04021358 <aes_free_ctx>:
		output[i] = ctx->state[i & 0x03][i >> 2];
}

void aes_free_ctx(aes_ctx_t *ctx)
{
	free(ctx);
 4021358:	4026c601 	jmpi	4026c60 <free>

0402135c <aes_invmixcolumns>:
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
	}
}

void aes_invmixcolumns(aes_ctx_t *ctx)
{
 402135c:	deffe404 	addi	sp,sp,-112
 4021360:	dc401315 	stw	r17,76(sp)
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 4021364:	044100f4 	movhi	r17,1027
 4021368:	8c44f904 	addi	r17,r17,5092
 402136c:	88800383 	ldbu	r2,14(r17)
 4021370:	88c00243 	ldbu	r3,9(r17)
 4021374:	89800343 	ldbu	r6,13(r17)
 4021378:	d8800e15 	stw	r2,56(sp)
 402137c:	888002c3 	ldbu	r2,11(r17)
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
	}
}

void aes_invmixcolumns(aes_ctx_t *ctx)
{
 4021380:	df001a15 	stw	fp,104(sp)
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 4021384:	d8c00a15 	stw	r3,40(sp)
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
	}
}

void aes_invmixcolumns(aes_ctx_t *ctx)
{
 4021388:	d9001015 	stw	r4,64(sp)
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 402138c:	2039883a 	mov	fp,r4
 4021390:	d8c00304 	addi	r3,sp,12
 4021394:	d9000404 	addi	r4,sp,16
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
	}
}

void aes_invmixcolumns(aes_ctx_t *ctx)
{
 4021398:	dc801415 	stw	r18,80(sp)
 402139c:	dfc01b15 	stw	ra,108(sp)
 40213a0:	ddc01915 	stw	r23,100(sp)
 40213a4:	dd801815 	stw	r22,96(sp)
 40213a8:	dd401715 	stw	r21,92(sp)
 40213ac:	dd001615 	stw	r20,88(sp)
 40213b0:	dcc01515 	stw	r19,84(sp)
 40213b4:	dc001215 	stw	r16,72(sp)
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 40213b8:	d9800b15 	stw	r6,44(sp)
 40213bc:	d8800c15 	stw	r2,48(sp)
 40213c0:	d8c00415 	stw	r3,16(sp)
 40213c4:	d9001115 	stw	r4,68(sp)
 40213c8:	048003c4 	movi	r18,15
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 40213cc:	e5800003 	ldbu	r22,0(fp)
 40213d0:	b0803fcc 	andi	r2,r22,255
 40213d4:	10018d1e 	bne	r2,zero,4021a0c <aes_invmixcolumns+0x6b0>
 40213d8:	d8000f05 	stb	zero,60(sp)
 40213dc:	e5c00103 	ldbu	r23,4(fp)
 40213e0:	b8803fcc 	andi	r2,r23,255
 40213e4:	10014c1e 	bne	r2,zero,4021918 <aes_invmixcolumns+0x5bc>
 40213e8:	d8000d05 	stb	zero,52(sp)
 40213ec:	e5400203 	ldbu	r21,8(fp)
 40213f0:	a8803fcc 	andi	r2,r21,255
 40213f4:	10015e1e 	bne	r2,zero,4021970 <aes_invmixcolumns+0x614>
 40213f8:	0027883a 	mov	r19,zero
 40213fc:	e5000303 	ldbu	r20,12(fp)
 4021400:	a0803fcc 	andi	r2,r20,255
 4021404:	1001091e 	bne	r2,zero,402182c <aes_invmixcolumns+0x4d0>
 4021408:	0007883a 	mov	r3,zero
 402140c:	d9000d03 	ldbu	r4,52(sp)
 4021410:	d9800f03 	ldbu	r6,60(sp)
 4021414:	24c4f03a 	xor	r2,r4,r19
 4021418:	d9000417 	ldw	r4,16(sp)
 402141c:	30c6f03a 	xor	r3,r6,r3
 4021420:	10c4f03a 	xor	r2,r2,r3
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 4021424:	b0c03fcc 	andi	r3,r22,255
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 4021428:	20bffd05 	stb	r2,-12(r4)
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 402142c:	1801631e 	bne	r3,zero,40219bc <aes_invmixcolumns+0x660>
 4021430:	d8000905 	stb	zero,36(sp)
 4021434:	b8803fcc 	andi	r2,r23,255
 4021438:	10010f1e 	bne	r2,zero,4021878 <aes_invmixcolumns+0x51c>
 402143c:	a8803fcc 	andi	r2,r21,255
 4021440:	d8000805 	stb	zero,32(sp)
 4021444:	1001211e 	bne	r2,zero,40218cc <aes_invmixcolumns+0x570>
 4021448:	0027883a 	mov	r19,zero
 402144c:	a0803fcc 	andi	r2,r20,255
 4021450:	1000e31e 	bne	r2,zero,40217e0 <aes_invmixcolumns+0x484>
 4021454:	0007883a 	mov	r3,zero
 4021458:	d9000803 	ldbu	r4,32(sp)
 402145c:	d9800903 	ldbu	r6,36(sp)
 4021460:	24c4f03a 	xor	r2,r4,r19
 4021464:	d9000417 	ldw	r4,16(sp)
 4021468:	30c6f03a 	xor	r3,r6,r3
 402146c:	10c4f03a 	xor	r2,r2,r3
				aes_mul(0x0e, ctx->state[1][i]) ^
				aes_mul(0x0b, ctx->state[2][i]) ^
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
 4021470:	b0c03fcc 	andi	r3,r22,255
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 4021474:	20bffe05 	stb	r2,-8(r4)
				aes_mul(0x0e, ctx->state[1][i]) ^
				aes_mul(0x0b, ctx->state[2][i]) ^
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
 4021478:	1800c51e 	bne	r3,zero,4021790 <aes_invmixcolumns+0x434>
 402147c:	d8000705 	stb	zero,28(sp)
 4021480:	b8803fcc 	andi	r2,r23,255
 4021484:	10009a1e 	bne	r2,zero,40216f0 <aes_invmixcolumns+0x394>
 4021488:	a8803fcc 	andi	r2,r21,255
 402148c:	d8000605 	stb	zero,24(sp)
 4021490:	1000ac1e 	bne	r2,zero,4021744 <aes_invmixcolumns+0x3e8>
 4021494:	0027883a 	mov	r19,zero
 4021498:	a0803fcc 	andi	r2,r20,255
 402149c:	1000811e 	bne	r2,zero,40216a4 <aes_invmixcolumns+0x348>
 40214a0:	0007883a 	mov	r3,zero
 40214a4:	d9000603 	ldbu	r4,24(sp)
 40214a8:	d9800703 	ldbu	r6,28(sp)
 40214ac:	24c4f03a 	xor	r2,r4,r19
 40214b0:	d9000417 	ldw	r4,16(sp)
 40214b4:	30c6f03a 	xor	r3,r6,r3
 40214b8:	10c4f03a 	xor	r2,r2,r3
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 40214bc:	b0c03fcc 	andi	r3,r22,255
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
				aes_mul(0x0e, ctx->state[1][i]) ^
				aes_mul(0x0b, ctx->state[2][i]) ^
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
 40214c0:	20bfff05 	stb	r2,-4(r4)
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 40214c4:	1800631e 	bne	r3,zero,4021654 <aes_invmixcolumns+0x2f8>
 40214c8:	d8000505 	stb	zero,20(sp)
 40214cc:	b8803fcc 	andi	r2,r23,255
 40214d0:	10004d1e 	bne	r2,zero,4021608 <aes_invmixcolumns+0x2ac>
 40214d4:	002d883a 	mov	r22,zero
 40214d8:	a8803fcc 	andi	r2,r21,255
 40214dc:	1000371e 	bne	r2,zero,40215bc <aes_invmixcolumns+0x260>
 40214e0:	0027883a 	mov	r19,zero
 40214e4:	a0803fcc 	andi	r2,r20,255
 40214e8:	1000211e 	bne	r2,zero,4021570 <aes_invmixcolumns+0x214>
 40214ec:	0007883a 	mov	r3,zero
 40214f0:	d9000503 	ldbu	r4,20(sp)
 40214f4:	d9800417 	ldw	r6,16(sp)
 40214f8:	9d84f03a 	xor	r2,r19,r22
 40214fc:	1906f03a 	xor	r3,r3,r4
 4021500:	10c4f03a 	xor	r2,r2,r3
 4021504:	30800005 	stb	r2,0(r6)
void aes_invmixcolumns(aes_ctx_t *ctx)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
 4021508:	d8801117 	ldw	r2,68(sp)
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 402150c:	31800044 	addi	r6,r6,1
 4021510:	d9800415 	stw	r6,16(sp)
 4021514:	e7000044 	addi	fp,fp,1
void aes_invmixcolumns(aes_ctx_t *ctx)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
 4021518:	30bfac1e 	bne	r6,r2,40213cc <aes_invmixcolumns+0x70>
				aes_mul(0x0d, ctx->state[1][i]) ^
				aes_mul(0x09, ctx->state[2][i]) ^
				aes_mul(0x0e, ctx->state[3][i]);
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 402151c:	d9000117 	ldw	r4,4(sp)
 4021520:	d9400217 	ldw	r5,8(sp)
 4021524:	d8c00317 	ldw	r3,12(sp)
 4021528:	d8800017 	ldw	r2,0(sp)
 402152c:	d9801017 	ldw	r6,64(sp)
 4021530:	30800015 	stw	r2,0(r6)
 4021534:	31000115 	stw	r4,4(r6)
 4021538:	30c00315 	stw	r3,12(r6)
 402153c:	31400215 	stw	r5,8(r6)
}
 4021540:	dfc01b17 	ldw	ra,108(sp)
 4021544:	df001a17 	ldw	fp,104(sp)
 4021548:	ddc01917 	ldw	r23,100(sp)
 402154c:	dd801817 	ldw	r22,96(sp)
 4021550:	dd401717 	ldw	r21,92(sp)
 4021554:	dd001617 	ldw	r20,88(sp)
 4021558:	dcc01517 	ldw	r19,84(sp)
 402155c:	dc801417 	ldw	r18,80(sp)
 4021560:	dc401317 	ldw	r17,76(sp)
 4021564:	dc001217 	ldw	r16,72(sp)
 4021568:	dec01c04 	addi	sp,sp,112
 402156c:	f800283a 	ret
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 4021570:	1445883a 	add	r2,r2,r17
 4021574:	10c00003 	ldbu	r3,0(r2)
 4021578:	d9000e17 	ldw	r4,56(sp)
 402157c:	20e1883a 	add	r16,r4,r3
 4021580:	80803fd4 	ori	r2,r16,255
 4021584:	90813536 	bltu	r18,r2,4021a5c <aes_invmixcolumns+0x700>
 4021588:	8004913a 	slli	r2,r16,4
 402158c:	018100f4 	movhi	r6,1027
 4021590:	31b72704 	addi	r6,r6,-9060
 4021594:	10803fd4 	ori	r2,r2,255
 4021598:	1185883a 	add	r2,r2,r6
 402159c:	10800003 	ldbu	r2,0(r2)
 40215a0:	10c03fe4 	muli	r3,r2,255
 40215a4:	008100f4 	movhi	r2,1027
 40215a8:	10843904 	addi	r2,r2,4324
 40215ac:	80c7c83a 	sub	r3,r16,r3
 40215b0:	10c5883a 	add	r2,r2,r3
 40215b4:	10c00003 	ldbu	r3,0(r2)
 40215b8:	003fcd06 	br	40214f0 <aes_invmixcolumns+0x194>
 40215bc:	1445883a 	add	r2,r2,r17
 40215c0:	10c00003 	ldbu	r3,0(r2)
 40215c4:	d8800a17 	ldw	r2,40(sp)
 40215c8:	10e1883a 	add	r16,r2,r3
 40215cc:	80803fd4 	ori	r2,r16,255
 40215d0:	90812a36 	bltu	r18,r2,4021a7c <aes_invmixcolumns+0x720>
 40215d4:	8004913a 	slli	r2,r16,4
 40215d8:	00c100f4 	movhi	r3,1027
 40215dc:	18f72704 	addi	r3,r3,-9060
 40215e0:	10803fd4 	ori	r2,r2,255
 40215e4:	10c5883a 	add	r2,r2,r3
 40215e8:	10800003 	ldbu	r2,0(r2)
 40215ec:	10c03fe4 	muli	r3,r2,255
 40215f0:	008100f4 	movhi	r2,1027
 40215f4:	10843904 	addi	r2,r2,4324
 40215f8:	80c7c83a 	sub	r3,r16,r3
 40215fc:	10c5883a 	add	r2,r2,r3
 4021600:	14c00003 	ldbu	r19,0(r2)
 4021604:	003fb706 	br	40214e4 <aes_invmixcolumns+0x188>
 4021608:	1445883a 	add	r2,r2,r17
 402160c:	10c00003 	ldbu	r3,0(r2)
 4021610:	d9000b17 	ldw	r4,44(sp)
 4021614:	20e1883a 	add	r16,r4,r3
 4021618:	80803fd4 	ori	r2,r16,255
 402161c:	90811b36 	bltu	r18,r2,4021a8c <aes_invmixcolumns+0x730>
 4021620:	8004913a 	slli	r2,r16,4
 4021624:	018100f4 	movhi	r6,1027
 4021628:	31b72704 	addi	r6,r6,-9060
 402162c:	10803fd4 	ori	r2,r2,255
 4021630:	1185883a 	add	r2,r2,r6
 4021634:	10800003 	ldbu	r2,0(r2)
 4021638:	10c03fe4 	muli	r3,r2,255
 402163c:	008100f4 	movhi	r2,1027
 4021640:	10843904 	addi	r2,r2,4324
 4021644:	80c7c83a 	sub	r3,r16,r3
 4021648:	10c5883a 	add	r2,r2,r3
 402164c:	15800003 	ldbu	r22,0(r2)
 4021650:	003fa106 	br	40214d8 <aes_invmixcolumns+0x17c>
 4021654:	1c45883a 	add	r2,r3,r17
 4021658:	10c00003 	ldbu	r3,0(r2)
 402165c:	d9800c17 	ldw	r6,48(sp)
 4021660:	30e1883a 	add	r16,r6,r3
 4021664:	80803fd4 	ori	r2,r16,255
 4021668:	90810c36 	bltu	r18,r2,4021a9c <aes_invmixcolumns+0x740>
 402166c:	8004913a 	slli	r2,r16,4
 4021670:	00c100f4 	movhi	r3,1027
 4021674:	18f72704 	addi	r3,r3,-9060
 4021678:	10803fd4 	ori	r2,r2,255
 402167c:	10c5883a 	add	r2,r2,r3
 4021680:	10800003 	ldbu	r2,0(r2)
 4021684:	10c03fe4 	muli	r3,r2,255
 4021688:	008100f4 	movhi	r2,1027
 402168c:	10843904 	addi	r2,r2,4324
 4021690:	80c7c83a 	sub	r3,r16,r3
 4021694:	10c5883a 	add	r2,r2,r3
 4021698:	10800003 	ldbu	r2,0(r2)
 402169c:	d8800505 	stb	r2,20(sp)
 40216a0:	003f8a06 	br	40214cc <aes_invmixcolumns+0x170>
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
				aes_mul(0x0e, ctx->state[1][i]) ^
				aes_mul(0x0b, ctx->state[2][i]) ^
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
 40216a4:	1445883a 	add	r2,r2,r17
 40216a8:	10c00003 	ldbu	r3,0(r2)
 40216ac:	d9000c17 	ldw	r4,48(sp)
 40216b0:	20e1883a 	add	r16,r4,r3
 40216b4:	80803fd4 	ori	r2,r16,255
 40216b8:	90810036 	bltu	r18,r2,4021abc <aes_invmixcolumns+0x760>
 40216bc:	8004913a 	slli	r2,r16,4
 40216c0:	018100f4 	movhi	r6,1027
 40216c4:	31b72704 	addi	r6,r6,-9060
 40216c8:	10803fd4 	ori	r2,r2,255
 40216cc:	1185883a 	add	r2,r2,r6
 40216d0:	10800003 	ldbu	r2,0(r2)
 40216d4:	10c03fe4 	muli	r3,r2,255
 40216d8:	008100f4 	movhi	r2,1027
 40216dc:	10843904 	addi	r2,r2,4324
 40216e0:	80c7c83a 	sub	r3,r16,r3
 40216e4:	10c5883a 	add	r2,r2,r3
 40216e8:	10c00003 	ldbu	r3,0(r2)
 40216ec:	003f6d06 	br	40214a4 <aes_invmixcolumns+0x148>
 40216f0:	1445883a 	add	r2,r2,r17
 40216f4:	10c00003 	ldbu	r3,0(r2)
 40216f8:	d9000a17 	ldw	r4,40(sp)
 40216fc:	20e1883a 	add	r16,r4,r3
 4021700:	80803fd4 	ori	r2,r16,255
 4021704:	9080e936 	bltu	r18,r2,4021aac <aes_invmixcolumns+0x750>
 4021708:	8004913a 	slli	r2,r16,4
 402170c:	018100f4 	movhi	r6,1027
 4021710:	31b72704 	addi	r6,r6,-9060
 4021714:	10803fd4 	ori	r2,r2,255
 4021718:	1185883a 	add	r2,r2,r6
 402171c:	10800003 	ldbu	r2,0(r2)
 4021720:	10c03fe4 	muli	r3,r2,255
 4021724:	008100f4 	movhi	r2,1027
 4021728:	10843904 	addi	r2,r2,4324
 402172c:	80c7c83a 	sub	r3,r16,r3
 4021730:	10c5883a 	add	r2,r2,r3
 4021734:	10800003 	ldbu	r2,0(r2)
 4021738:	d8800605 	stb	r2,24(sp)
 402173c:	a8803fcc 	andi	r2,r21,255
 4021740:	103f5426 	beq	r2,zero,4021494 <aes_invmixcolumns+0x138>
 4021744:	1445883a 	add	r2,r2,r17
 4021748:	10c00003 	ldbu	r3,0(r2)
 402174c:	d8800e17 	ldw	r2,56(sp)
 4021750:	10e1883a 	add	r16,r2,r3
 4021754:	80803fd4 	ori	r2,r16,255
 4021758:	9080dc36 	bltu	r18,r2,4021acc <aes_invmixcolumns+0x770>
 402175c:	8004913a 	slli	r2,r16,4
 4021760:	00c100f4 	movhi	r3,1027
 4021764:	18f72704 	addi	r3,r3,-9060
 4021768:	10803fd4 	ori	r2,r2,255
 402176c:	10c5883a 	add	r2,r2,r3
 4021770:	10800003 	ldbu	r2,0(r2)
 4021774:	10c03fe4 	muli	r3,r2,255
 4021778:	008100f4 	movhi	r2,1027
 402177c:	10843904 	addi	r2,r2,4324
 4021780:	80c7c83a 	sub	r3,r16,r3
 4021784:	10c5883a 	add	r2,r2,r3
 4021788:	14c00003 	ldbu	r19,0(r2)
 402178c:	003f4206 	br	4021498 <aes_invmixcolumns+0x13c>
 4021790:	1c45883a 	add	r2,r3,r17
 4021794:	10c00003 	ldbu	r3,0(r2)
 4021798:	d9800b17 	ldw	r6,44(sp)
 402179c:	30e1883a 	add	r16,r6,r3
 40217a0:	80803fd4 	ori	r2,r16,255
 40217a4:	9080cd36 	bltu	r18,r2,4021adc <aes_invmixcolumns+0x780>
 40217a8:	8004913a 	slli	r2,r16,4
 40217ac:	00c100f4 	movhi	r3,1027
 40217b0:	18f72704 	addi	r3,r3,-9060
 40217b4:	10803fd4 	ori	r2,r2,255
 40217b8:	10c5883a 	add	r2,r2,r3
 40217bc:	10800003 	ldbu	r2,0(r2)
 40217c0:	10c03fe4 	muli	r3,r2,255
 40217c4:	008100f4 	movhi	r2,1027
 40217c8:	10843904 	addi	r2,r2,4324
 40217cc:	80c7c83a 	sub	r3,r16,r3
 40217d0:	10c5883a 	add	r2,r2,r3
 40217d4:	10800003 	ldbu	r2,0(r2)
 40217d8:	d8800705 	stb	r2,28(sp)
 40217dc:	003f2806 	br	4021480 <aes_invmixcolumns+0x124>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 40217e0:	1445883a 	add	r2,r2,r17
 40217e4:	10c00003 	ldbu	r3,0(r2)
 40217e8:	d9000b17 	ldw	r4,44(sp)
 40217ec:	20e1883a 	add	r16,r4,r3
 40217f0:	80803fd4 	ori	r2,r16,255
 40217f4:	9080c936 	bltu	r18,r2,4021b1c <aes_invmixcolumns+0x7c0>
 40217f8:	8004913a 	slli	r2,r16,4
 40217fc:	018100f4 	movhi	r6,1027
 4021800:	31b72704 	addi	r6,r6,-9060
 4021804:	10803fd4 	ori	r2,r2,255
 4021808:	1185883a 	add	r2,r2,r6
 402180c:	10800003 	ldbu	r2,0(r2)
 4021810:	10c03fe4 	muli	r3,r2,255
 4021814:	008100f4 	movhi	r2,1027
 4021818:	10843904 	addi	r2,r2,4324
 402181c:	80c7c83a 	sub	r3,r16,r3
 4021820:	10c5883a 	add	r2,r2,r3
 4021824:	10c00003 	ldbu	r3,0(r2)
 4021828:	003f0b06 	br	4021458 <aes_invmixcolumns+0xfc>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 402182c:	1445883a 	add	r2,r2,r17
 4021830:	10c00003 	ldbu	r3,0(r2)
 4021834:	d9000a17 	ldw	r4,40(sp)
 4021838:	20e1883a 	add	r16,r4,r3
 402183c:	80803fd4 	ori	r2,r16,255
 4021840:	9080ae36 	bltu	r18,r2,4021afc <aes_invmixcolumns+0x7a0>
 4021844:	8004913a 	slli	r2,r16,4
 4021848:	018100f4 	movhi	r6,1027
 402184c:	31b72704 	addi	r6,r6,-9060
 4021850:	10803fd4 	ori	r2,r2,255
 4021854:	1185883a 	add	r2,r2,r6
 4021858:	10800003 	ldbu	r2,0(r2)
 402185c:	10c03fe4 	muli	r3,r2,255
 4021860:	008100f4 	movhi	r2,1027
 4021864:	10843904 	addi	r2,r2,4324
 4021868:	80c7c83a 	sub	r3,r16,r3
 402186c:	10c5883a 	add	r2,r2,r3
 4021870:	10c00003 	ldbu	r3,0(r2)
 4021874:	003ee506 	br	402140c <aes_invmixcolumns+0xb0>
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 4021878:	1445883a 	add	r2,r2,r17
 402187c:	10c00003 	ldbu	r3,0(r2)
 4021880:	d9000e17 	ldw	r4,56(sp)
 4021884:	20e1883a 	add	r16,r4,r3
 4021888:	80803fd4 	ori	r2,r16,255
 402188c:	9080ab36 	bltu	r18,r2,4021b3c <aes_invmixcolumns+0x7e0>
 4021890:	8004913a 	slli	r2,r16,4
 4021894:	018100f4 	movhi	r6,1027
 4021898:	31b72704 	addi	r6,r6,-9060
 402189c:	10803fd4 	ori	r2,r2,255
 40218a0:	1185883a 	add	r2,r2,r6
 40218a4:	10800003 	ldbu	r2,0(r2)
 40218a8:	10c03fe4 	muli	r3,r2,255
 40218ac:	008100f4 	movhi	r2,1027
 40218b0:	10843904 	addi	r2,r2,4324
 40218b4:	80c7c83a 	sub	r3,r16,r3
 40218b8:	10c5883a 	add	r2,r2,r3
 40218bc:	10800003 	ldbu	r2,0(r2)
 40218c0:	d8800805 	stb	r2,32(sp)
 40218c4:	a8803fcc 	andi	r2,r21,255
 40218c8:	103edf26 	beq	r2,zero,4021448 <aes_invmixcolumns+0xec>
 40218cc:	1445883a 	add	r2,r2,r17
 40218d0:	10c00003 	ldbu	r3,0(r2)
 40218d4:	d8800c17 	ldw	r2,48(sp)
 40218d8:	10e1883a 	add	r16,r2,r3
 40218dc:	80803fd4 	ori	r2,r16,255
 40218e0:	90809236 	bltu	r18,r2,4021b2c <aes_invmixcolumns+0x7d0>
 40218e4:	8004913a 	slli	r2,r16,4
 40218e8:	00c100f4 	movhi	r3,1027
 40218ec:	18f72704 	addi	r3,r3,-9060
 40218f0:	10803fd4 	ori	r2,r2,255
 40218f4:	10c5883a 	add	r2,r2,r3
 40218f8:	10800003 	ldbu	r2,0(r2)
 40218fc:	10c03fe4 	muli	r3,r2,255
 4021900:	008100f4 	movhi	r2,1027
 4021904:	10843904 	addi	r2,r2,4324
 4021908:	80c7c83a 	sub	r3,r16,r3
 402190c:	10c5883a 	add	r2,r2,r3
 4021910:	14c00003 	ldbu	r19,0(r2)
 4021914:	003ecd06 	br	402144c <aes_invmixcolumns+0xf0>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 4021918:	1445883a 	add	r2,r2,r17
 402191c:	10c00003 	ldbu	r3,0(r2)
 4021920:	d9000c17 	ldw	r4,48(sp)
 4021924:	20e1883a 	add	r16,r4,r3
 4021928:	80803fd4 	ori	r2,r16,255
 402192c:	90806f36 	bltu	r18,r2,4021aec <aes_invmixcolumns+0x790>
 4021930:	8004913a 	slli	r2,r16,4
 4021934:	018100f4 	movhi	r6,1027
 4021938:	31b72704 	addi	r6,r6,-9060
 402193c:	10803fd4 	ori	r2,r2,255
 4021940:	1185883a 	add	r2,r2,r6
 4021944:	10800003 	ldbu	r2,0(r2)
 4021948:	10c03fe4 	muli	r3,r2,255
 402194c:	008100f4 	movhi	r2,1027
 4021950:	10843904 	addi	r2,r2,4324
 4021954:	80c7c83a 	sub	r3,r16,r3
 4021958:	10c5883a 	add	r2,r2,r3
 402195c:	10800003 	ldbu	r2,0(r2)
 4021960:	d8800d05 	stb	r2,52(sp)
 4021964:	e5400203 	ldbu	r21,8(fp)
 4021968:	a8803fcc 	andi	r2,r21,255
 402196c:	103ea226 	beq	r2,zero,40213f8 <aes_invmixcolumns+0x9c>
 4021970:	1445883a 	add	r2,r2,r17
 4021974:	10c00003 	ldbu	r3,0(r2)
 4021978:	d8800b17 	ldw	r2,44(sp)
 402197c:	10e1883a 	add	r16,r2,r3
 4021980:	80803fd4 	ori	r2,r16,255
 4021984:	90806136 	bltu	r18,r2,4021b0c <aes_invmixcolumns+0x7b0>
 4021988:	8004913a 	slli	r2,r16,4
 402198c:	00c100f4 	movhi	r3,1027
 4021990:	18f72704 	addi	r3,r3,-9060
 4021994:	10803fd4 	ori	r2,r2,255
 4021998:	10c5883a 	add	r2,r2,r3
 402199c:	10800003 	ldbu	r2,0(r2)
 40219a0:	10c03fe4 	muli	r3,r2,255
 40219a4:	008100f4 	movhi	r2,1027
 40219a8:	10843904 	addi	r2,r2,4324
 40219ac:	80c7c83a 	sub	r3,r16,r3
 40219b0:	10c5883a 	add	r2,r2,r3
 40219b4:	14c00003 	ldbu	r19,0(r2)
 40219b8:	003e9006 	br	40213fc <aes_invmixcolumns+0xa0>
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 40219bc:	1c45883a 	add	r2,r3,r17
 40219c0:	10c00003 	ldbu	r3,0(r2)
 40219c4:	d9800a17 	ldw	r6,40(sp)
 40219c8:	30e1883a 	add	r16,r6,r3
 40219cc:	80803fd4 	ori	r2,r16,255
 40219d0:	90805e36 	bltu	r18,r2,4021b4c <aes_invmixcolumns+0x7f0>
 40219d4:	8004913a 	slli	r2,r16,4
 40219d8:	00c100f4 	movhi	r3,1027
 40219dc:	18f72704 	addi	r3,r3,-9060
 40219e0:	10803fd4 	ori	r2,r2,255
 40219e4:	10c5883a 	add	r2,r2,r3
 40219e8:	10800003 	ldbu	r2,0(r2)
 40219ec:	10c03fe4 	muli	r3,r2,255
 40219f0:	008100f4 	movhi	r2,1027
 40219f4:	10843904 	addi	r2,r2,4324
 40219f8:	80c7c83a 	sub	r3,r16,r3
 40219fc:	10c5883a 	add	r2,r2,r3
 4021a00:	10800003 	ldbu	r2,0(r2)
 4021a04:	d8800905 	stb	r2,36(sp)
 4021a08:	003e8a06 	br	4021434 <aes_invmixcolumns+0xd8>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 4021a0c:	1445883a 	add	r2,r2,r17
 4021a10:	10c00003 	ldbu	r3,0(r2)
 4021a14:	d9800e17 	ldw	r6,56(sp)
 4021a18:	30e1883a 	add	r16,r6,r3
 4021a1c:	80803fd4 	ori	r2,r16,255
 4021a20:	90801236 	bltu	r18,r2,4021a6c <aes_invmixcolumns+0x710>
 4021a24:	8004913a 	slli	r2,r16,4
 4021a28:	00c100f4 	movhi	r3,1027
 4021a2c:	18f72704 	addi	r3,r3,-9060
 4021a30:	10803fd4 	ori	r2,r2,255
 4021a34:	10c5883a 	add	r2,r2,r3
 4021a38:	10800003 	ldbu	r2,0(r2)
 4021a3c:	10c03fe4 	muli	r3,r2,255
 4021a40:	008100f4 	movhi	r2,1027
 4021a44:	10843904 	addi	r2,r2,4324
 4021a48:	80c7c83a 	sub	r3,r16,r3
 4021a4c:	10c5883a 	add	r2,r2,r3
 4021a50:	10800003 	ldbu	r2,0(r2)
 4021a54:	d8800f05 	stb	r2,60(sp)
 4021a58:	003e6006 	br	40213dc <aes_invmixcolumns+0x80>
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 4021a5c:	8009883a 	mov	r4,r16
 4021a60:	01403fc4 	movi	r5,255
 4021a64:	40265d40 	call	40265d4 <__divsi3>
 4021a68:	003ecd06 	br	40215a0 <aes_invmixcolumns+0x244>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 4021a6c:	8009883a 	mov	r4,r16
 4021a70:	01403fc4 	movi	r5,255
 4021a74:	40265d40 	call	40265d4 <__divsi3>
 4021a78:	003ff006 	br	4021a3c <aes_invmixcolumns+0x6e0>
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
				aes_mul(0x09, ctx->state[1][i]) ^
				aes_mul(0x0e, ctx->state[2][i]) ^
				aes_mul(0x0b, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x0b, ctx->state[0][i]) ^
 4021a7c:	8009883a 	mov	r4,r16
 4021a80:	01403fc4 	movi	r5,255
 4021a84:	40265d40 	call	40265d4 <__divsi3>
 4021a88:	003ed806 	br	40215ec <aes_invmixcolumns+0x290>
 4021a8c:	8009883a 	mov	r4,r16
 4021a90:	01403fc4 	movi	r5,255
 4021a94:	40265d40 	call	40265d4 <__divsi3>
 4021a98:	003ee706 	br	4021638 <aes_invmixcolumns+0x2dc>
 4021a9c:	8009883a 	mov	r4,r16
 4021aa0:	01403fc4 	movi	r5,255
 4021aa4:	40265d40 	call	40265d4 <__divsi3>
 4021aa8:	003ef606 	br	4021684 <aes_invmixcolumns+0x328>
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
				aes_mul(0x0e, ctx->state[1][i]) ^
				aes_mul(0x0b, ctx->state[2][i]) ^
				aes_mul(0x0d, ctx->state[3][i]);
		nstate[2][i] = aes_mul(0x0d, ctx->state[0][i]) ^
 4021aac:	8009883a 	mov	r4,r16
 4021ab0:	01403fc4 	movi	r5,255
 4021ab4:	40265d40 	call	40265d4 <__divsi3>
 4021ab8:	003f1906 	br	4021720 <aes_invmixcolumns+0x3c4>
 4021abc:	8009883a 	mov	r4,r16
 4021ac0:	01403fc4 	movi	r5,255
 4021ac4:	40265d40 	call	40265d4 <__divsi3>
 4021ac8:	003f0206 	br	40216d4 <aes_invmixcolumns+0x378>
 4021acc:	8009883a 	mov	r4,r16
 4021ad0:	01403fc4 	movi	r5,255
 4021ad4:	40265d40 	call	40265d4 <__divsi3>
 4021ad8:	003f2606 	br	4021774 <aes_invmixcolumns+0x418>
 4021adc:	8009883a 	mov	r4,r16
 4021ae0:	01403fc4 	movi	r5,255
 4021ae4:	40265d40 	call	40265d4 <__divsi3>
 4021ae8:	003f3506 	br	40217c0 <aes_invmixcolumns+0x464>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x0e, ctx->state[0][i]) ^ 
 4021aec:	8009883a 	mov	r4,r16
 4021af0:	01403fc4 	movi	r5,255
 4021af4:	40265d40 	call	40265d4 <__divsi3>
 4021af8:	003f9306 	br	4021948 <aes_invmixcolumns+0x5ec>
 4021afc:	8009883a 	mov	r4,r16
 4021b00:	01403fc4 	movi	r5,255
 4021b04:	40265d40 	call	40265d4 <__divsi3>
 4021b08:	003f5406 	br	402185c <aes_invmixcolumns+0x500>
 4021b0c:	8009883a 	mov	r4,r16
 4021b10:	01403fc4 	movi	r5,255
 4021b14:	40265d40 	call	40265d4 <__divsi3>
 4021b18:	003fa106 	br	40219a0 <aes_invmixcolumns+0x644>
				aes_mul(0x0b, ctx->state[1][i]) ^
				aes_mul(0x0d, ctx->state[2][i]) ^
				aes_mul(0x09, ctx->state[3][i]);
		nstate[1][i] = aes_mul(0x09, ctx->state[0][i]) ^
 4021b1c:	8009883a 	mov	r4,r16
 4021b20:	01403fc4 	movi	r5,255
 4021b24:	40265d40 	call	40265d4 <__divsi3>
 4021b28:	003f3906 	br	4021810 <aes_invmixcolumns+0x4b4>
 4021b2c:	8009883a 	mov	r4,r16
 4021b30:	01403fc4 	movi	r5,255
 4021b34:	40265d40 	call	40265d4 <__divsi3>
 4021b38:	003f7006 	br	40218fc <aes_invmixcolumns+0x5a0>
 4021b3c:	8009883a 	mov	r4,r16
 4021b40:	01403fc4 	movi	r5,255
 4021b44:	40265d40 	call	40265d4 <__divsi3>
 4021b48:	003f5706 	br	40218a8 <aes_invmixcolumns+0x54c>
 4021b4c:	8009883a 	mov	r4,r16
 4021b50:	01403fc4 	movi	r5,255
 4021b54:	40265d40 	call	40265d4 <__divsi3>
 4021b58:	003fa406 	br	40219ec <aes_invmixcolumns+0x690>

04021b5c <aes_invshiftrows>:
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 4021b5c:	20800003 	ldbu	r2,0(r4)
	for(i = 0; i < 16; i++)
		output[i] = ctx->state[i & 0x03][i >> 2];
}

void aes_invshiftrows(aes_ctx_t *ctx)
{
 4021b60:	defffc04 	addi	sp,sp,-16
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 4021b64:	20c00043 	ldbu	r3,1(r4)
 4021b68:	21400083 	ldbu	r5,2(r4)
 4021b6c:	218000c3 	ldbu	r6,3(r4)
 4021b70:	d8800005 	stb	r2,0(sp)
 4021b74:	20800103 	ldbu	r2,4(r4)
 4021b78:	d8c00045 	stb	r3,1(sp)
 4021b7c:	d9400085 	stb	r5,2(sp)
 4021b80:	d98000c5 	stb	r6,3(sp)
 4021b84:	20c00203 	ldbu	r3,8(r4)
 4021b88:	21400303 	ldbu	r5,12(r4)
 4021b8c:	21800143 	ldbu	r6,5(r4)
 4021b90:	21c00243 	ldbu	r7,9(r4)
 4021b94:	22000343 	ldbu	r8,13(r4)
 4021b98:	22400183 	ldbu	r9,6(r4)
 4021b9c:	22800283 	ldbu	r10,10(r4)
 4021ba0:	22c00383 	ldbu	r11,14(r4)
 4021ba4:	230001c3 	ldbu	r12,7(r4)
 4021ba8:	234002c3 	ldbu	r13,11(r4)
 4021bac:	238003c3 	ldbu	r14,15(r4)
 4021bb0:	d8800145 	stb	r2,5(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4021bb4:	d8800017 	ldw	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 4021bb8:	d8c00285 	stb	r3,10(sp)
 4021bbc:	d94003c5 	stb	r5,15(sp)
 4021bc0:	d9800185 	stb	r6,6(sp)
 4021bc4:	d9c002c5 	stb	r7,11(sp)
 4021bc8:	da000305 	stb	r8,12(sp)
 4021bcc:	da4001c5 	stb	r9,7(sp)
 4021bd0:	da800205 	stb	r10,8(sp)
 4021bd4:	dac00345 	stb	r11,13(sp)
 4021bd8:	db000105 	stb	r12,4(sp)
 4021bdc:	db400245 	stb	r13,9(sp)
 4021be0:	db800385 	stb	r14,14(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4021be4:	20800015 	stw	r2,0(r4)
 4021be8:	d8c00217 	ldw	r3,8(sp)
 4021bec:	d9400317 	ldw	r5,12(sp)
 4021bf0:	d8800117 	ldw	r2,4(sp)
 4021bf4:	20c00215 	stw	r3,8(r4)
 4021bf8:	21400315 	stw	r5,12(r4)
 4021bfc:	20800115 	stw	r2,4(r4)
}
 4021c00:	dec00404 	addi	sp,sp,16
 4021c04:	f800283a 	ret

04021c08 <aes_mixcolumns>:

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_mixcolumns(aes_ctx_t *ctx)
{
 4021c08:	deffe304 	addi	sp,sp,-116
 4021c0c:	df001b15 	stw	fp,108(sp)
 4021c10:	ddc01a15 	stw	r23,104(sp)
 4021c14:	dd401815 	stw	r21,96(sp)
 4021c18:	dc401415 	stw	r17,80(sp)
 4021c1c:	dfc01c15 	stw	ra,112(sp)
 4021c20:	dd801915 	stw	r22,100(sp)
 4021c24:	dd001715 	stw	r20,92(sp)
 4021c28:	dcc01615 	stw	r19,88(sp)
 4021c2c:	dc801515 	stw	r18,84(sp)
 4021c30:	dc001315 	stw	r16,76(sp)
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021c34:	25000003 	ldbu	r20,0(r4)
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021c38:	054100f4 	movhi	r21,1027
 4021c3c:	ad44f904 	addi	r21,r21,5092

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_mixcolumns(aes_ctx_t *ctx)
{
 4021c40:	2023883a 	mov	r17,r4
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021c44:	a0803fcc 	andi	r2,r20,255
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021c48:	af000083 	ldbu	fp,2(r21)
 4021c4c:	adc000c3 	ldbu	r23,3(r21)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021c50:	1003131e 	bne	r2,zero,40228a0 <aes_mixcolumns+0xc98>
 4021c54:	d8000605 	stb	zero,24(sp)
 4021c58:	8d800103 	ldbu	r22,4(r17)
 4021c5c:	b0803fcc 	andi	r2,r22,255
 4021c60:	10001226 	beq	r2,zero,4021cac <aes_mixcolumns+0xa4>
 4021c64:	1545883a 	add	r2,r2,r21
 4021c68:	10c00003 	ldbu	r3,0(r2)
 4021c6c:	008003c4 	movi	r2,15
 4021c70:	1de1883a 	add	r16,r3,r23
 4021c74:	81003fd4 	ori	r4,r16,255
 4021c78:	11039936 	bltu	r2,r4,4022ae0 <aes_mixcolumns+0xed8>
 4021c7c:	8004913a 	slli	r2,r16,4
 4021c80:	00c100f4 	movhi	r3,1027
 4021c84:	18f72704 	addi	r3,r3,-9060
 4021c88:	10803fd4 	ori	r2,r2,255
 4021c8c:	10c5883a 	add	r2,r2,r3
 4021c90:	10800003 	ldbu	r2,0(r2)
 4021c94:	10c03fe4 	muli	r3,r2,255
 4021c98:	008100f4 	movhi	r2,1027
 4021c9c:	10843904 	addi	r2,r2,4324
 4021ca0:	80c7c83a 	sub	r3,r16,r3
 4021ca4:	10c5883a 	add	r2,r2,r3
 4021ca8:	10800003 	ldbu	r2,0(r2)
 4021cac:	d8c00603 	ldbu	r3,24(sp)
 4021cb0:	8cc00203 	ldbu	r19,8(r17)
 4021cb4:	8c800303 	ldbu	r18,12(r17)
 4021cb8:	1884f03a 	xor	r2,r3,r2
 4021cbc:	14c4f03a 	xor	r2,r2,r19
 4021cc0:	1484f03a 	xor	r2,r2,r18
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021cc4:	b0c03fcc 	andi	r3,r22,255
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021cc8:	d8800005 	stb	r2,0(sp)
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021ccc:	1802e01e 	bne	r3,zero,4022850 <aes_mixcolumns+0xc48>
 4021cd0:	d8000905 	stb	zero,36(sp)
 4021cd4:	98803fcc 	andi	r2,r19,255
 4021cd8:	10001226 	beq	r2,zero,4021d24 <aes_mixcolumns+0x11c>
 4021cdc:	1545883a 	add	r2,r2,r21
 4021ce0:	10c00003 	ldbu	r3,0(r2)
 4021ce4:	008003c4 	movi	r2,15
 4021ce8:	b8e1883a 	add	r16,r23,r3
 4021cec:	81003fd4 	ori	r4,r16,255
 4021cf0:	11037736 	bltu	r2,r4,4022ad0 <aes_mixcolumns+0xec8>
 4021cf4:	8004913a 	slli	r2,r16,4
 4021cf8:	00c100f4 	movhi	r3,1027
 4021cfc:	18f72704 	addi	r3,r3,-9060
 4021d00:	10803fd4 	ori	r2,r2,255
 4021d04:	10c5883a 	add	r2,r2,r3
 4021d08:	10800003 	ldbu	r2,0(r2)
 4021d0c:	10c03fe4 	muli	r3,r2,255
 4021d10:	008100f4 	movhi	r2,1027
 4021d14:	10843904 	addi	r2,r2,4324
 4021d18:	80c7c83a 	sub	r3,r16,r3
 4021d1c:	10c5883a 	add	r2,r2,r3
 4021d20:	10800003 	ldbu	r2,0(r2)
 4021d24:	d9000903 	ldbu	r4,36(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4021d28:	98c03fcc 	andi	r3,r19,255
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021d2c:	1104f03a 	xor	r2,r2,r4
 4021d30:	1504f03a 	xor	r2,r2,r20
 4021d34:	1484f03a 	xor	r2,r2,r18
 4021d38:	d8800105 	stb	r2,4(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4021d3c:	1802b01e 	bne	r3,zero,4022800 <aes_mixcolumns+0xbf8>
 4021d40:	d8000c05 	stb	zero,48(sp)
 4021d44:	90803fcc 	andi	r2,r18,255
 4021d48:	10001226 	beq	r2,zero,4021d94 <aes_mixcolumns+0x18c>
 4021d4c:	1545883a 	add	r2,r2,r21
 4021d50:	10c00003 	ldbu	r3,0(r2)
 4021d54:	008003c4 	movi	r2,15
 4021d58:	b8e1883a 	add	r16,r23,r3
 4021d5c:	81003fd4 	ori	r4,r16,255
 4021d60:	11035736 	bltu	r2,r4,4022ac0 <aes_mixcolumns+0xeb8>
 4021d64:	8004913a 	slli	r2,r16,4
 4021d68:	00c100f4 	movhi	r3,1027
 4021d6c:	18f72704 	addi	r3,r3,-9060
 4021d70:	10803fd4 	ori	r2,r2,255
 4021d74:	10c5883a 	add	r2,r2,r3
 4021d78:	10800003 	ldbu	r2,0(r2)
 4021d7c:	10c03fe4 	muli	r3,r2,255
 4021d80:	008100f4 	movhi	r2,1027
 4021d84:	10843904 	addi	r2,r2,4324
 4021d88:	80c7c83a 	sub	r3,r16,r3
 4021d8c:	10c5883a 	add	r2,r2,r3
 4021d90:	10800003 	ldbu	r2,0(r2)
 4021d94:	d9000c03 	ldbu	r4,48(sp)
 4021d98:	2086f03a 	xor	r3,r4,r2
 4021d9c:	a584f03a 	xor	r2,r20,r22
 4021da0:	10c4f03a 	xor	r2,r2,r3
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021da4:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4021da8:	d8800205 	stb	r2,8(sp)
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021dac:	1802801e 	bne	r3,zero,40227b0 <aes_mixcolumns+0xba8>
 4021db0:	d8000f05 	stb	zero,60(sp)
 4021db4:	90803fcc 	andi	r2,r18,255
 4021db8:	10026a1e 	bne	r2,zero,4022764 <aes_mixcolumns+0xb5c>
 4021dbc:	0007883a 	mov	r3,zero
 4021dc0:	d9000f03 	ldbu	r4,60(sp)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021dc4:	8d000043 	ldbu	r20,1(r17)
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021dc8:	2584f03a 	xor	r2,r4,r22
 4021dcc:	10c4f03a 	xor	r2,r2,r3
 4021dd0:	14c4f03a 	xor	r2,r2,r19
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021dd4:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021dd8:	d8800305 	stb	r2,12(sp)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021ddc:	18024d1e 	bne	r3,zero,4022714 <aes_mixcolumns+0xb0c>
 4021de0:	d8000505 	stb	zero,20(sp)
 4021de4:	8d800143 	ldbu	r22,5(r17)
 4021de8:	b0803fcc 	andi	r2,r22,255
 4021dec:	10001226 	beq	r2,zero,4021e38 <aes_mixcolumns+0x230>
 4021df0:	1545883a 	add	r2,r2,r21
 4021df4:	10c00003 	ldbu	r3,0(r2)
 4021df8:	008003c4 	movi	r2,15
 4021dfc:	b8e1883a 	add	r16,r23,r3
 4021e00:	81003fd4 	ori	r4,r16,255
 4021e04:	11032a36 	bltu	r2,r4,4022ab0 <aes_mixcolumns+0xea8>
 4021e08:	8004913a 	slli	r2,r16,4
 4021e0c:	00c100f4 	movhi	r3,1027
 4021e10:	18f72704 	addi	r3,r3,-9060
 4021e14:	10803fd4 	ori	r2,r2,255
 4021e18:	10c5883a 	add	r2,r2,r3
 4021e1c:	10800003 	ldbu	r2,0(r2)
 4021e20:	10c03fe4 	muli	r3,r2,255
 4021e24:	008100f4 	movhi	r2,1027
 4021e28:	10843904 	addi	r2,r2,4324
 4021e2c:	80c7c83a 	sub	r3,r16,r3
 4021e30:	10c5883a 	add	r2,r2,r3
 4021e34:	10800003 	ldbu	r2,0(r2)
 4021e38:	d8c00503 	ldbu	r3,20(sp)
 4021e3c:	8cc00243 	ldbu	r19,9(r17)
 4021e40:	8c800343 	ldbu	r18,13(r17)
 4021e44:	1884f03a 	xor	r2,r3,r2
 4021e48:	14c4f03a 	xor	r2,r2,r19
 4021e4c:	1484f03a 	xor	r2,r2,r18
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021e50:	b0c03fcc 	andi	r3,r22,255
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021e54:	d8800045 	stb	r2,1(sp)
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021e58:	18021a1e 	bne	r3,zero,40226c4 <aes_mixcolumns+0xabc>
 4021e5c:	d8000805 	stb	zero,32(sp)
 4021e60:	98803fcc 	andi	r2,r19,255
 4021e64:	10001226 	beq	r2,zero,4021eb0 <aes_mixcolumns+0x2a8>
 4021e68:	1545883a 	add	r2,r2,r21
 4021e6c:	10c00003 	ldbu	r3,0(r2)
 4021e70:	008003c4 	movi	r2,15
 4021e74:	b8e1883a 	add	r16,r23,r3
 4021e78:	81003fd4 	ori	r4,r16,255
 4021e7c:	11030836 	bltu	r2,r4,4022aa0 <aes_mixcolumns+0xe98>
 4021e80:	8004913a 	slli	r2,r16,4
 4021e84:	00c100f4 	movhi	r3,1027
 4021e88:	18f72704 	addi	r3,r3,-9060
 4021e8c:	10803fd4 	ori	r2,r2,255
 4021e90:	10c5883a 	add	r2,r2,r3
 4021e94:	10800003 	ldbu	r2,0(r2)
 4021e98:	10c03fe4 	muli	r3,r2,255
 4021e9c:	008100f4 	movhi	r2,1027
 4021ea0:	10843904 	addi	r2,r2,4324
 4021ea4:	80c7c83a 	sub	r3,r16,r3
 4021ea8:	10c5883a 	add	r2,r2,r3
 4021eac:	10800003 	ldbu	r2,0(r2)
 4021eb0:	d9000803 	ldbu	r4,32(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4021eb4:	98c03fcc 	andi	r3,r19,255
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021eb8:	1104f03a 	xor	r2,r2,r4
 4021ebc:	1504f03a 	xor	r2,r2,r20
 4021ec0:	1484f03a 	xor	r2,r2,r18
 4021ec4:	d8800145 	stb	r2,5(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4021ec8:	1801ea1e 	bne	r3,zero,4022674 <aes_mixcolumns+0xa6c>
 4021ecc:	d8000b05 	stb	zero,44(sp)
 4021ed0:	90803fcc 	andi	r2,r18,255
 4021ed4:	10001226 	beq	r2,zero,4021f20 <aes_mixcolumns+0x318>
 4021ed8:	1545883a 	add	r2,r2,r21
 4021edc:	10c00003 	ldbu	r3,0(r2)
 4021ee0:	008003c4 	movi	r2,15
 4021ee4:	b8e1883a 	add	r16,r23,r3
 4021ee8:	81003fd4 	ori	r4,r16,255
 4021eec:	1102e836 	bltu	r2,r4,4022a90 <aes_mixcolumns+0xe88>
 4021ef0:	8004913a 	slli	r2,r16,4
 4021ef4:	00c100f4 	movhi	r3,1027
 4021ef8:	18f72704 	addi	r3,r3,-9060
 4021efc:	10803fd4 	ori	r2,r2,255
 4021f00:	10c5883a 	add	r2,r2,r3
 4021f04:	10800003 	ldbu	r2,0(r2)
 4021f08:	10c03fe4 	muli	r3,r2,255
 4021f0c:	008100f4 	movhi	r2,1027
 4021f10:	10843904 	addi	r2,r2,4324
 4021f14:	80c7c83a 	sub	r3,r16,r3
 4021f18:	10c5883a 	add	r2,r2,r3
 4021f1c:	10800003 	ldbu	r2,0(r2)
 4021f20:	d9000b03 	ldbu	r4,44(sp)
 4021f24:	2086f03a 	xor	r3,r4,r2
 4021f28:	a584f03a 	xor	r2,r20,r22
 4021f2c:	10c4f03a 	xor	r2,r2,r3
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021f30:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4021f34:	d8800245 	stb	r2,9(sp)
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021f38:	1801ba1e 	bne	r3,zero,4022624 <aes_mixcolumns+0xa1c>
 4021f3c:	d8000e05 	stb	zero,56(sp)
 4021f40:	90803fcc 	andi	r2,r18,255
 4021f44:	1001a41e 	bne	r2,zero,40225d8 <aes_mixcolumns+0x9d0>
 4021f48:	0007883a 	mov	r3,zero
 4021f4c:	d9000e03 	ldbu	r4,56(sp)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021f50:	8d000083 	ldbu	r20,2(r17)
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021f54:	2584f03a 	xor	r2,r4,r22
 4021f58:	10c4f03a 	xor	r2,r2,r3
 4021f5c:	14c4f03a 	xor	r2,r2,r19
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021f60:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4021f64:	d8800345 	stb	r2,13(sp)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021f68:	1801871e 	bne	r3,zero,4022588 <aes_mixcolumns+0x980>
 4021f6c:	d8000405 	stb	zero,16(sp)
 4021f70:	8d800183 	ldbu	r22,6(r17)
 4021f74:	b0803fcc 	andi	r2,r22,255
 4021f78:	10001226 	beq	r2,zero,4021fc4 <aes_mixcolumns+0x3bc>
 4021f7c:	1545883a 	add	r2,r2,r21
 4021f80:	10c00003 	ldbu	r3,0(r2)
 4021f84:	008003c4 	movi	r2,15
 4021f88:	b8e1883a 	add	r16,r23,r3
 4021f8c:	81003fd4 	ori	r4,r16,255
 4021f90:	1102bb36 	bltu	r2,r4,4022a80 <aes_mixcolumns+0xe78>
 4021f94:	8004913a 	slli	r2,r16,4
 4021f98:	00c100f4 	movhi	r3,1027
 4021f9c:	18f72704 	addi	r3,r3,-9060
 4021fa0:	10803fd4 	ori	r2,r2,255
 4021fa4:	10c5883a 	add	r2,r2,r3
 4021fa8:	10800003 	ldbu	r2,0(r2)
 4021fac:	10c03fe4 	muli	r3,r2,255
 4021fb0:	008100f4 	movhi	r2,1027
 4021fb4:	10843904 	addi	r2,r2,4324
 4021fb8:	80c7c83a 	sub	r3,r16,r3
 4021fbc:	10c5883a 	add	r2,r2,r3
 4021fc0:	10800003 	ldbu	r2,0(r2)
 4021fc4:	d8c00403 	ldbu	r3,16(sp)
 4021fc8:	8cc00283 	ldbu	r19,10(r17)
 4021fcc:	8c800383 	ldbu	r18,14(r17)
 4021fd0:	1884f03a 	xor	r2,r3,r2
 4021fd4:	14c4f03a 	xor	r2,r2,r19
 4021fd8:	1484f03a 	xor	r2,r2,r18
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021fdc:	b0c03fcc 	andi	r3,r22,255
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4021fe0:	d8800085 	stb	r2,2(sp)
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4021fe4:	1801541e 	bne	r3,zero,4022538 <aes_mixcolumns+0x930>
 4021fe8:	d8000705 	stb	zero,28(sp)
 4021fec:	98803fcc 	andi	r2,r19,255
 4021ff0:	10001226 	beq	r2,zero,402203c <aes_mixcolumns+0x434>
 4021ff4:	1545883a 	add	r2,r2,r21
 4021ff8:	10c00003 	ldbu	r3,0(r2)
 4021ffc:	008003c4 	movi	r2,15
 4022000:	b8e1883a 	add	r16,r23,r3
 4022004:	81003fd4 	ori	r4,r16,255
 4022008:	11029936 	bltu	r2,r4,4022a70 <aes_mixcolumns+0xe68>
 402200c:	8004913a 	slli	r2,r16,4
 4022010:	00c100f4 	movhi	r3,1027
 4022014:	18f72704 	addi	r3,r3,-9060
 4022018:	10803fd4 	ori	r2,r2,255
 402201c:	10c5883a 	add	r2,r2,r3
 4022020:	10800003 	ldbu	r2,0(r2)
 4022024:	10c03fe4 	muli	r3,r2,255
 4022028:	008100f4 	movhi	r2,1027
 402202c:	10843904 	addi	r2,r2,4324
 4022030:	80c7c83a 	sub	r3,r16,r3
 4022034:	10c5883a 	add	r2,r2,r3
 4022038:	10800003 	ldbu	r2,0(r2)
 402203c:	d9000703 	ldbu	r4,28(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022040:	98c03fcc 	andi	r3,r19,255
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022044:	1104f03a 	xor	r2,r2,r4
 4022048:	1504f03a 	xor	r2,r2,r20
 402204c:	1484f03a 	xor	r2,r2,r18
 4022050:	d8800185 	stb	r2,6(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022054:	1801241e 	bne	r3,zero,40224e8 <aes_mixcolumns+0x8e0>
 4022058:	d8000a05 	stb	zero,40(sp)
 402205c:	90803fcc 	andi	r2,r18,255
 4022060:	10001226 	beq	r2,zero,40220ac <aes_mixcolumns+0x4a4>
 4022064:	1545883a 	add	r2,r2,r21
 4022068:	10c00003 	ldbu	r3,0(r2)
 402206c:	008003c4 	movi	r2,15
 4022070:	b8e1883a 	add	r16,r23,r3
 4022074:	81003fd4 	ori	r4,r16,255
 4022078:	11027936 	bltu	r2,r4,4022a60 <aes_mixcolumns+0xe58>
 402207c:	8004913a 	slli	r2,r16,4
 4022080:	00c100f4 	movhi	r3,1027
 4022084:	18f72704 	addi	r3,r3,-9060
 4022088:	10803fd4 	ori	r2,r2,255
 402208c:	10c5883a 	add	r2,r2,r3
 4022090:	10800003 	ldbu	r2,0(r2)
 4022094:	10c03fe4 	muli	r3,r2,255
 4022098:	008100f4 	movhi	r2,1027
 402209c:	10843904 	addi	r2,r2,4324
 40220a0:	80c7c83a 	sub	r3,r16,r3
 40220a4:	10c5883a 	add	r2,r2,r3
 40220a8:	10800003 	ldbu	r2,0(r2)
 40220ac:	d9000a03 	ldbu	r4,40(sp)
 40220b0:	2086f03a 	xor	r3,r4,r2
 40220b4:	a584f03a 	xor	r2,r20,r22
 40220b8:	10c4f03a 	xor	r2,r2,r3
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40220bc:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 40220c0:	d8800285 	stb	r2,10(sp)
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40220c4:	1800f41e 	bne	r3,zero,4022498 <aes_mixcolumns+0x890>
 40220c8:	d8000d05 	stb	zero,52(sp)
 40220cc:	90803fcc 	andi	r2,r18,255
 40220d0:	1000de1e 	bne	r2,zero,402244c <aes_mixcolumns+0x844>
 40220d4:	0007883a 	mov	r3,zero
 40220d8:	d9000d03 	ldbu	r4,52(sp)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 40220dc:	8d0000c3 	ldbu	r20,3(r17)
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40220e0:	2584f03a 	xor	r2,r4,r22
 40220e4:	10c4f03a 	xor	r2,r2,r3
 40220e8:	14c4f03a 	xor	r2,r2,r19
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 40220ec:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40220f0:	d8800385 	stb	r2,14(sp)
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 40220f4:	1800c11e 	bne	r3,zero,40223fc <aes_mixcolumns+0x7f4>
 40220f8:	d8001205 	stb	zero,72(sp)
 40220fc:	8d8001c3 	ldbu	r22,7(r17)
 4022100:	b0803fcc 	andi	r2,r22,255
 4022104:	10001226 	beq	r2,zero,4022150 <aes_mixcolumns+0x548>
 4022108:	1545883a 	add	r2,r2,r21
 402210c:	10c00003 	ldbu	r3,0(r2)
 4022110:	008003c4 	movi	r2,15
 4022114:	b8e1883a 	add	r16,r23,r3
 4022118:	81003fd4 	ori	r4,r16,255
 402211c:	11024c36 	bltu	r2,r4,4022a50 <aes_mixcolumns+0xe48>
 4022120:	8004913a 	slli	r2,r16,4
 4022124:	00c100f4 	movhi	r3,1027
 4022128:	18f72704 	addi	r3,r3,-9060
 402212c:	10803fd4 	ori	r2,r2,255
 4022130:	10c5883a 	add	r2,r2,r3
 4022134:	10800003 	ldbu	r2,0(r2)
 4022138:	10c03fe4 	muli	r3,r2,255
 402213c:	008100f4 	movhi	r2,1027
 4022140:	10843904 	addi	r2,r2,4324
 4022144:	80c7c83a 	sub	r3,r16,r3
 4022148:	10c5883a 	add	r2,r2,r3
 402214c:	10800003 	ldbu	r2,0(r2)
 4022150:	d8c01203 	ldbu	r3,72(sp)
 4022154:	8cc002c3 	ldbu	r19,11(r17)
 4022158:	8c8003c3 	ldbu	r18,15(r17)
 402215c:	1884f03a 	xor	r2,r3,r2
 4022160:	14c4f03a 	xor	r2,r2,r19
 4022164:	1484f03a 	xor	r2,r2,r18
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022168:	b0c03fcc 	andi	r3,r22,255
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 402216c:	d88000c5 	stb	r2,3(sp)
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022170:	1800681e 	bne	r3,zero,4022314 <aes_mixcolumns+0x70c>
 4022174:	d8001105 	stb	zero,68(sp)
 4022178:	98803fcc 	andi	r2,r19,255
 402217c:	10001226 	beq	r2,zero,40221c8 <aes_mixcolumns+0x5c0>
 4022180:	1545883a 	add	r2,r2,r21
 4022184:	10c00003 	ldbu	r3,0(r2)
 4022188:	008003c4 	movi	r2,15
 402218c:	b8e1883a 	add	r16,r23,r3
 4022190:	81003fd4 	ori	r4,r16,255
 4022194:	11022a36 	bltu	r2,r4,4022a40 <aes_mixcolumns+0xe38>
 4022198:	8004913a 	slli	r2,r16,4
 402219c:	00c100f4 	movhi	r3,1027
 40221a0:	18f72704 	addi	r3,r3,-9060
 40221a4:	10803fd4 	ori	r2,r2,255
 40221a8:	10c5883a 	add	r2,r2,r3
 40221ac:	10800003 	ldbu	r2,0(r2)
 40221b0:	10c03fe4 	muli	r3,r2,255
 40221b4:	008100f4 	movhi	r2,1027
 40221b8:	10843904 	addi	r2,r2,4324
 40221bc:	80c7c83a 	sub	r3,r16,r3
 40221c0:	10c5883a 	add	r2,r2,r3
 40221c4:	10800003 	ldbu	r2,0(r2)
 40221c8:	d9001103 	ldbu	r4,68(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 40221cc:	98c03fcc 	andi	r3,r19,255
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 40221d0:	1104f03a 	xor	r2,r2,r4
 40221d4:	1504f03a 	xor	r2,r2,r20
 40221d8:	1484f03a 	xor	r2,r2,r18
 40221dc:	d88001c5 	stb	r2,7(sp)
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 40221e0:	1800381e 	bne	r3,zero,40222c4 <aes_mixcolumns+0x6bc>
 40221e4:	d8001005 	stb	zero,64(sp)
 40221e8:	90803fcc 	andi	r2,r18,255
 40221ec:	10001226 	beq	r2,zero,4022238 <aes_mixcolumns+0x630>
 40221f0:	1545883a 	add	r2,r2,r21
 40221f4:	10c00003 	ldbu	r3,0(r2)
 40221f8:	008003c4 	movi	r2,15
 40221fc:	b8e1883a 	add	r16,r23,r3
 4022200:	81003fd4 	ori	r4,r16,255
 4022204:	11020a36 	bltu	r2,r4,4022a30 <aes_mixcolumns+0xe28>
 4022208:	8004913a 	slli	r2,r16,4
 402220c:	00c100f4 	movhi	r3,1027
 4022210:	18f72704 	addi	r3,r3,-9060
 4022214:	10803fd4 	ori	r2,r2,255
 4022218:	10c5883a 	add	r2,r2,r3
 402221c:	10800003 	ldbu	r2,0(r2)
 4022220:	10c03fe4 	muli	r3,r2,255
 4022224:	008100f4 	movhi	r2,1027
 4022228:	10843904 	addi	r2,r2,4324
 402222c:	80c7c83a 	sub	r3,r16,r3
 4022230:	10c5883a 	add	r2,r2,r3
 4022234:	10800003 	ldbu	r2,0(r2)
 4022238:	d9001003 	ldbu	r4,64(sp)
 402223c:	2086f03a 	xor	r3,r4,r2
 4022240:	a584f03a 	xor	r2,r20,r22
 4022244:	10c4f03a 	xor	r2,r2,r3
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4022248:	a0c03fcc 	andi	r3,r20,255
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 402224c:	d88002c5 	stb	r2,11(sp)
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4022250:	1800571e 	bne	r3,zero,40223b0 <aes_mixcolumns+0x7a8>
 4022254:	0029883a 	mov	r20,zero
 4022258:	90803fcc 	andi	r2,r18,255
 402225c:	1000411e 	bne	r2,zero,4022364 <aes_mixcolumns+0x75c>
 4022260:	0007883a 	mov	r3,zero
 4022264:	a584f03a 	xor	r2,r20,r22
 4022268:	10c4f03a 	xor	r2,r2,r3
 402226c:	14c4f03a 	xor	r2,r2,r19
 4022270:	d88003c5 	stb	r2,15(sp)
				ctx->state[1][i] ^
				ctx->state[2][i] ^
				aes_mul(0x02, ctx->state[3][i]);
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4022274:	d9000117 	ldw	r4,4(sp)
 4022278:	d9400217 	ldw	r5,8(sp)
 402227c:	d8c00317 	ldw	r3,12(sp)
 4022280:	d8800017 	ldw	r2,0(sp)
 4022284:	89000115 	stw	r4,4(r17)
 4022288:	88c00315 	stw	r3,12(r17)
 402228c:	88800015 	stw	r2,0(r17)
 4022290:	89400215 	stw	r5,8(r17)
}
 4022294:	dfc01c17 	ldw	ra,112(sp)
 4022298:	df001b17 	ldw	fp,108(sp)
 402229c:	ddc01a17 	ldw	r23,104(sp)
 40222a0:	dd801917 	ldw	r22,100(sp)
 40222a4:	dd401817 	ldw	r21,96(sp)
 40222a8:	dd001717 	ldw	r20,92(sp)
 40222ac:	dcc01617 	ldw	r19,88(sp)
 40222b0:	dc801517 	ldw	r18,84(sp)
 40222b4:	dc401417 	ldw	r17,80(sp)
 40222b8:	dc001317 	ldw	r16,76(sp)
 40222bc:	dec01d04 	addi	sp,sp,116
 40222c0:	f800283a 	ret
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 40222c4:	1d45883a 	add	r2,r3,r21
 40222c8:	10c00003 	ldbu	r3,0(r2)
 40222cc:	008003c4 	movi	r2,15
 40222d0:	e0e1883a 	add	r16,fp,r3
 40222d4:	81003fd4 	ori	r4,r16,255
 40222d8:	1101d136 	bltu	r2,r4,4022a20 <aes_mixcolumns+0xe18>
 40222dc:	8004913a 	slli	r2,r16,4
 40222e0:	00c100f4 	movhi	r3,1027
 40222e4:	18f72704 	addi	r3,r3,-9060
 40222e8:	10803fd4 	ori	r2,r2,255
 40222ec:	10c5883a 	add	r2,r2,r3
 40222f0:	10800003 	ldbu	r2,0(r2)
 40222f4:	10c03fe4 	muli	r3,r2,255
 40222f8:	008100f4 	movhi	r2,1027
 40222fc:	10843904 	addi	r2,r2,4324
 4022300:	80c7c83a 	sub	r3,r16,r3
 4022304:	10c5883a 	add	r2,r2,r3
 4022308:	10800003 	ldbu	r2,0(r2)
 402230c:	d8801005 	stb	r2,64(sp)
 4022310:	003fb506 	br	40221e8 <aes_mixcolumns+0x5e0>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022314:	1d45883a 	add	r2,r3,r21
 4022318:	10c00003 	ldbu	r3,0(r2)
 402231c:	008003c4 	movi	r2,15
 4022320:	e0e1883a 	add	r16,fp,r3
 4022324:	81003fd4 	ori	r4,r16,255
 4022328:	1101b936 	bltu	r2,r4,4022a10 <aes_mixcolumns+0xe08>
 402232c:	8004913a 	slli	r2,r16,4
 4022330:	00c100f4 	movhi	r3,1027
 4022334:	18f72704 	addi	r3,r3,-9060
 4022338:	10803fd4 	ori	r2,r2,255
 402233c:	10c5883a 	add	r2,r2,r3
 4022340:	10800003 	ldbu	r2,0(r2)
 4022344:	10c03fe4 	muli	r3,r2,255
 4022348:	008100f4 	movhi	r2,1027
 402234c:	10843904 	addi	r2,r2,4324
 4022350:	80c7c83a 	sub	r3,r16,r3
 4022354:	10c5883a 	add	r2,r2,r3
 4022358:	10800003 	ldbu	r2,0(r2)
 402235c:	d8801105 	stb	r2,68(sp)
 4022360:	003f8506 	br	4022178 <aes_mixcolumns+0x570>
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4022364:	1545883a 	add	r2,r2,r21
 4022368:	10c00003 	ldbu	r3,0(r2)
 402236c:	008003c4 	movi	r2,15
 4022370:	e0e1883a 	add	r16,fp,r3
 4022374:	81003fd4 	ori	r4,r16,255
 4022378:	1101a136 	bltu	r2,r4,4022a00 <aes_mixcolumns+0xdf8>
 402237c:	8004913a 	slli	r2,r16,4
 4022380:	00c100f4 	movhi	r3,1027
 4022384:	18f72704 	addi	r3,r3,-9060
 4022388:	10803fd4 	ori	r2,r2,255
 402238c:	10c5883a 	add	r2,r2,r3
 4022390:	10800003 	ldbu	r2,0(r2)
 4022394:	10c03fe4 	muli	r3,r2,255
 4022398:	008100f4 	movhi	r2,1027
 402239c:	10843904 	addi	r2,r2,4324
 40223a0:	80c7c83a 	sub	r3,r16,r3
 40223a4:	10c5883a 	add	r2,r2,r3
 40223a8:	10c00003 	ldbu	r3,0(r2)
 40223ac:	003fad06 	br	4022264 <aes_mixcolumns+0x65c>
 40223b0:	1d45883a 	add	r2,r3,r21
 40223b4:	10c00003 	ldbu	r3,0(r2)
 40223b8:	008003c4 	movi	r2,15
 40223bc:	b8e1883a 	add	r16,r23,r3
 40223c0:	81003fd4 	ori	r4,r16,255
 40223c4:	11018a36 	bltu	r2,r4,40229f0 <aes_mixcolumns+0xde8>
 40223c8:	8004913a 	slli	r2,r16,4
 40223cc:	00c100f4 	movhi	r3,1027
 40223d0:	18f72704 	addi	r3,r3,-9060
 40223d4:	10803fd4 	ori	r2,r2,255
 40223d8:	10c5883a 	add	r2,r2,r3
 40223dc:	10800003 	ldbu	r2,0(r2)
 40223e0:	10c03fe4 	muli	r3,r2,255
 40223e4:	008100f4 	movhi	r2,1027
 40223e8:	10843904 	addi	r2,r2,4324
 40223ec:	80c7c83a 	sub	r3,r16,r3
 40223f0:	10c5883a 	add	r2,r2,r3
 40223f4:	15000003 	ldbu	r20,0(r2)
 40223f8:	003f9706 	br	4022258 <aes_mixcolumns+0x650>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 40223fc:	1d45883a 	add	r2,r3,r21
 4022400:	10c00003 	ldbu	r3,0(r2)
 4022404:	008003c4 	movi	r2,15
 4022408:	e0e1883a 	add	r16,fp,r3
 402240c:	81003fd4 	ori	r4,r16,255
 4022410:	11017336 	bltu	r2,r4,40229e0 <aes_mixcolumns+0xdd8>
 4022414:	8004913a 	slli	r2,r16,4
 4022418:	00c100f4 	movhi	r3,1027
 402241c:	18f72704 	addi	r3,r3,-9060
 4022420:	10803fd4 	ori	r2,r2,255
 4022424:	10c5883a 	add	r2,r2,r3
 4022428:	10800003 	ldbu	r2,0(r2)
 402242c:	10c03fe4 	muli	r3,r2,255
 4022430:	008100f4 	movhi	r2,1027
 4022434:	10843904 	addi	r2,r2,4324
 4022438:	80c7c83a 	sub	r3,r16,r3
 402243c:	10c5883a 	add	r2,r2,r3
 4022440:	10800003 	ldbu	r2,0(r2)
 4022444:	d8801205 	stb	r2,72(sp)
 4022448:	003f2c06 	br	40220fc <aes_mixcolumns+0x4f4>
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 402244c:	1545883a 	add	r2,r2,r21
 4022450:	10c00003 	ldbu	r3,0(r2)
 4022454:	008003c4 	movi	r2,15
 4022458:	e0e1883a 	add	r16,fp,r3
 402245c:	81003fd4 	ori	r4,r16,255
 4022460:	11015b36 	bltu	r2,r4,40229d0 <aes_mixcolumns+0xdc8>
 4022464:	8004913a 	slli	r2,r16,4
 4022468:	00c100f4 	movhi	r3,1027
 402246c:	18f72704 	addi	r3,r3,-9060
 4022470:	10803fd4 	ori	r2,r2,255
 4022474:	10c5883a 	add	r2,r2,r3
 4022478:	10800003 	ldbu	r2,0(r2)
 402247c:	10c03fe4 	muli	r3,r2,255
 4022480:	008100f4 	movhi	r2,1027
 4022484:	10843904 	addi	r2,r2,4324
 4022488:	80c7c83a 	sub	r3,r16,r3
 402248c:	10c5883a 	add	r2,r2,r3
 4022490:	10c00003 	ldbu	r3,0(r2)
 4022494:	003f1006 	br	40220d8 <aes_mixcolumns+0x4d0>
 4022498:	1d45883a 	add	r2,r3,r21
 402249c:	10c00003 	ldbu	r3,0(r2)
 40224a0:	008003c4 	movi	r2,15
 40224a4:	b8e1883a 	add	r16,r23,r3
 40224a8:	81003fd4 	ori	r4,r16,255
 40224ac:	11014436 	bltu	r2,r4,40229c0 <aes_mixcolumns+0xdb8>
 40224b0:	8004913a 	slli	r2,r16,4
 40224b4:	00c100f4 	movhi	r3,1027
 40224b8:	18f72704 	addi	r3,r3,-9060
 40224bc:	10803fd4 	ori	r2,r2,255
 40224c0:	10c5883a 	add	r2,r2,r3
 40224c4:	10800003 	ldbu	r2,0(r2)
 40224c8:	10c03fe4 	muli	r3,r2,255
 40224cc:	008100f4 	movhi	r2,1027
 40224d0:	10843904 	addi	r2,r2,4324
 40224d4:	80c7c83a 	sub	r3,r16,r3
 40224d8:	10c5883a 	add	r2,r2,r3
 40224dc:	10800003 	ldbu	r2,0(r2)
 40224e0:	d8800d05 	stb	r2,52(sp)
 40224e4:	003ef906 	br	40220cc <aes_mixcolumns+0x4c4>
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 40224e8:	1d45883a 	add	r2,r3,r21
 40224ec:	10c00003 	ldbu	r3,0(r2)
 40224f0:	008003c4 	movi	r2,15
 40224f4:	e0e1883a 	add	r16,fp,r3
 40224f8:	81003fd4 	ori	r4,r16,255
 40224fc:	11012c36 	bltu	r2,r4,40229b0 <aes_mixcolumns+0xda8>
 4022500:	8004913a 	slli	r2,r16,4
 4022504:	00c100f4 	movhi	r3,1027
 4022508:	18f72704 	addi	r3,r3,-9060
 402250c:	10803fd4 	ori	r2,r2,255
 4022510:	10c5883a 	add	r2,r2,r3
 4022514:	10800003 	ldbu	r2,0(r2)
 4022518:	10c03fe4 	muli	r3,r2,255
 402251c:	008100f4 	movhi	r2,1027
 4022520:	10843904 	addi	r2,r2,4324
 4022524:	80c7c83a 	sub	r3,r16,r3
 4022528:	10c5883a 	add	r2,r2,r3
 402252c:	10800003 	ldbu	r2,0(r2)
 4022530:	d8800a05 	stb	r2,40(sp)
 4022534:	003ec906 	br	402205c <aes_mixcolumns+0x454>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022538:	1d45883a 	add	r2,r3,r21
 402253c:	10c00003 	ldbu	r3,0(r2)
 4022540:	008003c4 	movi	r2,15
 4022544:	e0e1883a 	add	r16,fp,r3
 4022548:	81003fd4 	ori	r4,r16,255
 402254c:	11011436 	bltu	r2,r4,40229a0 <aes_mixcolumns+0xd98>
 4022550:	8004913a 	slli	r2,r16,4
 4022554:	00c100f4 	movhi	r3,1027
 4022558:	18f72704 	addi	r3,r3,-9060
 402255c:	10803fd4 	ori	r2,r2,255
 4022560:	10c5883a 	add	r2,r2,r3
 4022564:	10800003 	ldbu	r2,0(r2)
 4022568:	10c03fe4 	muli	r3,r2,255
 402256c:	008100f4 	movhi	r2,1027
 4022570:	10843904 	addi	r2,r2,4324
 4022574:	80c7c83a 	sub	r3,r16,r3
 4022578:	10c5883a 	add	r2,r2,r3
 402257c:	10800003 	ldbu	r2,0(r2)
 4022580:	d8800705 	stb	r2,28(sp)
 4022584:	003e9906 	br	4021fec <aes_mixcolumns+0x3e4>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022588:	1d45883a 	add	r2,r3,r21
 402258c:	10c00003 	ldbu	r3,0(r2)
 4022590:	008003c4 	movi	r2,15
 4022594:	e0e1883a 	add	r16,fp,r3
 4022598:	81003fd4 	ori	r4,r16,255
 402259c:	1100fc36 	bltu	r2,r4,4022990 <aes_mixcolumns+0xd88>
 40225a0:	8004913a 	slli	r2,r16,4
 40225a4:	00c100f4 	movhi	r3,1027
 40225a8:	18f72704 	addi	r3,r3,-9060
 40225ac:	10803fd4 	ori	r2,r2,255
 40225b0:	10c5883a 	add	r2,r2,r3
 40225b4:	10800003 	ldbu	r2,0(r2)
 40225b8:	10c03fe4 	muli	r3,r2,255
 40225bc:	008100f4 	movhi	r2,1027
 40225c0:	10843904 	addi	r2,r2,4324
 40225c4:	80c7c83a 	sub	r3,r16,r3
 40225c8:	10c5883a 	add	r2,r2,r3
 40225cc:	10800003 	ldbu	r2,0(r2)
 40225d0:	d8800405 	stb	r2,16(sp)
 40225d4:	003e6606 	br	4021f70 <aes_mixcolumns+0x368>
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40225d8:	1545883a 	add	r2,r2,r21
 40225dc:	10c00003 	ldbu	r3,0(r2)
 40225e0:	008003c4 	movi	r2,15
 40225e4:	e0e1883a 	add	r16,fp,r3
 40225e8:	81003fd4 	ori	r4,r16,255
 40225ec:	1100e436 	bltu	r2,r4,4022980 <aes_mixcolumns+0xd78>
 40225f0:	8004913a 	slli	r2,r16,4
 40225f4:	00c100f4 	movhi	r3,1027
 40225f8:	18f72704 	addi	r3,r3,-9060
 40225fc:	10803fd4 	ori	r2,r2,255
 4022600:	10c5883a 	add	r2,r2,r3
 4022604:	10800003 	ldbu	r2,0(r2)
 4022608:	10c03fe4 	muli	r3,r2,255
 402260c:	008100f4 	movhi	r2,1027
 4022610:	10843904 	addi	r2,r2,4324
 4022614:	80c7c83a 	sub	r3,r16,r3
 4022618:	10c5883a 	add	r2,r2,r3
 402261c:	10c00003 	ldbu	r3,0(r2)
 4022620:	003e4a06 	br	4021f4c <aes_mixcolumns+0x344>
 4022624:	1d45883a 	add	r2,r3,r21
 4022628:	10c00003 	ldbu	r3,0(r2)
 402262c:	008003c4 	movi	r2,15
 4022630:	b8e1883a 	add	r16,r23,r3
 4022634:	81003fd4 	ori	r4,r16,255
 4022638:	1100cd36 	bltu	r2,r4,4022970 <aes_mixcolumns+0xd68>
 402263c:	8004913a 	slli	r2,r16,4
 4022640:	00c100f4 	movhi	r3,1027
 4022644:	18f72704 	addi	r3,r3,-9060
 4022648:	10803fd4 	ori	r2,r2,255
 402264c:	10c5883a 	add	r2,r2,r3
 4022650:	10800003 	ldbu	r2,0(r2)
 4022654:	10c03fe4 	muli	r3,r2,255
 4022658:	008100f4 	movhi	r2,1027
 402265c:	10843904 	addi	r2,r2,4324
 4022660:	80c7c83a 	sub	r3,r16,r3
 4022664:	10c5883a 	add	r2,r2,r3
 4022668:	10800003 	ldbu	r2,0(r2)
 402266c:	d8800e05 	stb	r2,56(sp)
 4022670:	003e3306 	br	4021f40 <aes_mixcolumns+0x338>
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022674:	1d45883a 	add	r2,r3,r21
 4022678:	10c00003 	ldbu	r3,0(r2)
 402267c:	008003c4 	movi	r2,15
 4022680:	e0e1883a 	add	r16,fp,r3
 4022684:	81003fd4 	ori	r4,r16,255
 4022688:	1100b536 	bltu	r2,r4,4022960 <aes_mixcolumns+0xd58>
 402268c:	8004913a 	slli	r2,r16,4
 4022690:	00c100f4 	movhi	r3,1027
 4022694:	18f72704 	addi	r3,r3,-9060
 4022698:	10803fd4 	ori	r2,r2,255
 402269c:	10c5883a 	add	r2,r2,r3
 40226a0:	10800003 	ldbu	r2,0(r2)
 40226a4:	10c03fe4 	muli	r3,r2,255
 40226a8:	008100f4 	movhi	r2,1027
 40226ac:	10843904 	addi	r2,r2,4324
 40226b0:	80c7c83a 	sub	r3,r16,r3
 40226b4:	10c5883a 	add	r2,r2,r3
 40226b8:	10800003 	ldbu	r2,0(r2)
 40226bc:	d8800b05 	stb	r2,44(sp)
 40226c0:	003e0306 	br	4021ed0 <aes_mixcolumns+0x2c8>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 40226c4:	1d45883a 	add	r2,r3,r21
 40226c8:	10c00003 	ldbu	r3,0(r2)
 40226cc:	008003c4 	movi	r2,15
 40226d0:	e0e1883a 	add	r16,fp,r3
 40226d4:	81003fd4 	ori	r4,r16,255
 40226d8:	11009d36 	bltu	r2,r4,4022950 <aes_mixcolumns+0xd48>
 40226dc:	8004913a 	slli	r2,r16,4
 40226e0:	00c100f4 	movhi	r3,1027
 40226e4:	18f72704 	addi	r3,r3,-9060
 40226e8:	10803fd4 	ori	r2,r2,255
 40226ec:	10c5883a 	add	r2,r2,r3
 40226f0:	10800003 	ldbu	r2,0(r2)
 40226f4:	10c03fe4 	muli	r3,r2,255
 40226f8:	008100f4 	movhi	r2,1027
 40226fc:	10843904 	addi	r2,r2,4324
 4022700:	80c7c83a 	sub	r3,r16,r3
 4022704:	10c5883a 	add	r2,r2,r3
 4022708:	10800003 	ldbu	r2,0(r2)
 402270c:	d8800805 	stb	r2,32(sp)
 4022710:	003dd306 	br	4021e60 <aes_mixcolumns+0x258>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022714:	1d45883a 	add	r2,r3,r21
 4022718:	10c00003 	ldbu	r3,0(r2)
 402271c:	008003c4 	movi	r2,15
 4022720:	e0e1883a 	add	r16,fp,r3
 4022724:	81003fd4 	ori	r4,r16,255
 4022728:	11008536 	bltu	r2,r4,4022940 <aes_mixcolumns+0xd38>
 402272c:	8004913a 	slli	r2,r16,4
 4022730:	00c100f4 	movhi	r3,1027
 4022734:	18f72704 	addi	r3,r3,-9060
 4022738:	10803fd4 	ori	r2,r2,255
 402273c:	10c5883a 	add	r2,r2,r3
 4022740:	10800003 	ldbu	r2,0(r2)
 4022744:	10c03fe4 	muli	r3,r2,255
 4022748:	008100f4 	movhi	r2,1027
 402274c:	10843904 	addi	r2,r2,4324
 4022750:	80c7c83a 	sub	r3,r16,r3
 4022754:	10c5883a 	add	r2,r2,r3
 4022758:	10800003 	ldbu	r2,0(r2)
 402275c:	d8800505 	stb	r2,20(sp)
 4022760:	003da006 	br	4021de4 <aes_mixcolumns+0x1dc>
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4022764:	1545883a 	add	r2,r2,r21
 4022768:	10c00003 	ldbu	r3,0(r2)
 402276c:	008003c4 	movi	r2,15
 4022770:	e0e1883a 	add	r16,fp,r3
 4022774:	81003fd4 	ori	r4,r16,255
 4022778:	11006d36 	bltu	r2,r4,4022930 <aes_mixcolumns+0xd28>
 402277c:	8004913a 	slli	r2,r16,4
 4022780:	00c100f4 	movhi	r3,1027
 4022784:	18f72704 	addi	r3,r3,-9060
 4022788:	10803fd4 	ori	r2,r2,255
 402278c:	10c5883a 	add	r2,r2,r3
 4022790:	10800003 	ldbu	r2,0(r2)
 4022794:	10c03fe4 	muli	r3,r2,255
 4022798:	008100f4 	movhi	r2,1027
 402279c:	10843904 	addi	r2,r2,4324
 40227a0:	80c7c83a 	sub	r3,r16,r3
 40227a4:	10c5883a 	add	r2,r2,r3
 40227a8:	10c00003 	ldbu	r3,0(r2)
 40227ac:	003d8406 	br	4021dc0 <aes_mixcolumns+0x1b8>
 40227b0:	1d45883a 	add	r2,r3,r21
 40227b4:	10c00003 	ldbu	r3,0(r2)
 40227b8:	008003c4 	movi	r2,15
 40227bc:	b8e1883a 	add	r16,r23,r3
 40227c0:	81003fd4 	ori	r4,r16,255
 40227c4:	11005636 	bltu	r2,r4,4022920 <aes_mixcolumns+0xd18>
 40227c8:	8004913a 	slli	r2,r16,4
 40227cc:	00c100f4 	movhi	r3,1027
 40227d0:	18f72704 	addi	r3,r3,-9060
 40227d4:	10803fd4 	ori	r2,r2,255
 40227d8:	10c5883a 	add	r2,r2,r3
 40227dc:	10800003 	ldbu	r2,0(r2)
 40227e0:	10c03fe4 	muli	r3,r2,255
 40227e4:	008100f4 	movhi	r2,1027
 40227e8:	10843904 	addi	r2,r2,4324
 40227ec:	80c7c83a 	sub	r3,r16,r3
 40227f0:	10c5883a 	add	r2,r2,r3
 40227f4:	10800003 	ldbu	r2,0(r2)
 40227f8:	d8800f05 	stb	r2,60(sp)
 40227fc:	003d6d06 	br	4021db4 <aes_mixcolumns+0x1ac>
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022800:	1d45883a 	add	r2,r3,r21
 4022804:	10c00003 	ldbu	r3,0(r2)
 4022808:	008003c4 	movi	r2,15
 402280c:	e0e1883a 	add	r16,fp,r3
 4022810:	81003fd4 	ori	r4,r16,255
 4022814:	11003e36 	bltu	r2,r4,4022910 <aes_mixcolumns+0xd08>
 4022818:	8004913a 	slli	r2,r16,4
 402281c:	00c100f4 	movhi	r3,1027
 4022820:	18f72704 	addi	r3,r3,-9060
 4022824:	10803fd4 	ori	r2,r2,255
 4022828:	10c5883a 	add	r2,r2,r3
 402282c:	10800003 	ldbu	r2,0(r2)
 4022830:	10c03fe4 	muli	r3,r2,255
 4022834:	008100f4 	movhi	r2,1027
 4022838:	10843904 	addi	r2,r2,4324
 402283c:	80c7c83a 	sub	r3,r16,r3
 4022840:	10c5883a 	add	r2,r2,r3
 4022844:	10800003 	ldbu	r2,0(r2)
 4022848:	d8800c05 	stb	r2,48(sp)
 402284c:	003d3d06 	br	4021d44 <aes_mixcolumns+0x13c>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022850:	1d45883a 	add	r2,r3,r21
 4022854:	10c00003 	ldbu	r3,0(r2)
 4022858:	008003c4 	movi	r2,15
 402285c:	e0e1883a 	add	r16,fp,r3
 4022860:	81003fd4 	ori	r4,r16,255
 4022864:	11002636 	bltu	r2,r4,4022900 <aes_mixcolumns+0xcf8>
 4022868:	8004913a 	slli	r2,r16,4
 402286c:	00c100f4 	movhi	r3,1027
 4022870:	18f72704 	addi	r3,r3,-9060
 4022874:	10803fd4 	ori	r2,r2,255
 4022878:	10c5883a 	add	r2,r2,r3
 402287c:	10800003 	ldbu	r2,0(r2)
 4022880:	10c03fe4 	muli	r3,r2,255
 4022884:	008100f4 	movhi	r2,1027
 4022888:	10843904 	addi	r2,r2,4324
 402288c:	80c7c83a 	sub	r3,r16,r3
 4022890:	10c5883a 	add	r2,r2,r3
 4022894:	10800003 	ldbu	r2,0(r2)
 4022898:	d8800905 	stb	r2,36(sp)
 402289c:	003d0d06 	br	4021cd4 <aes_mixcolumns+0xcc>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 40228a0:	1545883a 	add	r2,r2,r21
 40228a4:	10c00003 	ldbu	r3,0(r2)
 40228a8:	008003c4 	movi	r2,15
 40228ac:	1f21883a 	add	r16,r3,fp
 40228b0:	81003fd4 	ori	r4,r16,255
 40228b4:	11000e36 	bltu	r2,r4,40228f0 <aes_mixcolumns+0xce8>
 40228b8:	8004913a 	slli	r2,r16,4
 40228bc:	00c100f4 	movhi	r3,1027
 40228c0:	18f72704 	addi	r3,r3,-9060
 40228c4:	10803fd4 	ori	r2,r2,255
 40228c8:	10c5883a 	add	r2,r2,r3
 40228cc:	10800003 	ldbu	r2,0(r2)
 40228d0:	10c03fe4 	muli	r3,r2,255
 40228d4:	008100f4 	movhi	r2,1027
 40228d8:	10843904 	addi	r2,r2,4324
 40228dc:	80c7c83a 	sub	r3,r16,r3
 40228e0:	10c5883a 	add	r2,r2,r3
 40228e4:	10800003 	ldbu	r2,0(r2)
 40228e8:	d8800605 	stb	r2,24(sp)
 40228ec:	003cda06 	br	4021c58 <aes_mixcolumns+0x50>
 40228f0:	8009883a 	mov	r4,r16
 40228f4:	01403fc4 	movi	r5,255
 40228f8:	40265d40 	call	40265d4 <__divsi3>
 40228fc:	003ff406 	br	40228d0 <aes_mixcolumns+0xcc8>
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022900:	8009883a 	mov	r4,r16
 4022904:	01403fc4 	movi	r5,255
 4022908:	40265d40 	call	40265d4 <__divsi3>
 402290c:	003fdc06 	br	4022880 <aes_mixcolumns+0xc78>
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022910:	8009883a 	mov	r4,r16
 4022914:	01403fc4 	movi	r5,255
 4022918:	40265d40 	call	40265d4 <__divsi3>
 402291c:	003fc406 	br	4022830 <aes_mixcolumns+0xc28>
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4022920:	8009883a 	mov	r4,r16
 4022924:	01403fc4 	movi	r5,255
 4022928:	40265d40 	call	40265d4 <__divsi3>
 402292c:	003fac06 	br	40227e0 <aes_mixcolumns+0xbd8>
 4022930:	8009883a 	mov	r4,r16
 4022934:	01403fc4 	movi	r5,255
 4022938:	40265d40 	call	40265d4 <__divsi3>
 402293c:	003f9506 	br	4022794 <aes_mixcolumns+0xb8c>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022940:	8009883a 	mov	r4,r16
 4022944:	01403fc4 	movi	r5,255
 4022948:	40265d40 	call	40265d4 <__divsi3>
 402294c:	003f7d06 	br	4022744 <aes_mixcolumns+0xb3c>
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022950:	8009883a 	mov	r4,r16
 4022954:	01403fc4 	movi	r5,255
 4022958:	40265d40 	call	40265d4 <__divsi3>
 402295c:	003f6506 	br	40226f4 <aes_mixcolumns+0xaec>
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022960:	8009883a 	mov	r4,r16
 4022964:	01403fc4 	movi	r5,255
 4022968:	40265d40 	call	40265d4 <__divsi3>
 402296c:	003f4d06 	br	40226a4 <aes_mixcolumns+0xa9c>
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 4022970:	8009883a 	mov	r4,r16
 4022974:	01403fc4 	movi	r5,255
 4022978:	40265d40 	call	40265d4 <__divsi3>
 402297c:	003f3506 	br	4022654 <aes_mixcolumns+0xa4c>
 4022980:	8009883a 	mov	r4,r16
 4022984:	01403fc4 	movi	r5,255
 4022988:	40265d40 	call	40265d4 <__divsi3>
 402298c:	003f1e06 	br	4022608 <aes_mixcolumns+0xa00>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022990:	8009883a 	mov	r4,r16
 4022994:	01403fc4 	movi	r5,255
 4022998:	40265d40 	call	40265d4 <__divsi3>
 402299c:	003f0606 	br	40225b8 <aes_mixcolumns+0x9b0>
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 40229a0:	8009883a 	mov	r4,r16
 40229a4:	01403fc4 	movi	r5,255
 40229a8:	40265d40 	call	40265d4 <__divsi3>
 40229ac:	003eee06 	br	4022568 <aes_mixcolumns+0x960>
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 40229b0:	8009883a 	mov	r4,r16
 40229b4:	01403fc4 	movi	r5,255
 40229b8:	40265d40 	call	40265d4 <__divsi3>
 40229bc:	003ed606 	br	4022518 <aes_mixcolumns+0x910>
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40229c0:	8009883a 	mov	r4,r16
 40229c4:	01403fc4 	movi	r5,255
 40229c8:	40265d40 	call	40265d4 <__divsi3>
 40229cc:	003ebe06 	br	40224c8 <aes_mixcolumns+0x8c0>
 40229d0:	8009883a 	mov	r4,r16
 40229d4:	01403fc4 	movi	r5,255
 40229d8:	40265d40 	call	40265d4 <__divsi3>
 40229dc:	003ea706 	br	402247c <aes_mixcolumns+0x874>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 40229e0:	8009883a 	mov	r4,r16
 40229e4:	01403fc4 	movi	r5,255
 40229e8:	40265d40 	call	40265d4 <__divsi3>
 40229ec:	003e8f06 	br	402242c <aes_mixcolumns+0x824>
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
				ctx->state[1][i] ^
				aes_mul(0x02, ctx->state[2][i]) ^
				aes_mul(0x03, ctx->state[3][i]);
		nstate[3][i] = aes_mul(0x03, ctx->state[0][i]) ^
 40229f0:	8009883a 	mov	r4,r16
 40229f4:	01403fc4 	movi	r5,255
 40229f8:	40265d40 	call	40265d4 <__divsi3>
 40229fc:	003e7806 	br	40223e0 <aes_mixcolumns+0x7d8>
 4022a00:	8009883a 	mov	r4,r16
 4022a04:	01403fc4 	movi	r5,255
 4022a08:	40265d40 	call	40265d4 <__divsi3>
 4022a0c:	003e6106 	br	4022394 <aes_mixcolumns+0x78c>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022a10:	8009883a 	mov	r4,r16
 4022a14:	01403fc4 	movi	r5,255
 4022a18:	40265d40 	call	40265d4 <__divsi3>
 4022a1c:	003e4906 	br	4022344 <aes_mixcolumns+0x73c>
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022a20:	8009883a 	mov	r4,r16
 4022a24:	01403fc4 	movi	r5,255
 4022a28:	40265d40 	call	40265d4 <__divsi3>
 4022a2c:	003e3106 	br	40222f4 <aes_mixcolumns+0x6ec>
 4022a30:	8009883a 	mov	r4,r16
 4022a34:	01403fc4 	movi	r5,255
 4022a38:	40265d40 	call	40265d4 <__divsi3>
 4022a3c:	003df806 	br	4022220 <aes_mixcolumns+0x618>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022a40:	8009883a 	mov	r4,r16
 4022a44:	01403fc4 	movi	r5,255
 4022a48:	40265d40 	call	40265d4 <__divsi3>
 4022a4c:	003dd806 	br	40221b0 <aes_mixcolumns+0x5a8>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022a50:	8009883a 	mov	r4,r16
 4022a54:	01403fc4 	movi	r5,255
 4022a58:	40265d40 	call	40265d4 <__divsi3>
 4022a5c:	003db606 	br	4022138 <aes_mixcolumns+0x530>
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022a60:	8009883a 	mov	r4,r16
 4022a64:	01403fc4 	movi	r5,255
 4022a68:	40265d40 	call	40265d4 <__divsi3>
 4022a6c:	003d8906 	br	4022094 <aes_mixcolumns+0x48c>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022a70:	8009883a 	mov	r4,r16
 4022a74:	01403fc4 	movi	r5,255
 4022a78:	40265d40 	call	40265d4 <__divsi3>
 4022a7c:	003d6906 	br	4022024 <aes_mixcolumns+0x41c>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022a80:	8009883a 	mov	r4,r16
 4022a84:	01403fc4 	movi	r5,255
 4022a88:	40265d40 	call	40265d4 <__divsi3>
 4022a8c:	003d4706 	br	4021fac <aes_mixcolumns+0x3a4>
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022a90:	8009883a 	mov	r4,r16
 4022a94:	01403fc4 	movi	r5,255
 4022a98:	40265d40 	call	40265d4 <__divsi3>
 4022a9c:	003d1a06 	br	4021f08 <aes_mixcolumns+0x300>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022aa0:	8009883a 	mov	r4,r16
 4022aa4:	01403fc4 	movi	r5,255
 4022aa8:	40265d40 	call	40265d4 <__divsi3>
 4022aac:	003cfa06 	br	4021e98 <aes_mixcolumns+0x290>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022ab0:	8009883a 	mov	r4,r16
 4022ab4:	01403fc4 	movi	r5,255
 4022ab8:	40265d40 	call	40265d4 <__divsi3>
 4022abc:	003cd806 	br	4021e20 <aes_mixcolumns+0x218>
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
				aes_mul(0x02, ctx->state[1][i]) ^
				aes_mul(0x03, ctx->state[2][i]) ^
				ctx->state[3][i];
		nstate[2][i] = ctx->state[0][i] ^
 4022ac0:	8009883a 	mov	r4,r16
 4022ac4:	01403fc4 	movi	r5,255
 4022ac8:	40265d40 	call	40265d4 <__divsi3>
 4022acc:	003cab06 	br	4021d7c <aes_mixcolumns+0x174>
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
				aes_mul(0x03, ctx->state[1][i]) ^
				ctx->state[2][i] ^
				ctx->state[3][i];
		nstate[1][i] = ctx->state[0][i] ^
 4022ad0:	8009883a 	mov	r4,r16
 4022ad4:	01403fc4 	movi	r5,255
 4022ad8:	40265d40 	call	40265d4 <__divsi3>
 4022adc:	003c8b06 	br	4021d0c <aes_mixcolumns+0x104>
{
	unsigned char nstate[4][4];
	int i;
	
	for(i = 0; i < 4; i++) {
		nstate[0][i] = aes_mul(0x02, ctx->state[0][i]) ^ 
 4022ae0:	8009883a 	mov	r4,r16
 4022ae4:	01403fc4 	movi	r5,255
 4022ae8:	40265d40 	call	40265d4 <__divsi3>
 4022aec:	003c6906 	br	4021c94 <aes_mixcolumns+0x8c>

04022af0 <aes_shiftrows>:
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4022af0:	20800003 	ldbu	r2,0(r4)
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
	}
}

void aes_shiftrows(aes_ctx_t *ctx)
{
 4022af4:	defffc04 	addi	sp,sp,-16
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4022af8:	20c00043 	ldbu	r3,1(r4)
 4022afc:	21400083 	ldbu	r5,2(r4)
 4022b00:	218000c3 	ldbu	r6,3(r4)
 4022b04:	d8800005 	stb	r2,0(sp)
 4022b08:	20800143 	ldbu	r2,5(r4)
 4022b0c:	d8c00045 	stb	r3,1(sp)
 4022b10:	d9400085 	stb	r5,2(sp)
 4022b14:	d98000c5 	stb	r6,3(sp)
 4022b18:	20c00283 	ldbu	r3,10(r4)
 4022b1c:	214003c3 	ldbu	r5,15(r4)
 4022b20:	21800183 	ldbu	r6,6(r4)
 4022b24:	21c002c3 	ldbu	r7,11(r4)
 4022b28:	22000303 	ldbu	r8,12(r4)
 4022b2c:	224001c3 	ldbu	r9,7(r4)
 4022b30:	22800203 	ldbu	r10,8(r4)
 4022b34:	22c00343 	ldbu	r11,13(r4)
 4022b38:	23000103 	ldbu	r12,4(r4)
 4022b3c:	23400243 	ldbu	r13,9(r4)
 4022b40:	23800383 	ldbu	r14,14(r4)
 4022b44:	d8800105 	stb	r2,4(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4022b48:	d8800017 	ldw	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4022b4c:	d8c00205 	stb	r3,8(sp)
 4022b50:	d9400305 	stb	r5,12(sp)
 4022b54:	d9800145 	stb	r6,5(sp)
 4022b58:	d9c00245 	stb	r7,9(sp)
 4022b5c:	da000345 	stb	r8,13(sp)
 4022b60:	da400185 	stb	r9,6(sp)
 4022b64:	da800285 	stb	r10,10(sp)
 4022b68:	dac00385 	stb	r11,14(sp)
 4022b6c:	db0001c5 	stb	r12,7(sp)
 4022b70:	db4002c5 	stb	r13,11(sp)
 4022b74:	db8003c5 	stb	r14,15(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4022b78:	20800015 	stw	r2,0(r4)
 4022b7c:	d8c00217 	ldw	r3,8(sp)
 4022b80:	d9400317 	ldw	r5,12(sp)
 4022b84:	d8800117 	ldw	r2,4(sp)
 4022b88:	20c00215 	stw	r3,8(r4)
 4022b8c:	21400315 	stw	r5,12(r4)
 4022b90:	20800115 	stw	r2,4(r4)
}
 4022b94:	dec00404 	addi	sp,sp,16
 4022b98:	f800283a 	ret

04022b9c <init_aes>:

unsigned char g_aes_logt[256], g_aes_ilogt[256];
unsigned char g_aes_sbox[256], g_aes_isbox[256];

void init_aes()
{
 4022b9c:	defff704 	addi	sp,sp,-36
 4022ba0:	df000815 	stw	fp,32(sp)
 4022ba4:	070100f4 	movhi	fp,1027
 4022ba8:	e7043904 	addi	fp,fp,4324
 4022bac:	0011883a 	mov	r8,zero
 4022bb0:	01800044 	movi	r6,1
 4022bb4:	e013883a 	mov	r9,fp
 4022bb8:	02c100f4 	movhi	r11,1027
 4022bbc:	5ac4f904 	addi	r11,r11,5092
 4022bc0:	02803fc4 	movi	r10,255
 4022bc4:	ddc00715 	stw	r23,28(sp)
 4022bc8:	dd800615 	stw	r22,24(sp)
 4022bcc:	dd400515 	stw	r21,20(sp)
 4022bd0:	dd000415 	stw	r20,16(sp)
 4022bd4:	dcc00315 	stw	r19,12(sp)
 4022bd8:	dc800215 	stw	r18,8(sp)
 4022bdc:	dc400115 	stw	r17,4(sp)
 4022be0:	dc000015 	stw	r16,0(sp)
 4022be4:	00000106 	br	4022bec <init_aes+0x50>
	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
		g_aes_logt[gen]  = i;
		g_aes_ilogt[i]   = gen;
		gen = aes_mul_manual(gen, AES_GEN);
 4022be8:	100d883a 	mov	r6,r2
	unsigned char gen;

	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
		g_aes_logt[gen]  = i;
 4022bec:	30803fcc 	andi	r2,r6,255
inline unsigned char aes_mul_manual(unsigned char a, unsigned char b)
{
	register unsigned short ac;
	register unsigned char ret;

	ac = a;
 4022bf0:	10c03fcc 	andi	r3,r2,255
	ret = 0;
	while(b) {
		if(b & 0x01)
			ret ^= ac;
		ac <<= 1;
 4022bf4:	18cf883a 	add	r7,r3,r3
	unsigned char gen;

	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
		g_aes_logt[gen]  = i;
 4022bf8:	12c5883a 	add	r2,r2,r11
	while(b) {
		if(b & 0x01)
			ret ^= ac;
		ac <<= 1;
		b >>= 1;
		if(ac & 0x0100)
 4022bfc:	3900400c 	andi	r4,r7,256

	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
		g_aes_logt[gen]  = i;
		g_aes_ilogt[i]   = gen;
 4022c00:	49800005 	stb	r6,0(r9)
	unsigned char gen;

	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
		g_aes_logt[gen]  = i;
 4022c04:	12000005 	stb	r8,0(r2)
	ac = a;
	ret = 0;
	while(b) {
		if(b & 0x01)
			ret ^= ac;
		ac <<= 1;
 4022c08:	380b883a 	mov	r5,r7
	int i;
	unsigned char gen;

	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
 4022c0c:	42000044 	addi	r8,r8,1
 4022c10:	4a400044 	addi	r9,r9,1
	while(b) {
		if(b & 0x01)
			ret ^= ac;
		ac <<= 1;
		b >>= 1;
		if(ac & 0x0100)
 4022c14:	20000126 	beq	r4,zero,4022c1c <init_aes+0x80>
			ac ^= AES_RPOL;
 4022c18:	394046dc 	xori	r5,r7,283

	ac = a;
	ret = 0;
	while(b) {
		if(b & 0x01)
			ret ^= ac;
 4022c1c:	1944f03a 	xor	r2,r3,r5
	int i;
	unsigned char gen;

	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
 4022c20:	42bff11e 	bne	r8,r10,4022be8 <init_aes+0x4c>
 4022c24:	0007883a 	mov	r3,zero
 4022c28:	0029883a 	mov	r20,zero
 4022c2c:	058100f4 	movhi	r22,1027
 4022c30:	b584f904 	addi	r22,r22,5092
 4022c34:	054100f4 	movhi	r21,1027
 4022c38:	ad44b904 	addi	r21,r21,4836
 4022c3c:	05c100f4 	movhi	r23,1027
 4022c40:	bdc47904 	addi	r23,r23,4580

		g_aes_sbox[i] = 0;
		for(bi = 0; bi < 8; bi++) {
			// based on transformation 5.1
			// could also be done with a loop based on the matrix
			g_aes_sbox[i] |= ((inv & (1<<bi)?1:0)
 4022c44:	1813d0fa 	srai	r9,r3,3
 4022c48:	1825d17a 	srai	r18,r3,5
 4022c4c:	181fd1ba 	srai	r15,r3,6
 4022c50:	180fd07a 	srai	r7,r3,1
 4022c54:	180dd0ba 	srai	r6,r3,2
 4022c58:	1822d1fa 	srli	r17,r3,7
 4022c5c:	1811d13a 	srai	r8,r3,4
 4022c60:	9480004c 	andi	r18,r18,1
 4022c64:	7bc0004c 	andi	r15,r15,1
 4022c68:	39c0004c 	andi	r7,r7,1
 4022c6c:	3180004c 	andi	r6,r6,1
 4022c70:	4a40004c 	andi	r9,r9,1
 4022c74:	4200004c 	andi	r8,r8,1
 4022c78:	18c0004c 	andi	r3,r3,1
 4022c7c:	799cf03a 	xor	r14,r15,r6
 4022c80:	91daf03a 	xor	r13,r18,r7
 4022c84:	8a66f03a 	xor	r19,r17,r9
 4022c88:	7c4af03a 	xor	r5,r15,r17
 4022c8c:	1a04f03a 	xor	r2,r3,r8
 4022c90:	19e0f03a 	xor	r16,r3,r7
 4022c94:	3b96f03a 	xor	r11,r7,r14
 4022c98:	2940005c 	xori	r5,r5,1
 4022c9c:	1c48f03a 	xor	r4,r3,r17
 4022ca0:	93d4f03a 	xor	r10,r18,r15
 4022ca4:	1b46f03a 	xor	r3,r3,r13
 4022ca8:	34d8f03a 	xor	r12,r6,r19
 4022cac:	1946f03a 	xor	r3,r3,r5
 4022cb0:	398ef03a 	xor	r7,r7,r6
 4022cb4:	124af03a 	xor	r5,r2,r9
 4022cb8:	324cf03a 	xor	r6,r6,r9
 4022cbc:	22c8f03a 	xor	r4,r4,r11
 4022cc0:	8320f03a 	xor	r16,r16,r12
 4022cc4:	5280005c 	xori	r10,r10,1
 4022cc8:	1444f03a 	xor	r2,r2,r17
 4022ccc:	18c7883a 	add	r3,r3,r3
 4022cd0:	435af03a 	xor	r13,r8,r13
 4022cd4:	4252f03a 	xor	r9,r8,r9
 4022cd8:	1284f03a 	xor	r2,r2,r10
 4022cdc:	394ef03a 	xor	r7,r7,r5
 4022ce0:	2109883a 	add	r4,r4,r4
 4022ce4:	802090fa 	slli	r16,r16,3
 4022ce8:	3180005c 	xori	r6,r6,1
 4022cec:	10c4b03a 	or	r2,r2,r3
 4022cf0:	2109883a 	add	r4,r4,r4
 4022cf4:	699af03a 	xor	r13,r13,r6
 4022cf8:	380e913a 	slli	r7,r7,4
 4022cfc:	939cf03a 	xor	r14,r18,r14
 4022d00:	4a40005c 	xori	r9,r9,1
 4022d04:	1104b03a 	or	r2,r2,r4
 4022d08:	725cf03a 	xor	r14,r14,r9
 4022d0c:	4490f03a 	xor	r8,r8,r18
 4022d10:	7cdef03a 	xor	r15,r15,r19
 4022d14:	681a917a 	slli	r13,r13,5
 4022d18:	1404b03a 	or	r2,r2,r16
 4022d1c:	43d0f03a 	xor	r8,r8,r15
 4022d20:	701c91ba 	slli	r14,r14,6
 4022d24:	11c4b03a 	or	r2,r2,r7
 4022d28:	401091fa 	slli	r8,r8,7
 4022d2c:	1344b03a 	or	r2,r2,r13
 4022d30:	1384b03a 	or	r2,r2,r14
 4022d34:	1204b03a 	or	r2,r2,r8
						^ (inv & (1 << ((bi+6) & 7))?1:0)
						^ (inv & (1 << ((bi+7) & 7))?1:0) 
						^ (AES_SBOX_CC & (1 << bi)?1:0)
			) << bi;
		}
		g_aes_isbox[g_aes_sbox[i]] = i;
 4022d38:	15c7883a 	add	r3,r2,r23

		g_aes_sbox[i] = 0;
		for(bi = 0; bi < 8; bi++) {
			// based on transformation 5.1
			// could also be done with a loop based on the matrix
			g_aes_sbox[i] |= ((inv & (1<<bi)?1:0)
 4022d3c:	a8800005 	stb	r2,0(r21)
						^ (inv & (1 << ((bi+6) & 7))?1:0)
						^ (inv & (1 << ((bi+7) & 7))?1:0) 
						^ (AES_SBOX_CC & (1 << bi)?1:0)
			) << bi;
		}
		g_aes_isbox[g_aes_sbox[i]] = i;
 4022d40:	1d000005 	stb	r20,0(r3)
		g_aes_ilogt[i]   = gen;
		gen = aes_mul_manual(gen, AES_GEN);
	}

	// build S-Box and it's inverse
	for(i = 0; i <= 0xff; i++) {
 4022d44:	00804004 	movi	r2,256
 4022d48:	a5000044 	addi	r20,r20,1
 4022d4c:	b5800044 	addi	r22,r22,1
 4022d50:	ad400044 	addi	r21,r21,1
						^ (inv & (1 << ((bi+6) & 7))?1:0)
						^ (inv & (1 << ((bi+7) & 7))?1:0) 
						^ (AES_SBOX_CC & (1 << bi)?1:0)
			) << bi;
		}
		g_aes_isbox[g_aes_sbox[i]] = i;
 4022d54:	010100f4 	movhi	r4,1027
 4022d58:	21047904 	addi	r4,r4,4580
		g_aes_ilogt[i]   = gen;
		gen = aes_mul_manual(gen, AES_GEN);
	}

	// build S-Box and it's inverse
	for(i = 0; i <= 0xff; i++) {
 4022d5c:	a0800826 	beq	r20,r2,4022d80 <init_aes+0x1e4>
	// build logarithm table and it's inverse
	gen = 1;
	for(i = 0; i < 0xff; i++) {
		g_aes_logt[gen]  = i;
		g_aes_ilogt[i]   = gen;
		gen = aes_mul_manual(gen, AES_GEN);
 4022d60:	0007883a 	mov	r3,zero
	}

	// build S-Box and it's inverse
	for(i = 0; i <= 0xff; i++) {
		char bi;
		unsigned char inv = aes_inv(i);
 4022d64:	a03fb726 	beq	r20,zero,4022c44 <init_aes+0xa8>
 4022d68:	b0c00003 	ldbu	r3,0(r22)
 4022d6c:	00803fc4 	movi	r2,255
 4022d70:	10c5c83a 	sub	r2,r2,r3
 4022d74:	1705883a 	add	r2,r2,fp
 4022d78:	10c00003 	ldbu	r3,0(r2)
 4022d7c:	003fb106 	br	4022c44 <init_aes+0xa8>
			) << bi;
		}
		g_aes_isbox[g_aes_sbox[i]] = i;
	}
	// warning: quickhack
	g_aes_sbox[1] = 0x7c;
 4022d80:	00c01f04 	movi	r3,124
 4022d84:	008100f4 	movhi	r2,1027
 4022d88:	1084b904 	addi	r2,r2,4836
 4022d8c:	10c00045 	stb	r3,1(r2)
	g_aes_isbox[0x7c] = 1;
 4022d90:	00800044 	movi	r2,1
 4022d94:	20801f05 	stb	r2,124(r4)
	g_aes_isbox[0x63] = 0;
 4022d98:	200018c5 	stb	zero,99(r4)
}
 4022d9c:	df000817 	ldw	fp,32(sp)
 4022da0:	ddc00717 	ldw	r23,28(sp)
 4022da4:	dd800617 	ldw	r22,24(sp)
 4022da8:	dd400517 	ldw	r21,20(sp)
 4022dac:	dd000417 	ldw	r20,16(sp)
 4022db0:	dcc00317 	ldw	r19,12(sp)
 4022db4:	dc800217 	ldw	r18,8(sp)
 4022db8:	dc400117 	ldw	r17,4(sp)
 4022dbc:	dc000017 	ldw	r16,0(sp)
 4022dc0:	dec00904 	addi	sp,sp,36
 4022dc4:	f800283a 	ret

04022dc8 <aes_encrypt>:
			((ctx->keysched[round*4+y] & (0xff << (x*8))) >> (x*8));
	}
}

void aes_encrypt(aes_ctx_t *ctx, unsigned char input[16], unsigned char output[16])
{
 4022dc8:	deffcd04 	addi	sp,sp,-204
 4022dcc:	df003115 	stw	fp,196(sp)
 4022dd0:	dcc02c15 	stw	r19,176(sp)
 4022dd4:	dc402a15 	stw	r17,168(sp)
 4022dd8:	dc002915 	stw	r16,164(sp)
 4022ddc:	dfc03215 	stw	ra,200(sp)
 4022de0:	ddc03015 	stw	r23,192(sp)
 4022de4:	dd802f15 	stw	r22,188(sp)
 4022de8:	dd402e15 	stw	r21,184(sp)
 4022dec:	dd002d15 	stw	r20,180(sp)
 4022df0:	dc802b15 	stw	r18,172(sp)
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022df4:	29c00003 	ldbu	r7,0(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022df8:	22800617 	ldw	r10,24(r4)
			((ctx->keysched[round*4+y] & (0xff << (x*8))) >> (x*8));
	}
}

void aes_encrypt(aes_ctx_t *ctx, unsigned char input[16], unsigned char output[16])
{
 4022dfc:	2039883a 	mov	fp,r4
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e00:	21c00005 	stb	r7,0(r4)
 4022e04:	28800043 	ldbu	r2,1(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e08:	50ffc00c 	andi	r3,r10,65280
 4022e0c:	1806d23a 	srli	r3,r3,8
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e10:	20800105 	stb	r2,4(r4)
 4022e14:	29000083 	ldbu	r4,2(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e18:	1886f03a 	xor	r3,r3,r2
 4022e1c:	52003fec 	andhi	r8,r10,255
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e20:	e1000205 	stb	r4,8(fp)
 4022e24:	288000c3 	ldbu	r2,3(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e28:	4010d43a 	srli	r8,r8,16
 4022e2c:	51cef03a 	xor	r7,r10,r7
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e30:	e0800305 	stb	r2,12(fp)
 4022e34:	2a400103 	ldbu	r9,4(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e38:	4110f03a 	xor	r8,r8,r4
 4022e3c:	da001315 	stw	r8,76(sp)
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e40:	da400705 	stb	r9,28(sp)
 4022e44:	e2400045 	stb	r9,1(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e48:	5014d63a 	srli	r10,r10,24
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e4c:	2b800143 	ldbu	r14,5(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e50:	5094f03a 	xor	r10,r10,r2
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e54:	db800805 	stb	r14,32(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e58:	da801415 	stw	r10,80(sp)
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e5c:	e3800145 	stb	r14,5(fp)
 4022e60:	28800183 	ldbu	r2,6(r5)
			((ctx->keysched[round*4+y] & (0xff << (x*8))) >> (x*8));
	}
}

void aes_encrypt(aes_ctx_t *ctx, unsigned char input[16], unsigned char output[16])
{
 4022e64:	d9800615 	stw	r6,24(sp)
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e68:	d8800905 	stb	r2,36(sp)
 4022e6c:	e0800245 	stb	r2,9(fp)
 4022e70:	290001c3 	ldbu	r4,7(r5)
 4022e74:	d9000a05 	stb	r4,40(sp)
 4022e78:	e1000345 	stb	r4,13(fp)
 4022e7c:	2a400203 	ldbu	r9,8(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e80:	e2000917 	ldw	r8,36(fp)
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 4022e84:	e4c00517 	ldw	r19,20(fp)
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e88:	da400b05 	stb	r9,44(sp)
 4022e8c:	e2400085 	stb	r9,2(fp)
 4022e90:	2a800243 	ldbu	r10,9(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022e94:	42c03fec 	andhi	r11,r8,255
 4022e98:	5816d43a 	srli	r11,r11,16
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022e9c:	da800c05 	stb	r10,48(sp)
 4022ea0:	e2800185 	stb	r10,6(fp)
 4022ea4:	2b800283 	ldbu	r14,10(r5)
 4022ea8:	db800d05 	stb	r14,52(sp)
 4022eac:	e3800285 	stb	r14,10(fp)
 4022eb0:	288002c3 	ldbu	r2,11(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022eb4:	43bfc00c 	andi	r14,r8,65280
 4022eb8:	701cd23a 	srli	r14,r14,8
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022ebc:	d8800e05 	stb	r2,56(sp)
 4022ec0:	e0800385 	stb	r2,14(fp)
 4022ec4:	29000303 	ldbu	r4,12(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022ec8:	e0800717 	ldw	r2,28(fp)
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022ecc:	d9000f05 	stb	r4,60(sp)
 4022ed0:	e10000c5 	stb	r4,3(fp)
 4022ed4:	2a400343 	ldbu	r9,13(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022ed8:	113fc00c 	andi	r4,r2,65280
 4022edc:	1018d63a 	srli	r12,r2,24
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022ee0:	da401005 	stb	r9,64(sp)
 4022ee4:	e24001c5 	stb	r9,7(fp)
 4022ee8:	2a800383 	ldbu	r10,14(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022eec:	2008d23a 	srli	r4,r4,8
{
	int i;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4022ef0:	da801105 	stb	r10,68(sp)
 4022ef4:	e28002c5 	stb	r10,11(fp)
 4022ef8:	294003c3 	ldbu	r5,15(r5)
 4022efc:	d9401205 	stb	r5,72(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022f00:	e1c00005 	stb	r7,0(fp)
 4022f04:	e0c00105 	stb	r3,4(fp)
 4022f08:	db801515 	stw	r14,84(sp)
 4022f0c:	401cd63a 	srli	r14,r8,24
 4022f10:	e0c00817 	ldw	r3,32(fp)
 4022f14:	11403fec 	andhi	r5,r2,255
 4022f18:	db801615 	stw	r14,88(sp)
 4022f1c:	da400803 	ldbu	r9,32(sp)
 4022f20:	da800903 	ldbu	r10,36(sp)
 4022f24:	db800a03 	ldbu	r14,40(sp)
 4022f28:	280ad43a 	srli	r5,r5,16
 4022f2c:	19bfc00c 	andi	r6,r3,65280
 4022f30:	19c03fec 	andhi	r7,r3,255
 4022f34:	181ad63a 	srli	r13,r3,24
 4022f38:	2248f03a 	xor	r4,r4,r9
 4022f3c:	2a8af03a 	xor	r5,r5,r10
 4022f40:	da400c03 	ldbu	r9,48(sp)
 4022f44:	da800d03 	ldbu	r10,52(sp)
 4022f48:	6398f03a 	xor	r12,r12,r14
 4022f4c:	300cd23a 	srli	r6,r6,8
 4022f50:	db800e03 	ldbu	r14,56(sp)
 4022f54:	380ed43a 	srli	r7,r7,16
 4022f58:	324cf03a 	xor	r6,r6,r9
 4022f5c:	6b9af03a 	xor	r13,r13,r14
 4022f60:	da401517 	ldw	r9,84(sp)
 4022f64:	db801103 	ldbu	r14,68(sp)
 4022f68:	3a8ef03a 	xor	r7,r7,r10
 4022f6c:	da801003 	ldbu	r10,64(sp)
 4022f70:	5b96f03a 	xor	r11,r11,r14
 4022f74:	db800703 	ldbu	r14,28(sp)
 4022f78:	4aa2f03a 	xor	r17,r9,r10
 4022f7c:	da401617 	ldw	r9,88(sp)
 4022f80:	da801203 	ldbu	r10,72(sp)
 4022f84:	1384f03a 	xor	r2,r2,r14
 4022f88:	db801317 	ldw	r14,76(sp)
 4022f8c:	4aa0f03a 	xor	r16,r9,r10
 4022f90:	da400b03 	ldbu	r9,44(sp)
 4022f94:	da800f03 	ldbu	r10,60(sp)
 4022f98:	e3800205 	stb	r14,8(fp)
 4022f9c:	1a46f03a 	xor	r3,r3,r9
 4022fa0:	da401417 	ldw	r9,80(sp)
 4022fa4:	4290f03a 	xor	r8,r8,r10
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 4022fa8:	02800044 	movi	r10,1
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4022fac:	e2400305 	stb	r9,12(fp)
 4022fb0:	e0800045 	stb	r2,1(fp)
 4022fb4:	e1000145 	stb	r4,5(fp)
 4022fb8:	e1400245 	stb	r5,9(fp)
 4022fbc:	e3000345 	stb	r12,13(fp)
 4022fc0:	e0c00085 	stb	r3,2(fp)
 4022fc4:	e1800185 	stb	r6,6(fp)
 4022fc8:	e1c00285 	stb	r7,10(fp)
 4022fcc:	e3400385 	stb	r13,14(fp)
 4022fd0:	e20000c5 	stb	r8,3(fp)
 4022fd4:	e44001c5 	stb	r17,7(fp)
 4022fd8:	e2c002c5 	stb	r11,11(fp)
 4022fdc:	e40003c5 	stb	r16,15(fp)
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 4022fe0:	54c1ca2e 	bgeu	r10,r19,402370c <aes_encrypt+0x944>
 4022fe4:	da800515 	stw	r10,20(sp)
 4022fe8:	df000415 	stw	fp,16(sp)
 4022fec:	054100f4 	movhi	r21,1027
 4022ff0:	ad44b904 	addi	r21,r21,4836
 4022ff4:	e3c00d04 	addi	r15,fp,52
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4022ff8:	e0800003 	ldbu	r2,0(fp)
 4022ffc:	e0c00103 	ldbu	r3,4(fp)
 4023000:	e1000203 	ldbu	r4,8(fp)
 4023004:	1545883a 	add	r2,r2,r21
 4023008:	11400003 	ldbu	r5,0(r2)
 402300c:	1d47883a 	add	r3,r3,r21
 4023010:	2549883a 	add	r4,r4,r21
 4023014:	e1400005 	stb	r5,0(fp)
 4023018:	1dc00003 	ldbu	r23,0(r3)
 402301c:	e0800303 	ldbu	r2,12(fp)
 4023020:	e1400043 	ldbu	r5,1(fp)
 4023024:	e5c00105 	stb	r23,4(fp)
 4023028:	27c00003 	ldbu	ra,0(r4)
 402302c:	1545883a 	add	r2,r2,r21
 4023030:	2d4b883a 	add	r5,r5,r21
 4023034:	e7c00205 	stb	ra,8(fp)
 4023038:	12400003 	ldbu	r9,0(r2)
 402303c:	e0c00143 	ldbu	r3,5(fp)
 4023040:	e1000243 	ldbu	r4,9(fp)
 4023044:	e2400305 	stb	r9,12(fp)
 4023048:	29400003 	ldbu	r5,0(r5)
 402304c:	1d47883a 	add	r3,r3,r21
 4023050:	2549883a 	add	r4,r4,r21
 4023054:	d9401705 	stb	r5,92(sp)
 4023058:	29403fcc 	andi	r5,r5,255
 402305c:	e1400045 	stb	r5,1(fp)
 4023060:	1b400003 	ldbu	r13,0(r3)
 4023064:	e0800343 	ldbu	r2,13(fp)
 4023068:	e1400083 	ldbu	r5,2(fp)
 402306c:	e3400145 	stb	r13,5(fp)
 4023070:	25000003 	ldbu	r20,0(r4)
 4023074:	1545883a 	add	r2,r2,r21
 4023078:	2d4b883a 	add	r5,r5,r21
 402307c:	e5000245 	stb	r20,9(fp)
 4023080:	15800003 	ldbu	r22,0(r2)
 4023084:	e0c00183 	ldbu	r3,6(fp)
 4023088:	e1800283 	ldbu	r6,10(fp)
 402308c:	e5800345 	stb	r22,13(fp)
 4023090:	2ac00003 	ldbu	r11,0(r5)
 4023094:	1d47883a 	add	r3,r3,r21
 4023098:	354d883a 	add	r6,r6,r21
 402309c:	e2c00085 	stb	r11,2(fp)
 40230a0:	18c00003 	ldbu	r3,0(r3)
	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
		aes_subbytes(ctx);
		aes_shiftrows(ctx);
		aes_mixcolumns(ctx);
 40230a4:	e009883a 	mov	r4,fp
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40230a8:	d8c01745 	stb	r3,93(sp)
 40230ac:	e0800383 	ldbu	r2,14(fp)
 40230b0:	e0c00185 	stb	r3,6(fp)
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 40230b4:	db800517 	ldw	r14,20(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40230b8:	31800003 	ldbu	r6,0(r6)
 40230bc:	1545883a 	add	r2,r2,r21
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 40230c0:	73800044 	addi	r14,r14,1
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40230c4:	d9801785 	stb	r6,94(sp)
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 40230c8:	db800515 	stw	r14,20(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40230cc:	31803fcc 	andi	r6,r6,255
 40230d0:	e1800285 	stb	r6,10(fp)
 40230d4:	13000003 	ldbu	r12,0(r2)
 40230d8:	e08000c3 	ldbu	r2,3(fp)
 40230dc:	e0c001c3 	ldbu	r3,7(fp)
 40230e0:	e3000385 	stb	r12,14(fp)
 40230e4:	1545883a 	add	r2,r2,r21
 40230e8:	12000003 	ldbu	r8,0(r2)
 40230ec:	1d47883a 	add	r3,r3,r21
 40230f0:	e14002c3 	ldbu	r5,11(fp)
 40230f4:	e20000c5 	stb	r8,3(fp)
 40230f8:	19c00003 	ldbu	r7,0(r3)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 40230fc:	e0800003 	ldbu	r2,0(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023100:	e18003c3 	ldbu	r6,15(fp)
 4023104:	e1c001c5 	stb	r7,7(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023108:	da801743 	ldbu	r10,93(sp)
 402310c:	d8800005 	stb	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023110:	2d4b883a 	add	r5,r5,r21
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023114:	d8801703 	ldbu	r2,92(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023118:	28c00003 	ldbu	r3,0(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 402311c:	db400105 	stb	r13,4(sp)
 4023120:	da800145 	stb	r10,5(sp)
 4023124:	d9c00185 	stb	r7,6(sp)
 4023128:	dac00085 	stb	r11,2(sp)
 402312c:	da0000c5 	stb	r8,3(sp)
 4023130:	ddc001c5 	stb	r23,7(sp)
 4023134:	d8800045 	stb	r2,1(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023138:	e0c002c5 	stb	r3,11(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 402313c:	db801783 	ldbu	r14,94(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023140:	354d883a 	add	r6,r6,r21
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023144:	d8c00245 	stb	r3,9(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023148:	30c00003 	ldbu	r3,0(r6)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 402314c:	db800205 	stb	r14,8(sp)
 4023150:	dfc00285 	stb	ra,10(sp)
 4023154:	dd0002c5 	stb	r20,11(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023158:	d9400117 	ldw	r5,4(sp)
 402315c:	d9800217 	ldw	r6,8(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023160:	d8c00305 	stb	r3,12(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023164:	d8800017 	ldw	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023168:	da400345 	stb	r9,13(sp)
 402316c:	dd800385 	stb	r22,14(sp)
 4023170:	db0003c5 	stb	r12,15(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023174:	e0c003c5 	stb	r3,15(fp)
		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023178:	e1400115 	stw	r5,4(fp)
 402317c:	e1800215 	stw	r6,8(fp)
 4023180:	e0800015 	stw	r2,0(fp)
 4023184:	d8800317 	ldw	r2,12(sp)
 4023188:	e0800315 	stw	r2,12(fp)
	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
		aes_subbytes(ctx);
		aes_shiftrows(ctx);
		aes_mixcolumns(ctx);
 402318c:	dbc02815 	stw	r15,160(sp)
 4023190:	4021c080 	call	4021c08 <aes_mixcolumns>
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023194:	dbc02817 	ldw	r15,160(sp)
 4023198:	db800417 	ldw	r14,16(sp)
 402319c:	78ffff17 	ldw	r3,-4(r15)
 40231a0:	73800a03 	ldbu	r14,40(r14)
 40231a4:	79bffe17 	ldw	r6,-8(r15)
 40231a8:	19003fec 	andhi	r4,r3,255
 40231ac:	2012d43a 	srli	r9,r4,16
 40231b0:	1814d63a 	srli	r10,r3,24
 40231b4:	db801815 	stw	r14,96(sp)
 40231b8:	da401d15 	stw	r9,116(sp)
 40231bc:	da801f15 	stw	r10,124(sp)
 40231c0:	e3800003 	ldbu	r14,0(fp)
 40231c4:	da401817 	ldw	r9,96(sp)
 40231c8:	e5000343 	ldbu	r20,13(fp)
 40231cc:	302ed63a 	srli	r23,r6,24
 40231d0:	4b9cf03a 	xor	r14,r9,r14
 40231d4:	e4800103 	ldbu	r18,4(fp)
 40231d8:	e4400203 	ldbu	r17,8(fp)
 40231dc:	e4000303 	ldbu	r16,12(fp)
 40231e0:	e5800243 	ldbu	r22,9(fp)
 40231e4:	e2800083 	ldbu	r10,2(fp)
 40231e8:	e10000c3 	ldbu	r4,3(fp)
 40231ec:	bd2ef03a 	xor	r23,r23,r20
 40231f0:	db801915 	stw	r14,100(sp)
 40231f4:	e3800143 	ldbu	r14,5(fp)
 40231f8:	333fc00c 	andi	r12,r6,65280
 40231fc:	ddc01a15 	stw	r23,104(sp)
 4023200:	1b7fc00c 	andi	r13,r3,65280
 4023204:	e2400183 	ldbu	r9,6(fp)
 4023208:	6018d23a 	srli	r12,r12,8
 402320c:	681ad23a 	srli	r13,r13,8
 4023210:	78bffd17 	ldw	r2,-12(r15)
 4023214:	6398f03a 	xor	r12,r12,r14
 4023218:	6a5af03a 	xor	r13,r13,r9
 402321c:	db801d17 	ldw	r14,116(sp)
 4023220:	e2400283 	ldbu	r9,10(fp)
 4023224:	11c03fec 	andhi	r7,r2,255
 4023228:	32c03fec 	andhi	r11,r6,255
 402322c:	725cf03a 	xor	r14,r14,r9
 4023230:	db801e15 	stw	r14,120(sp)
 4023234:	e2400383 	ldbu	r9,14(fp)
 4023238:	db801f17 	ldw	r14,124(sp)
 402323c:	7a3ffd43 	ldbu	r8,-11(r15)
 4023240:	380ed43a 	srli	r7,r7,16
 4023244:	725cf03a 	xor	r14,r14,r9
 4023248:	7a7fff17 	ldw	r9,-4(r15)
 402324c:	db802015 	stw	r14,128(sp)
 4023250:	e3800043 	ldbu	r14,1(fp)
 4023254:	4a94f03a 	xor	r10,r9,r10
 4023258:	1004d63a 	srli	r2,r2,24
 402325c:	5816d43a 	srli	r11,r11,16
 4023260:	da801b15 	stw	r10,108(sp)
 4023264:	da801917 	ldw	r10,100(sp)
 4023268:	1404f03a 	xor	r2,r2,r16
 402326c:	338cf03a 	xor	r6,r6,r14
 4023270:	4490f03a 	xor	r8,r8,r18
 4023274:	3c4ef03a 	xor	r7,r7,r17
 4023278:	5d96f03a 	xor	r11,r11,r22
 402327c:	79400017 	ldw	r5,0(r15)
 4023280:	e2800005 	stb	r10,0(fp)
 4023284:	e2000105 	stb	r8,4(fp)
 4023288:	e1c00205 	stb	r7,8(fp)
 402328c:	e0800305 	stb	r2,12(fp)
 4023290:	e1800045 	stb	r6,1(fp)
 4023294:	e3000145 	stb	r12,5(fp)
 4023298:	e2c00245 	stb	r11,9(fp)
 402329c:	db801a17 	ldw	r14,104(sp)
 40232a0:	28ffc00c 	andi	r3,r5,65280
 40232a4:	1806d23a 	srli	r3,r3,8
 40232a8:	e3800345 	stb	r14,13(fp)
 40232ac:	d8801b17 	ldw	r2,108(sp)
 40232b0:	e3400185 	stb	r13,6(fp)
 40232b4:	e38001c3 	ldbu	r14,7(fp)
 40232b8:	e0800085 	stb	r2,2(fp)
 40232bc:	da401e17 	ldw	r9,120(sp)
 40232c0:	2908f03a 	xor	r4,r5,r4
 40232c4:	1b86f03a 	xor	r3,r3,r14
 40232c8:	e2400285 	stb	r9,10(fp)
 40232cc:	28803fec 	andhi	r2,r5,255
 40232d0:	da802017 	ldw	r10,128(sp)
 40232d4:	1004d43a 	srli	r2,r2,16
 40232d8:	e10000c5 	stb	r4,3(fp)
 40232dc:	e0c001c5 	stb	r3,7(fp)
 40232e0:	e10003c3 	ldbu	r4,15(fp)
 40232e4:	e0c002c3 	ldbu	r3,11(fp)
 40232e8:	280ad63a 	srli	r5,r5,24
 40232ec:	e2800385 	stb	r10,14(fp)
 40232f0:	10c4f03a 	xor	r2,r2,r3
 40232f4:	290af03a 	xor	r5,r5,r4
 40232f8:	e08002c5 	stb	r2,11(fp)
 40232fc:	e14003c5 	stb	r5,15(fp)
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, 0);

	for(i = 1; i < ctx->rounds; i++) {
 4023300:	d8800417 	ldw	r2,16(sp)
 4023304:	e4c00517 	ldw	r19,20(fp)
 4023308:	d8c00517 	ldw	r3,20(sp)
 402330c:	10800404 	addi	r2,r2,16
 4023310:	d8800415 	stw	r2,16(sp)
 4023314:	7bc00404 	addi	r15,r15,16
 4023318:	1cff3736 	bltu	r3,r19,4022ff8 <aes_encrypt+0x230>
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 402331c:	e0800003 	ldbu	r2,0(fp)
 4023320:	e0c00103 	ldbu	r3,4(fp)
 4023324:	e1000203 	ldbu	r4,8(fp)
 4023328:	1545883a 	add	r2,r2,r21
 402332c:	11400003 	ldbu	r5,0(r2)
 4023330:	1d47883a 	add	r3,r3,r21
 4023334:	2549883a 	add	r4,r4,r21
 4023338:	e1400005 	stb	r5,0(fp)
 402333c:	18c00003 	ldbu	r3,0(r3)
 4023340:	d8c02105 	stb	r3,132(sp)
 4023344:	e0c00105 	stb	r3,4(fp)
 4023348:	21000003 	ldbu	r4,0(r4)
 402334c:	e0800303 	ldbu	r2,12(fp)
 4023350:	e1400043 	ldbu	r5,1(fp)
 4023354:	d9002145 	stb	r4,133(sp)
 4023358:	e1000205 	stb	r4,8(fp)
 402335c:	1545883a 	add	r2,r2,r21
 4023360:	10800003 	ldbu	r2,0(r2)
 4023364:	2d4b883a 	add	r5,r5,r21
 4023368:	d8802185 	stb	r2,134(sp)
 402336c:	e0800305 	stb	r2,12(fp)
 4023370:	29400003 	ldbu	r5,0(r5)
 4023374:	e0c00143 	ldbu	r3,5(fp)
 4023378:	e1000243 	ldbu	r4,9(fp)
 402337c:	d94021c5 	stb	r5,135(sp)
 4023380:	29403fcc 	andi	r5,r5,255
 4023384:	e1400045 	stb	r5,1(fp)
 4023388:	1d47883a 	add	r3,r3,r21
 402338c:	18c00003 	ldbu	r3,0(r3)
 4023390:	2549883a 	add	r4,r4,r21
 4023394:	d8c02205 	stb	r3,136(sp)
 4023398:	e0c00145 	stb	r3,5(fp)
 402339c:	21000003 	ldbu	r4,0(r4)
 40233a0:	e0800343 	ldbu	r2,13(fp)
 40233a4:	e1400083 	ldbu	r5,2(fp)
 40233a8:	d9002245 	stb	r4,137(sp)
 40233ac:	e1000245 	stb	r4,9(fp)
 40233b0:	1545883a 	add	r2,r2,r21
 40233b4:	10800003 	ldbu	r2,0(r2)
 40233b8:	2d4b883a 	add	r5,r5,r21
		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 40233bc:	9cc9883a 	add	r4,r19,r19
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40233c0:	d8802285 	stb	r2,138(sp)
 40233c4:	e0c00183 	ldbu	r3,6(fp)
 40233c8:	e1800283 	ldbu	r6,10(fp)
 40233cc:	e0800345 	stb	r2,13(fp)
 40233d0:	2b400003 	ldbu	r13,0(r5)
 40233d4:	1d47883a 	add	r3,r3,r21
 40233d8:	354d883a 	add	r6,r6,r21
 40233dc:	e3400085 	stb	r13,2(fp)
 40233e0:	1ac00003 	ldbu	r11,0(r3)
 40233e4:	e0800383 	ldbu	r2,14(fp)
		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 40233e8:	2109883a 	add	r4,r4,r4
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40233ec:	e2c00185 	stb	r11,6(fp)
 40233f0:	33000003 	ldbu	r12,0(r6)
 40233f4:	1545883a 	add	r2,r2,r21
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40233f8:	21800044 	addi	r6,r4,1
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40233fc:	e3000285 	stb	r12,10(fp)
 4023400:	10800003 	ldbu	r2,0(r2)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023404:	21c00084 	addi	r7,r4,2
 4023408:	318d883a 	add	r6,r6,r6
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 402340c:	d88022c5 	stb	r2,139(sp)
 4023410:	e0800385 	stb	r2,14(fp)
 4023414:	e08000c3 	ldbu	r2,3(fp)
 4023418:	e0c001c3 	ldbu	r3,7(fp)
 402341c:	e14002c3 	ldbu	r5,11(fp)
 4023420:	1545883a 	add	r2,r2,r21
 4023424:	15c00003 	ldbu	r23,0(r2)
 4023428:	1d47883a 	add	r3,r3,r21
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 402342c:	e0800003 	ldbu	r2,0(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023430:	e5c000c5 	stb	r23,3(fp)
 4023434:	1d800003 	ldbu	r22,0(r3)
 4023438:	2d4b883a 	add	r5,r5,r21
 402343c:	e20003c3 	ldbu	r8,15(fp)
 4023440:	e58001c5 	stb	r22,7(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023444:	da402203 	ldbu	r9,136(sp)
 4023448:	da8021c3 	ldbu	r10,135(sp)
 402344c:	db802103 	ldbu	r14,132(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023450:	28c00003 	ldbu	r3,0(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023454:	d8800005 	stb	r2,0(sp)
 4023458:	da400105 	stb	r9,4(sp)
 402345c:	da800045 	stb	r10,1(sp)
 4023460:	dac00145 	stb	r11,5(sp)
 4023464:	db400085 	stb	r13,2(sp)
 4023468:	dd800185 	stb	r22,6(sp)
 402346c:	ddc000c5 	stb	r23,3(sp)
 4023470:	db8001c5 	stb	r14,7(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023474:	e0c002c5 	stb	r3,11(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 4023478:	db000205 	stb	r12,8(sp)
 402347c:	d8c00245 	stb	r3,9(sp)
 4023480:	d8802143 	ldbu	r2,133(sp)
 4023484:	d8c02243 	ldbu	r3,137(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023488:	4551883a 	add	r8,r8,r21
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 402348c:	d8800285 	stb	r2,10(sp)
 4023490:	d88022c3 	ldbu	r2,139(sp)
 4023494:	d8c002c5 	stb	r3,11(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 4023498:	41400003 	ldbu	r5,0(r8)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 402349c:	da402183 	ldbu	r9,134(sp)
 40234a0:	db802283 	ldbu	r14,138(sp)
 40234a4:	d88003c5 	stb	r2,15(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 40234a8:	da800117 	ldw	r10,4(sp)
 40234ac:	da000217 	ldw	r8,8(sp)
 40234b0:	d8800017 	ldw	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
 40234b4:	da400345 	stb	r9,13(sp)
 40234b8:	db800385 	stb	r14,14(sp)
 40234bc:	d9400305 	stb	r5,12(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40234c0:	20c000c4 	addi	r3,r4,3
 40234c4:	39cf883a 	add	r7,r7,r7
 40234c8:	2109883a 	add	r4,r4,r4
 40234cc:	318d883a 	add	r6,r6,r6
		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 40234d0:	e0800015 	stw	r2,0(fp)
 40234d4:	e2800115 	stw	r10,4(fp)
 40234d8:	e2000215 	stw	r8,8(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_sbox[ctx->state[x][y]];
 40234dc:	e14003c5 	stb	r5,15(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40234e0:	370d883a 	add	r6,r6,fp
 40234e4:	2109883a 	add	r4,r4,r4
 40234e8:	39cf883a 	add	r7,r7,r7
 40234ec:	32000617 	ldw	r8,24(r6)
		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 40234f0:	d8800317 	ldw	r2,12(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40234f4:	2709883a 	add	r4,r4,fp
 40234f8:	3f0f883a 	add	r7,r7,fp
 40234fc:	18c7883a 	add	r3,r3,r3
 4023500:	3ac00617 	ldw	r11,24(r7)
 4023504:	21400617 	ldw	r5,24(r4)
 4023508:	18c7883a 	add	r3,r3,r3
 402350c:	1f07883a 	add	r3,r3,fp
		x = i & 0x03;
		y = i >> 2;
		nstate[x][y] = ctx->state[x][(y+x) & 0x03];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023510:	e0800315 	stw	r2,12(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023514:	19800617 	ldw	r6,24(r3)
 4023518:	40bfc00c 	andi	r2,r8,65280
 402351c:	40c03fec 	andhi	r3,r8,255
 4023520:	2812d63a 	srli	r9,r5,24
 4023524:	4014d63a 	srli	r10,r8,24
 4023528:	581cd63a 	srli	r14,r11,24
 402352c:	1004d23a 	srli	r2,r2,8
 4023530:	1806d43a 	srli	r3,r3,16
 4023534:	da402315 	stw	r9,140(sp)
 4023538:	d8802415 	stw	r2,144(sp)
 402353c:	d8c02515 	stw	r3,148(sp)
 4023540:	da802615 	stw	r10,152(sp)
 4023544:	db802715 	stw	r14,156(sp)
 4023548:	29ffc00c 	andi	r7,r5,65280
 402354c:	e2400003 	ldbu	r9,0(fp)
 4023550:	e2800103 	ldbu	r10,4(fp)
 4023554:	380ed23a 	srli	r7,r7,8
 4023558:	29003fec 	andhi	r4,r5,255
 402355c:	29403fcc 	andi	r5,r5,255
 4023560:	2a4af03a 	xor	r5,r5,r9
 4023564:	e3800203 	ldbu	r14,8(fp)
 4023568:	da402317 	ldw	r9,140(sp)
 402356c:	3a8ef03a 	xor	r7,r7,r10
 4023570:	2008d43a 	srli	r4,r4,16
 4023574:	e2800303 	ldbu	r10,12(fp)
 4023578:	5b3fc00c 	andi	r12,r11,65280
 402357c:	2388f03a 	xor	r4,r4,r14
 4023580:	4aaef03a 	xor	r23,r9,r10
 4023584:	db802417 	ldw	r14,144(sp)
 4023588:	e2400143 	ldbu	r9,5(fp)
 402358c:	da802517 	ldw	r10,148(sp)
 4023590:	6018d23a 	srli	r12,r12,8
 4023594:	7268f03a 	xor	r20,r14,r9
 4023598:	e3800243 	ldbu	r14,9(fp)
 402359c:	da402617 	ldw	r9,152(sp)
 40235a0:	5b403fec 	andhi	r13,r11,255
 40235a4:	53aaf03a 	xor	r21,r10,r14
 40235a8:	e2800343 	ldbu	r10,13(fp)
 40235ac:	e3800183 	ldbu	r14,6(fp)
 40235b0:	681ad43a 	srli	r13,r13,16
 40235b4:	4aacf03a 	xor	r22,r9,r10
 40235b8:	6398f03a 	xor	r12,r12,r14
 40235bc:	e2400283 	ldbu	r9,10(fp)
 40235c0:	da802717 	ldw	r10,156(sp)
 40235c4:	e3800383 	ldbu	r14,14(fp)
 40235c8:	e08000c3 	ldbu	r2,3(fp)
 40235cc:	30ffc00c 	andi	r3,r6,65280
 40235d0:	53a2f03a 	xor	r17,r10,r14
 40235d4:	6a5af03a 	xor	r13,r13,r9
 40235d8:	e2800083 	ldbu	r10,2(fp)
 40235dc:	e2400043 	ldbu	r9,1(fp)
 40235e0:	1806d23a 	srli	r3,r3,8
 40235e4:	e1c00105 	stb	r7,4(fp)
 40235e8:	e38001c3 	ldbu	r14,7(fp)
 40235ec:	3084f03a 	xor	r2,r6,r2
 40235f0:	e08000c5 	stb	r2,3(fp)
 40235f4:	1b86f03a 	xor	r3,r3,r14
 40235f8:	30803fec 	andhi	r2,r6,255
 40235fc:	e1000205 	stb	r4,8(fp)
 4023600:	e0c001c5 	stb	r3,7(fp)
 4023604:	e10003c3 	ldbu	r4,15(fp)
 4023608:	e0c002c3 	ldbu	r3,11(fp)
 402360c:	1004d43a 	srli	r2,r2,16
 4023610:	300cd63a 	srli	r6,r6,24
 4023614:	4250f03a 	xor	r8,r8,r9
 4023618:	10c4f03a 	xor	r2,r2,r3
 402361c:	310cf03a 	xor	r6,r6,r4
 4023620:	5a96f03a 	xor	r11,r11,r10
 4023624:	e5c00305 	stb	r23,12(fp)
 4023628:	e2000045 	stb	r8,1(fp)
 402362c:	e5000145 	stb	r20,5(fp)
 4023630:	e5400245 	stb	r21,9(fp)
 4023634:	e5800345 	stb	r22,13(fp)
 4023638:	e2c00085 	stb	r11,2(fp)
 402363c:	e3000185 	stb	r12,6(fp)
 4023640:	e3400285 	stb	r13,10(fp)
 4023644:	e4400385 	stb	r17,14(fp)
 4023648:	e1400005 	stb	r5,0(fp)
 402364c:	e08002c5 	stb	r2,11(fp)
 4023650:	e18003c5 	stb	r6,15(fp)
	aes_shiftrows(ctx);
	aes_addroundkey(ctx, ctx->rounds);

	// copy state to output
	for(i = 0; i < 16; i++)
		output[i] = ctx->state[i & 0x03][i >> 2];
 4023654:	d8800617 	ldw	r2,24(sp)
 4023658:	11400005 	stb	r5,0(r2)
 402365c:	e0800103 	ldbu	r2,4(fp)
 4023660:	d8c00617 	ldw	r3,24(sp)
 4023664:	18800045 	stb	r2,1(r3)
 4023668:	d9000617 	ldw	r4,24(sp)
 402366c:	e0c00203 	ldbu	r3,8(fp)
 4023670:	20c00085 	stb	r3,2(r4)
 4023674:	e0800303 	ldbu	r2,12(fp)
 4023678:	208000c5 	stb	r2,3(r4)
 402367c:	e0c00043 	ldbu	r3,1(fp)
 4023680:	20c00105 	stb	r3,4(r4)
 4023684:	e0800143 	ldbu	r2,5(fp)
 4023688:	20800145 	stb	r2,5(r4)
 402368c:	e0c00243 	ldbu	r3,9(fp)
 4023690:	20c00185 	stb	r3,6(r4)
 4023694:	e0800343 	ldbu	r2,13(fp)
 4023698:	208001c5 	stb	r2,7(r4)
 402369c:	e0c00083 	ldbu	r3,2(fp)
 40236a0:	20c00205 	stb	r3,8(r4)
 40236a4:	e0800183 	ldbu	r2,6(fp)
 40236a8:	20800245 	stb	r2,9(r4)
 40236ac:	e0c00283 	ldbu	r3,10(fp)
 40236b0:	20c00285 	stb	r3,10(r4)
 40236b4:	e0800383 	ldbu	r2,14(fp)
 40236b8:	208002c5 	stb	r2,11(r4)
 40236bc:	e0c000c3 	ldbu	r3,3(fp)
 40236c0:	20c00305 	stb	r3,12(r4)
 40236c4:	e08001c3 	ldbu	r2,7(fp)
 40236c8:	20800345 	stb	r2,13(r4)
 40236cc:	e0c002c3 	ldbu	r3,11(fp)
 40236d0:	20c00385 	stb	r3,14(r4)
 40236d4:	e08003c3 	ldbu	r2,15(fp)
 40236d8:	208003c5 	stb	r2,15(r4)
}
 40236dc:	dfc03217 	ldw	ra,200(sp)
 40236e0:	df003117 	ldw	fp,196(sp)
 40236e4:	ddc03017 	ldw	r23,192(sp)
 40236e8:	dd802f17 	ldw	r22,188(sp)
 40236ec:	dd402e17 	ldw	r21,184(sp)
 40236f0:	dd002d17 	ldw	r20,180(sp)
 40236f4:	dcc02c17 	ldw	r19,176(sp)
 40236f8:	dc802b17 	ldw	r18,172(sp)
 40236fc:	dc402a17 	ldw	r17,168(sp)
 4023700:	dc002917 	ldw	r16,164(sp)
 4023704:	dec03304 	addi	sp,sp,204
 4023708:	f800283a 	ret
 402370c:	054100f4 	movhi	r21,1027
 4023710:	ad44b904 	addi	r21,r21,4836
 4023714:	003f0106 	br	402331c <aes_encrypt+0x554>

04023718 <aes_decrypt>:

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_decrypt(aes_ctx_t *ctx, unsigned char input[16], unsigned char output[16])
{
 4023718:	deffbc04 	addi	sp,sp,-272
 402371c:	df004215 	stw	fp,264(sp)
 4023720:	ddc04115 	stw	r23,260(sp)
 4023724:	dc403b15 	stw	r17,236(sp)
 4023728:	dc003a15 	stw	r16,232(sp)
 402372c:	dfc04315 	stw	ra,268(sp)
 4023730:	dd804015 	stw	r22,256(sp)
 4023734:	dd403f15 	stw	r21,252(sp)
 4023738:	dd003e15 	stw	r20,248(sp)
 402373c:	dcc03d15 	stw	r19,244(sp)
 4023740:	dc803c15 	stw	r18,240(sp)
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023744:	29c00003 	ldbu	r7,0(r5)
 4023748:	23800517 	ldw	r14,20(r4)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_decrypt(aes_ctx_t *ctx, unsigned char input[16], unsigned char output[16])
{
 402374c:	2039883a 	mov	fp,r4
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023750:	21c00005 	stb	r7,0(r4)
 4023754:	2ac00043 	ldbu	r11,1(r5)
 4023758:	7385883a 	add	r2,r14,r14
 402375c:	1085883a 	add	r2,r2,r2
 4023760:	d8801215 	stw	r2,72(sp)
 4023764:	22c00105 	stb	r11,4(r4)
 4023768:	2a800083 	ldbu	r10,2(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 402376c:	d8c01217 	ldw	r3,72(sp)
	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023770:	73bfffc4 	addi	r14,r14,-1
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023774:	22800205 	stb	r10,8(r4)
 4023778:	2a4000c3 	ldbu	r9,3(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 402377c:	18c5883a 	add	r2,r3,r3
 4023780:	1085883a 	add	r2,r2,r2
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023784:	22400305 	stb	r9,12(r4)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023788:	1105883a 	add	r2,r2,r4
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 402378c:	29000103 	ldbu	r4,4(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023790:	da001217 	ldw	r8,72(sp)
 4023794:	13000617 	ldw	r12,24(r2)
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023798:	d9000605 	stb	r4,24(sp)
 402379c:	dc400603 	ldbu	r17,24(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237a0:	40c00044 	addi	r3,r8,1
 40237a4:	41000084 	addi	r4,r8,2
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 40237a8:	e4400045 	stb	r17,1(fp)
 40237ac:	28800143 	ldbu	r2,5(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237b0:	18c7883a 	add	r3,r3,r3
 40237b4:	18c7883a 	add	r3,r3,r3
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 40237b8:	d8800705 	stb	r2,28(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237bc:	408000c4 	addi	r2,r8,3
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 40237c0:	da000703 	ldbu	r8,28(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237c4:	1f07883a 	add	r3,r3,fp
 40237c8:	2109883a 	add	r4,r4,r4
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 40237cc:	e2000145 	stb	r8,5(fp)
 40237d0:	2c400183 	ldbu	r17,6(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237d4:	61cef03a 	xor	r7,r12,r7
 40237d8:	64003fec 	andhi	r16,r12,255
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 40237dc:	dc400805 	stb	r17,32(sp)
 40237e0:	e4400245 	stb	r17,9(fp)
 40237e4:	2a0001c3 	ldbu	r8,7(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237e8:	1085883a 	add	r2,r2,r2
 40237ec:	2109883a 	add	r4,r4,r4
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 40237f0:	da000905 	stb	r8,36(sp)
 40237f4:	e2000345 	stb	r8,13(fp)
 40237f8:	2c400203 	ldbu	r17,8(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 40237fc:	2709883a 	add	r4,r4,fp
 4023800:	1085883a 	add	r2,r2,r2
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023804:	dc400a05 	stb	r17,40(sp)
 4023808:	e4400085 	stb	r17,2(fp)
 402380c:	2a000243 	ldbu	r8,9(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023810:	1705883a 	add	r2,r2,fp
 4023814:	8020d43a 	srli	r16,r16,16
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023818:	da000b05 	stb	r8,44(sp)
 402381c:	e2000185 	stb	r8,6(fp)
 4023820:	2c400283 	ldbu	r17,10(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023824:	623fc00c 	andi	r8,r12,65280
 4023828:	401ad23a 	srli	r13,r8,8
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 402382c:	dc400c05 	stb	r17,48(sp)
 4023830:	e4400285 	stb	r17,10(fp)
 4023834:	2c4002c3 	ldbu	r17,11(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023838:	6adaf03a 	xor	r13,r13,r11
 402383c:	6018d63a 	srli	r12,r12,24
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023840:	dc400d05 	stb	r17,52(sp)
 4023844:	e4400385 	stb	r17,14(fp)
 4023848:	2a000303 	ldbu	r8,12(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 402384c:	6258f03a 	xor	r12,r12,r9
 4023850:	12400617 	ldw	r9,24(r2)
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023854:	da000e05 	stb	r8,56(sp)
 4023858:	e20000c5 	stb	r8,3(fp)
 402385c:	2c400343 	ldbu	r17,13(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023860:	db401415 	stw	r13,80(sp)
 4023864:	82a0f03a 	xor	r16,r16,r10
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023868:	dc400f05 	stb	r17,60(sp)
 402386c:	e44001c5 	stb	r17,7(fp)
 4023870:	2a000383 	ldbu	r8,14(r5)

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023874:	db800415 	stw	r14,16(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023878:	4abfc00c 	andi	r10,r9,65280
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 402387c:	da001005 	stb	r8,64(sp)
 4023880:	e20002c5 	stb	r8,11(fp)
 4023884:	294003c3 	ldbu	r5,15(r5)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023888:	5014d23a 	srli	r10,r10,8
 402388c:	4ac03fec 	andhi	r11,r9,255
{
	int i, j;

	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];
 4023890:	d9401105 	stb	r5,68(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023894:	19400617 	ldw	r5,24(r3)
 4023898:	e1c00005 	stb	r7,0(fp)
 402389c:	21c00617 	ldw	r7,24(r4)
 40238a0:	28ffc00c 	andi	r3,r5,65280
 40238a4:	28803fec 	andhi	r2,r5,255
 40238a8:	dc400703 	ldbu	r17,28(sp)
 40238ac:	da000803 	ldbu	r8,32(sp)
 40238b0:	1806d23a 	srli	r3,r3,8
 40238b4:	1004d43a 	srli	r2,r2,16
 40238b8:	3b803fec 	andhi	r14,r7,255
 40238bc:	393fc00c 	andi	r4,r7,65280
 40238c0:	701cd43a 	srli	r14,r14,16
 40238c4:	281ad63a 	srli	r13,r5,24
 40238c8:	1c46f03a 	xor	r3,r3,r17
 40238cc:	1204f03a 	xor	r2,r2,r8
 40238d0:	dc400903 	ldbu	r17,36(sp)
 40238d4:	da000b03 	ldbu	r8,44(sp)
 40238d8:	2008d23a 	srli	r4,r4,8
 40238dc:	db801515 	stw	r14,84(sp)
 40238e0:	6c5af03a 	xor	r13,r13,r17
 40238e4:	2208f03a 	xor	r4,r4,r8
 40238e8:	dc401517 	ldw	r17,84(sp)
 40238ec:	da000c03 	ldbu	r8,48(sp)
 40238f0:	381cd63a 	srli	r14,r7,24
 40238f4:	5816d43a 	srli	r11,r11,16
 40238f8:	8a2ef03a 	xor	r23,r17,r8
 40238fc:	dc400d03 	ldbu	r17,52(sp)
 4023900:	da000f03 	ldbu	r8,60(sp)
 4023904:	481ed63a 	srli	r15,r9,24
 4023908:	745cf03a 	xor	r14,r14,r17
 402390c:	dc401003 	ldbu	r17,64(sp)
 4023910:	5214f03a 	xor	r10,r10,r8
 4023914:	da001103 	ldbu	r8,68(sp)
 4023918:	5c56f03a 	xor	r11,r11,r17
 402391c:	dc400603 	ldbu	r17,24(sp)
 4023920:	7a1ef03a 	xor	r15,r15,r8
 4023924:	da000a03 	ldbu	r8,40(sp)
 4023928:	2c4af03a 	xor	r5,r5,r17
 402392c:	dc400e03 	ldbu	r17,56(sp)
 4023930:	3a0ef03a 	xor	r7,r7,r8
 4023934:	da001417 	ldw	r8,80(sp)
 4023938:	4c52f03a 	xor	r9,r9,r17
 402393c:	e2000105 	stb	r8,4(fp)
 4023940:	e4000205 	stb	r16,8(fp)
 4023944:	e3000305 	stb	r12,12(fp)
 4023948:	e1400045 	stb	r5,1(fp)
 402394c:	e0c00145 	stb	r3,5(fp)
 4023950:	e0800245 	stb	r2,9(fp)
 4023954:	e3400345 	stb	r13,13(fp)
 4023958:	e1c00085 	stb	r7,2(fp)
 402395c:	e1000185 	stb	r4,6(fp)
 4023960:	e5c00285 	stb	r23,10(fp)
 4023964:	e3800385 	stb	r14,14(fp)
 4023968:	e24000c5 	stb	r9,3(fp)
 402396c:	e28001c5 	stb	r10,7(fp)
 4023970:	e2c002c5 	stb	r11,11(fp)
 4023974:	e3c003c5 	stb	r15,15(fp)
	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023978:	dc400417 	ldw	r17,16(sp)

	memcpy(ctx->state, nstate, sizeof(ctx->state));
}

void aes_decrypt(aes_ctx_t *ctx, unsigned char input[16], unsigned char output[16])
{
 402397c:	d9800515 	stw	r6,20(sp)
	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023980:	0440e10e 	bge	zero,r17,4023d08 <aes_decrypt+0x5f0>
 4023984:	d8c01217 	ldw	r3,72(sp)
 4023988:	18bfff04 	addi	r2,r3,-4
 402398c:	1085883a 	add	r2,r2,r2
 4023990:	1085883a 	add	r2,r2,r2
 4023994:	1705883a 	add	r2,r2,fp
 4023998:	15c00904 	addi	r23,r2,36
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 402399c:	e0800003 	ldbu	r2,0(fp)
 40239a0:	e0c00043 	ldbu	r3,1(fp)
 40239a4:	e1000083 	ldbu	r4,2(fp)
 40239a8:	e14000c3 	ldbu	r5,3(fp)
 40239ac:	d8800005 	stb	r2,0(sp)
 40239b0:	d8c00045 	stb	r3,1(sp)
 40239b4:	d9000085 	stb	r4,2(sp)
 40239b8:	d94000c5 	stb	r5,3(sp)
 40239bc:	e0800103 	ldbu	r2,4(fp)
 40239c0:	e0c00203 	ldbu	r3,8(fp)
 40239c4:	e1000303 	ldbu	r4,12(fp)
 40239c8:	e1400143 	ldbu	r5,5(fp)
 40239cc:	e1800243 	ldbu	r6,9(fp)
 40239d0:	e1c00343 	ldbu	r7,13(fp)
 40239d4:	e2000183 	ldbu	r8,6(fp)
 40239d8:	e2400283 	ldbu	r9,10(fp)
 40239dc:	e2800383 	ldbu	r10,14(fp)
 40239e0:	e2c001c3 	ldbu	r11,7(fp)
 40239e4:	e30002c3 	ldbu	r12,11(fp)
 40239e8:	e34003c3 	ldbu	r13,15(fp)
 40239ec:	d8800145 	stb	r2,5(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 40239f0:	d8800017 	ldw	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 40239f4:	d8c00285 	stb	r3,10(sp)
 40239f8:	d90003c5 	stb	r4,15(sp)
 40239fc:	d9400185 	stb	r5,6(sp)
 4023a00:	d98002c5 	stb	r6,11(sp)
 4023a04:	d9c00305 	stb	r7,12(sp)
 4023a08:	da0001c5 	stb	r8,7(sp)
 4023a0c:	da400205 	stb	r9,8(sp)
 4023a10:	da800345 	stb	r10,13(sp)
 4023a14:	dac00105 	stb	r11,4(sp)
 4023a18:	db000245 	stb	r12,9(sp)
 4023a1c:	db400385 	stb	r13,14(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023a20:	e0800015 	stw	r2,0(fp)
 4023a24:	d9000217 	ldw	r4,8(sp)
 4023a28:	d9400317 	ldw	r5,12(sp)
 4023a2c:	d8800117 	ldw	r2,4(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023a30:	e0c00003 	ldbu	r3,0(fp)
 4023a34:	044100f4 	movhi	r17,1027
 4023a38:	8c447904 	addi	r17,r17,4580
		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023a3c:	e0800115 	stw	r2,4(fp)
 4023a40:	e1000215 	stw	r4,8(fp)
 4023a44:	e1400315 	stw	r5,12(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023a48:	1c47883a 	add	r3,r3,r17
 4023a4c:	18c00003 	ldbu	r3,0(r3)
 4023a50:	d8c01705 	stb	r3,92(sp)
 4023a54:	d9001703 	ldbu	r4,92(sp)
 4023a58:	e0800103 	ldbu	r2,4(fp)
 4023a5c:	e0c00203 	ldbu	r3,8(fp)
 4023a60:	e1000005 	stb	r4,0(fp)
 4023a64:	1445883a 	add	r2,r2,r17
 4023a68:	10800003 	ldbu	r2,0(r2)
 4023a6c:	1c47883a 	add	r3,r3,r17
 4023a70:	010100f4 	movhi	r4,1027
 4023a74:	21047904 	addi	r4,r4,4580
 4023a78:	d8801805 	stb	r2,96(sp)
 4023a7c:	d9401803 	ldbu	r5,96(sp)
 4023a80:	e0800303 	ldbu	r2,12(fp)
 4023a84:	e1400105 	stb	r5,4(fp)
 4023a88:	18c00003 	ldbu	r3,0(r3)
 4023a8c:	1445883a 	add	r2,r2,r17
 4023a90:	d8c01905 	stb	r3,100(sp)
 4023a94:	d9801903 	ldbu	r6,100(sp)
 4023a98:	e0c00043 	ldbu	r3,1(fp)
 4023a9c:	e1800205 	stb	r6,8(fp)
 4023aa0:	12000003 	ldbu	r8,0(r2)
 4023aa4:	1c47883a 	add	r3,r3,r17
 4023aa8:	e0800143 	ldbu	r2,5(fp)
 4023aac:	e2000305 	stb	r8,12(fp)
 4023ab0:	18c00003 	ldbu	r3,0(r3)
 4023ab4:	1445883a 	add	r2,r2,r17
 4023ab8:	018100f4 	movhi	r6,1027
 4023abc:	31847904 	addi	r6,r6,4580
 4023ac0:	d8c01a05 	stb	r3,104(sp)
 4023ac4:	d9c01a03 	ldbu	r7,104(sp)
 4023ac8:	e0c00243 	ldbu	r3,9(fp)
 4023acc:	e1c00045 	stb	r7,1(fp)
 4023ad0:	14400003 	ldbu	r17,0(r2)
 4023ad4:	008100f4 	movhi	r2,1027
 4023ad8:	10847904 	addi	r2,r2,4580
 4023adc:	1887883a 	add	r3,r3,r2
 4023ae0:	e0800343 	ldbu	r2,13(fp)
 4023ae4:	e4400145 	stb	r17,5(fp)
 4023ae8:	1c800003 	ldbu	r18,0(r3)
 4023aec:	00c100f4 	movhi	r3,1027
 4023af0:	18c47904 	addi	r3,r3,4580
 4023af4:	10c5883a 	add	r2,r2,r3
 4023af8:	e4800245 	stb	r18,9(fp)
 4023afc:	15000003 	ldbu	r20,0(r2)
 4023b00:	e0c00083 	ldbu	r3,2(fp)
 4023b04:	e0800183 	ldbu	r2,6(fp)
 4023b08:	e5000345 	stb	r20,13(fp)
	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023b0c:	d9400417 	ldw	r5,16(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023b10:	1907883a 	add	r3,r3,r4
 4023b14:	1cc00003 	ldbu	r19,0(r3)
	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023b18:	297fffc4 	addi	r5,r5,-1
 4023b1c:	d9400415 	stw	r5,16(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023b20:	e4c00085 	stb	r19,2(fp)
 4023b24:	1105883a 	add	r2,r2,r4
 4023b28:	17c00003 	ldbu	ra,0(r2)
 4023b2c:	e0800283 	ldbu	r2,10(fp)
 4023b30:	e0c00383 	ldbu	r3,14(fp)
 4023b34:	e7c00185 	stb	ra,6(fp)
 4023b38:	1185883a 	add	r2,r2,r6
 4023b3c:	10800003 	ldbu	r2,0(r2)
 4023b40:	e14000c3 	ldbu	r5,3(fp)
 4023b44:	1987883a 	add	r3,r3,r6
 4023b48:	d8801b05 	stb	r2,108(sp)
 4023b4c:	e0800285 	stb	r2,10(fp)
 4023b50:	18c00003 	ldbu	r3,0(r3)
 4023b54:	298b883a 	add	r5,r5,r6
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023b58:	bafffe17 	ldw	r11,-8(r23)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023b5c:	d8c01c05 	stb	r3,112(sp)
 4023b60:	d9c01c03 	ldbu	r7,112(sp)
 4023b64:	e08001c3 	ldbu	r2,7(fp)
 4023b68:	e0c002c3 	ldbu	r3,11(fp)
 4023b6c:	e1c00385 	stb	r7,14(fp)
 4023b70:	2d400003 	ldbu	r21,0(r5)
 4023b74:	1185883a 	add	r2,r2,r6
 4023b78:	1987883a 	add	r3,r3,r6
 4023b7c:	e54000c5 	stb	r21,3(fp)
 4023b80:	15800003 	ldbu	r22,0(r2)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023b84:	b9bffd17 	ldw	r6,-12(r23)
 4023b88:	bbbfff17 	ldw	r14,-4(r23)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023b8c:	e58001c5 	stb	r22,7(fp)
 4023b90:	18c00003 	ldbu	r3,0(r3)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023b94:	31ffc00c 	andi	r7,r6,65280
 4023b98:	380ed23a 	srli	r7,r7,8
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023b9c:	d8c01d05 	stb	r3,116(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023ba0:	30c03fec 	andhi	r3,r6,255
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023ba4:	e08003c3 	ldbu	r2,15(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023ba8:	d8c01f15 	stw	r3,124(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023bac:	d9401d03 	ldbu	r5,116(sp)
 4023bb0:	00c100f4 	movhi	r3,1027
 4023bb4:	18c47904 	addi	r3,r3,4580
 4023bb8:	10c5883a 	add	r2,r2,r3
 4023bbc:	e14002c5 	stb	r5,11(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023bc0:	d9401f17 	ldw	r5,124(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023bc4:	d8803815 	stw	r2,224(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023bc8:	7004d63a 	srli	r2,r14,24
 4023bcc:	280ad43a 	srli	r5,r5,16
 4023bd0:	5a7fc00c 	andi	r9,r11,65280
 4023bd4:	d8802215 	stw	r2,136(sp)
 4023bd8:	d9402015 	stw	r5,128(sp)
 4023bdc:	b9400017 	ldw	r5,0(r23)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023be0:	d8803817 	ldw	r2,224(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023be4:	301ed63a 	srli	r15,r6,24
 4023be8:	28ffc00c 	andi	r3,r5,65280
 4023bec:	1806d23a 	srli	r3,r3,8
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023bf0:	10800003 	ldbu	r2,0(r2)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023bf4:	4812d23a 	srli	r9,r9,8
 4023bf8:	d8c03915 	stw	r3,228(sp)
 4023bfc:	b8c00017 	ldw	r3,0(r23)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023c00:	d8801e05 	stb	r2,120(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023c04:	d8801803 	ldbu	r2,96(sp)
 4023c08:	1806d63a 	srli	r3,r3,24
 4023c0c:	7a1ef03a 	xor	r15,r15,r8
 4023c10:	388ef03a 	xor	r7,r7,r2
 4023c14:	d8c03815 	stw	r3,224(sp)
 4023c18:	d8801903 	ldbu	r2,100(sp)
 4023c1c:	d8c02017 	ldw	r3,128(sp)
 4023c20:	da002217 	ldw	r8,136(sp)
 4023c24:	4c52f03a 	xor	r9,r9,r17
 4023c28:	dc401c03 	ldbu	r17,112(sp)
 4023c2c:	1886f03a 	xor	r3,r3,r2
 4023c30:	73403fec 	andhi	r13,r14,255
 4023c34:	d8801703 	ldbu	r2,92(sp)
 4023c38:	d8c02115 	stw	r3,132(sp)
 4023c3c:	681ad43a 	srli	r13,r13,16
 4023c40:	d8c01b03 	ldbu	r3,108(sp)
 4023c44:	4450f03a 	xor	r8,r8,r17
 4023c48:	da002315 	stw	r8,140(sp)
 4023c4c:	308cf03a 	xor	r6,r6,r2
 4023c50:	5a803fec 	andhi	r10,r11,255
 4023c54:	68daf03a 	xor	r13,r13,r3
 4023c58:	733fc00c 	andi	r12,r14,65280
 4023c5c:	d8c01a03 	ldbu	r3,104(sp)
 4023c60:	5820d63a 	srli	r16,r11,24
 4023c64:	e1c00105 	stb	r7,4(fp)
 4023c68:	e1800005 	stb	r6,0(fp)
 4023c6c:	5014d43a 	srli	r10,r10,16
 4023c70:	d9802117 	ldw	r6,132(sp)
 4023c74:	6018d23a 	srli	r12,r12,8
 4023c78:	58d6f03a 	xor	r11,r11,r3
 4023c7c:	5494f03a 	xor	r10,r10,r18
 4023c80:	74dcf03a 	xor	r14,r14,r19
 4023c84:	8520f03a 	xor	r16,r16,r20
 4023c88:	67d8f03a 	xor	r12,r12,ra
 4023c8c:	e1800205 	stb	r6,8(fp)
 4023c90:	e3c00305 	stb	r15,12(fp)
 4023c94:	e2c00045 	stb	r11,1(fp)
 4023c98:	e2400145 	stb	r9,5(fp)
 4023c9c:	e2800245 	stb	r10,9(fp)
 4023ca0:	e3800085 	stb	r14,2(fp)
 4023ca4:	e4000345 	stb	r16,13(fp)
 4023ca8:	e3000185 	stb	r12,6(fp)
 4023cac:	e3400285 	stb	r13,10(fp)
 4023cb0:	e2000385 	stb	r8,14(fp)
 4023cb4:	d9c03917 	ldw	r7,228(sp)
 4023cb8:	29403fec 	andhi	r5,r5,255
 4023cbc:	da001d03 	ldbu	r8,116(sp)
 4023cc0:	3d86f03a 	xor	r3,r7,r22
 4023cc4:	b9c00017 	ldw	r7,0(r23)
 4023cc8:	dc403817 	ldw	r17,224(sp)
 4023ccc:	d9801e03 	ldbu	r6,120(sp)
 4023cd0:	280ad43a 	srli	r5,r5,16
 4023cd4:	3d6af03a 	xor	r21,r7,r21
 4023cd8:	dd402415 	stw	r21,144(sp)
 4023cdc:	2a0af03a 	xor	r5,r5,r8
 4023ce0:	8984f03a 	xor	r2,r17,r6
	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
		aes_invshiftrows(ctx);
		aes_invsubbytes(ctx);
		aes_addroundkey(ctx, i);
		aes_invmixcolumns(ctx);
 4023ce4:	e009883a 	mov	r4,fp
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023ce8:	e54000c5 	stb	r21,3(fp)
 4023cec:	e0c001c5 	stb	r3,7(fp)
 4023cf0:	e14002c5 	stb	r5,11(fp)
 4023cf4:	e08003c5 	stb	r2,15(fp)
	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
		aes_invshiftrows(ctx);
		aes_invsubbytes(ctx);
		aes_addroundkey(ctx, i);
		aes_invmixcolumns(ctx);
 4023cf8:	402135c0 	call	402135c <aes_invmixcolumns>
	// copy input to state
	for(i = 0; i < 16; i++)
		ctx->state[i & 0x03][i >> 2] = input[i];

	aes_addroundkey(ctx, ctx->rounds);
	for(i = ctx->rounds-1; i >= 1; i--) {
 4023cfc:	da000417 	ldw	r8,16(sp)
 4023d00:	bdfffc04 	addi	r23,r23,-16
 4023d04:	023f2516 	blt	zero,r8,402399c <aes_decrypt+0x284>
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 4023d08:	e0800003 	ldbu	r2,0(fp)
 4023d0c:	e0c00043 	ldbu	r3,1(fp)
 4023d10:	e1000083 	ldbu	r4,2(fp)
 4023d14:	e14000c3 	ldbu	r5,3(fp)
 4023d18:	d8800005 	stb	r2,0(sp)
 4023d1c:	d8c00045 	stb	r3,1(sp)
 4023d20:	d9000085 	stb	r4,2(sp)
 4023d24:	d94000c5 	stb	r5,3(sp)
 4023d28:	e0800103 	ldbu	r2,4(fp)
 4023d2c:	e0c00203 	ldbu	r3,8(fp)
 4023d30:	e1000303 	ldbu	r4,12(fp)
 4023d34:	e1400143 	ldbu	r5,5(fp)
 4023d38:	e1800243 	ldbu	r6,9(fp)
 4023d3c:	e1c00343 	ldbu	r7,13(fp)
 4023d40:	e3800183 	ldbu	r14,6(fp)
 4023d44:	e2400283 	ldbu	r9,10(fp)
 4023d48:	e2800383 	ldbu	r10,14(fp)
 4023d4c:	e2c001c3 	ldbu	r11,7(fp)
 4023d50:	e30002c3 	ldbu	r12,11(fp)
 4023d54:	e34003c3 	ldbu	r13,15(fp)
 4023d58:	d8800145 	stb	r2,5(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023d5c:	d8800017 	ldw	r2,0(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
 4023d60:	d8c00285 	stb	r3,10(sp)
 4023d64:	d90003c5 	stb	r4,15(sp)
 4023d68:	d9400185 	stb	r5,6(sp)
 4023d6c:	d98002c5 	stb	r6,11(sp)
 4023d70:	d9c00305 	stb	r7,12(sp)
 4023d74:	db8001c5 	stb	r14,7(sp)
 4023d78:	da400205 	stb	r9,8(sp)
 4023d7c:	da800345 	stb	r10,13(sp)
 4023d80:	dac00105 	stb	r11,4(sp)
 4023d84:	db000245 	stb	r12,9(sp)
 4023d88:	db400385 	stb	r13,14(sp)
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023d8c:	e0800015 	stw	r2,0(fp)
 4023d90:	d9000217 	ldw	r4,8(sp)
 4023d94:	d9400317 	ldw	r5,12(sp)
 4023d98:	d8800117 	ldw	r2,4(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023d9c:	e0c00003 	ldbu	r3,0(fp)
 4023da0:	044100f4 	movhi	r17,1027
 4023da4:	8c447904 	addi	r17,r17,4580
		x = i & 0x03;
		y = i >> 2;
		nstate[x][(y+x) & 0x03] = ctx->state[x][y];
	}

	memcpy(ctx->state, nstate, sizeof(ctx->state));
 4023da8:	e0800115 	stw	r2,4(fp)
 4023dac:	e1000215 	stw	r4,8(fp)
 4023db0:	e1400315 	stw	r5,12(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023db4:	1c47883a 	add	r3,r3,r17
 4023db8:	18c00003 	ldbu	r3,0(r3)
 4023dbc:	d8c02505 	stb	r3,148(sp)
 4023dc0:	e0800103 	ldbu	r2,4(fp)
 4023dc4:	d9002503 	ldbu	r4,148(sp)
 4023dc8:	e0c00203 	ldbu	r3,8(fp)
 4023dcc:	1445883a 	add	r2,r2,r17
 4023dd0:	e1000005 	stb	r4,0(fp)
 4023dd4:	10800003 	ldbu	r2,0(r2)
 4023dd8:	1c47883a 	add	r3,r3,r17
 4023ddc:	d8802605 	stb	r2,152(sp)
 4023de0:	d9402603 	ldbu	r5,152(sp)
 4023de4:	e0800303 	ldbu	r2,12(fp)
 4023de8:	e1400105 	stb	r5,4(fp)
 4023dec:	18c00003 	ldbu	r3,0(r3)
 4023df0:	1445883a 	add	r2,r2,r17
 4023df4:	014100f4 	movhi	r5,1027
 4023df8:	29447904 	addi	r5,r5,4580
 4023dfc:	d8c02705 	stb	r3,156(sp)
 4023e00:	d9802703 	ldbu	r6,156(sp)
 4023e04:	e0c00043 	ldbu	r3,1(fp)
 4023e08:	e1800205 	stb	r6,8(fp)
 4023e0c:	10800003 	ldbu	r2,0(r2)
 4023e10:	1c47883a 	add	r3,r3,r17
 4023e14:	d8802805 	stb	r2,160(sp)
 4023e18:	d9c02803 	ldbu	r7,160(sp)
 4023e1c:	e0800143 	ldbu	r2,5(fp)
 4023e20:	e1c00305 	stb	r7,12(fp)
 4023e24:	18c00003 	ldbu	r3,0(r3)
 4023e28:	1445883a 	add	r2,r2,r17
 4023e2c:	d8c02905 	stb	r3,164(sp)
 4023e30:	da002903 	ldbu	r8,164(sp)
 4023e34:	e0c00243 	ldbu	r3,9(fp)
 4023e38:	e2000045 	stb	r8,1(fp)
 4023e3c:	10800003 	ldbu	r2,0(r2)
 4023e40:	1c47883a 	add	r3,r3,r17
 4023e44:	020100f4 	movhi	r8,1027
 4023e48:	42047904 	addi	r8,r8,4580
 4023e4c:	d8802a05 	stb	r2,168(sp)
 4023e50:	dc402a03 	ldbu	r17,168(sp)
 4023e54:	e0800343 	ldbu	r2,13(fp)
 4023e58:	e4400145 	stb	r17,5(fp)
 4023e5c:	18c00003 	ldbu	r3,0(r3)
 4023e60:	d8c02b05 	stb	r3,172(sp)
 4023e64:	d9002b03 	ldbu	r4,172(sp)
 4023e68:	00c100f4 	movhi	r3,1027
 4023e6c:	18c47904 	addi	r3,r3,4580
 4023e70:	10c5883a 	add	r2,r2,r3
 4023e74:	e1000245 	stb	r4,9(fp)
 4023e78:	10800003 	ldbu	r2,0(r2)
 4023e7c:	e0c00083 	ldbu	r3,2(fp)
 4023e80:	d8802c05 	stb	r2,176(sp)
 4023e84:	d9802c03 	ldbu	r6,176(sp)
 4023e88:	1947883a 	add	r3,r3,r5
 4023e8c:	e0800183 	ldbu	r2,6(fp)
 4023e90:	e1800345 	stb	r6,13(fp)
 4023e94:	18c00003 	ldbu	r3,0(r3)
 4023e98:	1145883a 	add	r2,r2,r5
 4023e9c:	d8c02d05 	stb	r3,180(sp)
 4023ea0:	e0c00085 	stb	r3,2(fp)
 4023ea4:	10800003 	ldbu	r2,0(r2)
 4023ea8:	d8802e05 	stb	r2,184(sp)
 4023eac:	e0800185 	stb	r2,6(fp)
 4023eb0:	e0800283 	ldbu	r2,10(fp)
 4023eb4:	e0c00383 	ldbu	r3,14(fp)
 4023eb8:	e10000c3 	ldbu	r4,3(fp)
 4023ebc:	1145883a 	add	r2,r2,r5
 4023ec0:	10800003 	ldbu	r2,0(r2)
 4023ec4:	1947883a 	add	r3,r3,r5
 4023ec8:	2149883a 	add	r4,r4,r5
 4023ecc:	d8802f05 	stb	r2,188(sp)
 4023ed0:	e0800285 	stb	r2,10(fp)
 4023ed4:	18c00003 	ldbu	r3,0(r3)
 4023ed8:	d8c03005 	stb	r3,192(sp)
 4023edc:	d9c03003 	ldbu	r7,192(sp)
 4023ee0:	e08001c3 	ldbu	r2,7(fp)
 4023ee4:	e0c002c3 	ldbu	r3,11(fp)
 4023ee8:	e1c00385 	stb	r7,14(fp)
 4023eec:	21000003 	ldbu	r4,0(r4)
 4023ef0:	1145883a 	add	r2,r2,r5
 4023ef4:	1947883a 	add	r3,r3,r5
 4023ef8:	d9003105 	stb	r4,196(sp)
 4023efc:	e10000c5 	stb	r4,3(fp)
 4023f00:	10800003 	ldbu	r2,0(r2)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023f04:	e2800717 	ldw	r10,28(fp)
 4023f08:	e1000617 	ldw	r4,24(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023f0c:	d8803205 	stb	r2,200(sp)
 4023f10:	e08001c5 	stb	r2,7(fp)
 4023f14:	18c00003 	ldbu	r3,0(r3)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023f18:	51bfc00c 	andi	r6,r10,65280
 4023f1c:	300cd23a 	srli	r6,r6,8
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023f20:	d8c03305 	stb	r3,204(sp)
 4023f24:	dc403303 	ldbu	r17,204(sp)
 4023f28:	e08003c3 	ldbu	r2,15(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023f2c:	20ffc00c 	andi	r3,r4,65280
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023f30:	e44002c5 	stb	r17,11(fp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023f34:	d9803515 	stw	r6,212(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023f38:	1205883a 	add	r2,r2,r8
 4023f3c:	10800003 	ldbu	r2,0(r2)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023f40:	e2000917 	ldw	r8,36(fp)
 4023f44:	dc402503 	ldbu	r17,148(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = g_aes_isbox[ctx->state[x][y]];
 4023f48:	d8803405 	stb	r2,208(sp)
	for(i = 0; i < 16; i++) {
		int x, y;

		x = i & 0x03;
		y = i >> 2;
		ctx->state[x][y] = ctx->state[x][y] ^
 4023f4c:	1806d23a 	srli	r3,r3,8
 4023f50:	4004d63a 	srli	r2,r8,24
 4023f54:	da002603 	ldbu	r8,152(sp)
 4023f58:	21403fec 	andhi	r5,r4,255
 4023f5c:	201cd63a 	srli	r14,r4,24
 4023f60:	21003fcc 	andi	r4,r4,255
 4023f64:	2448f03a 	xor	r4,r4,r17
 4023f68:	1a06f03a 	xor	r3,r3,r8
 4023f6c:	dc402703 	ldbu	r17,156(sp)
 4023f70:	da002803 	ldbu	r8,160(sp)
 4023f74:	280ad43a 	srli	r5,r5,16
 4023f78:	e3400817 	ldw	r13,32(fp)
 4023f7c:	721cf03a 	xor	r14,r14,r8
 4023f80:	2c4af03a 	xor	r5,r5,r17
 4023f84:	da002a03 	ldbu	r8,168(sp)
 4023f88:	dc403517 	ldw	r17,212(sp)
 4023f8c:	52403fec 	andhi	r9,r10,255
 4023f90:	501ed63a 	srli	r15,r10,24
 4023f94:	8a22f03a 	xor	r17,r17,r8
 4023f98:	dc403615 	stw	r17,216(sp)
 4023f9c:	da002c03 	ldbu	r8,176(sp)
 4023fa0:	dc402b03 	ldbu	r17,172(sp)
 4023fa4:	4812d43a 	srli	r9,r9,16
 4023fa8:	6affc00c 	andi	r11,r13,65280
 4023fac:	6b003fec 	andhi	r12,r13,255
 4023fb0:	4c52f03a 	xor	r9,r9,r17
 4023fb4:	7a1ef03a 	xor	r15,r15,r8
 4023fb8:	dc402e03 	ldbu	r17,184(sp)
 4023fbc:	da002f03 	ldbu	r8,188(sp)
 4023fc0:	5816d23a 	srli	r11,r11,8
 4023fc4:	6018d43a 	srli	r12,r12,16
 4023fc8:	6820d63a 	srli	r16,r13,24
 4023fcc:	5c56f03a 	xor	r11,r11,r17
 4023fd0:	6218f03a 	xor	r12,r12,r8
 4023fd4:	dc403003 	ldbu	r17,192(sp)
 4023fd8:	da002903 	ldbu	r8,164(sp)
 4023fdc:	e1c00917 	ldw	r7,36(fp)
 4023fe0:	8460f03a 	xor	r16,r16,r17
 4023fe4:	5214f03a 	xor	r10,r10,r8
 4023fe8:	dc402d03 	ldbu	r17,180(sp)
 4023fec:	e0c00105 	stb	r3,4(fp)
 4023ff0:	e1400205 	stb	r5,8(fp)
 4023ff4:	e3800305 	stb	r14,12(fp)
 4023ff8:	e2800045 	stb	r10,1(fp)
 4023ffc:	d8c03617 	ldw	r3,216(sp)
 4024000:	6c5af03a 	xor	r13,r13,r17
 4024004:	e2400245 	stb	r9,9(fp)
 4024008:	e0c00145 	stb	r3,5(fp)
 402400c:	e3c00345 	stb	r15,13(fp)
 4024010:	e3400085 	stb	r13,2(fp)
 4024014:	e2c00185 	stb	r11,6(fp)
 4024018:	e3000285 	stb	r12,10(fp)
 402401c:	e4000385 	stb	r16,14(fp)
 4024020:	39bfc00c 	andi	r6,r7,65280
 4024024:	d9403203 	ldbu	r5,200(sp)
 4024028:	300cd23a 	srli	r6,r6,8
 402402c:	da003303 	ldbu	r8,204(sp)
 4024030:	dc403403 	ldbu	r17,208(sp)
 4024034:	e1000005 	stb	r4,0(fp)
 4024038:	e0c00917 	ldw	r3,36(fp)
 402403c:	314cf03a 	xor	r6,r6,r5
 4024040:	39c03fec 	andhi	r7,r7,255
 4024044:	d9403103 	ldbu	r5,196(sp)
 4024048:	380ed43a 	srli	r7,r7,16
 402404c:	1444f03a 	xor	r2,r2,r17
 4024050:	1946f03a 	xor	r3,r3,r5
 4024054:	d8c03715 	stw	r3,220(sp)
 4024058:	3a0ef03a 	xor	r7,r7,r8
 402405c:	e0c000c5 	stb	r3,3(fp)
 4024060:	e08003c5 	stb	r2,15(fp)
 4024064:	e18001c5 	stb	r6,7(fp)
 4024068:	e1c002c5 	stb	r7,11(fp)
	aes_invsubbytes(ctx);
	aes_addroundkey(ctx, 0);

	// copy state to output
	for(i = 0; i < 16; i++)
		output[i] = ctx->state[i & 0x03][i >> 2];
 402406c:	d9800517 	ldw	r6,20(sp)
 4024070:	31000005 	stb	r4,0(r6)
 4024074:	e0800103 	ldbu	r2,4(fp)
 4024078:	30800045 	stb	r2,1(r6)
 402407c:	e0c00203 	ldbu	r3,8(fp)
 4024080:	30c00085 	stb	r3,2(r6)
 4024084:	e0800303 	ldbu	r2,12(fp)
 4024088:	308000c5 	stb	r2,3(r6)
 402408c:	e0c00043 	ldbu	r3,1(fp)
 4024090:	30c00105 	stb	r3,4(r6)
 4024094:	e0800143 	ldbu	r2,5(fp)
 4024098:	30800145 	stb	r2,5(r6)
 402409c:	e0c00243 	ldbu	r3,9(fp)
 40240a0:	30c00185 	stb	r3,6(r6)
 40240a4:	e0800343 	ldbu	r2,13(fp)
 40240a8:	308001c5 	stb	r2,7(r6)
 40240ac:	e0c00083 	ldbu	r3,2(fp)
 40240b0:	30c00205 	stb	r3,8(r6)
 40240b4:	e0800183 	ldbu	r2,6(fp)
 40240b8:	30800245 	stb	r2,9(r6)
 40240bc:	e0c00283 	ldbu	r3,10(fp)
 40240c0:	30c00285 	stb	r3,10(r6)
 40240c4:	e0800383 	ldbu	r2,14(fp)
 40240c8:	308002c5 	stb	r2,11(r6)
 40240cc:	e0c000c3 	ldbu	r3,3(fp)
 40240d0:	30c00305 	stb	r3,12(r6)
 40240d4:	e08001c3 	ldbu	r2,7(fp)
 40240d8:	30800345 	stb	r2,13(r6)
 40240dc:	e0c002c3 	ldbu	r3,11(fp)
 40240e0:	30c00385 	stb	r3,14(r6)
 40240e4:	e08003c3 	ldbu	r2,15(fp)
 40240e8:	308003c5 	stb	r2,15(r6)
}
 40240ec:	dfc04317 	ldw	ra,268(sp)
 40240f0:	df004217 	ldw	fp,264(sp)
 40240f4:	ddc04117 	ldw	r23,260(sp)
 40240f8:	dd804017 	ldw	r22,256(sp)
 40240fc:	dd403f17 	ldw	r21,252(sp)
 4024100:	dd003e17 	ldw	r20,248(sp)
 4024104:	dcc03d17 	ldw	r19,244(sp)
 4024108:	dc803c17 	ldw	r18,240(sp)
 402410c:	dc403b17 	ldw	r17,236(sp)
 4024110:	dc003a17 	ldw	r16,232(sp)
 4024114:	dec04404 	addi	sp,sp,272
 4024118:	f800283a 	ret

0402411c <aes_alloc_ctx>:
	g_aes_isbox[0x7c] = 1;
	g_aes_isbox[0x63] = 0;
}

aes_ctx_t *aes_alloc_ctx(unsigned char *key, unsigned long keyLen)
{
 402411c:	defff504 	addi	sp,sp,-44
	aes_ctx_t *ctx;
	size_t rounds;
	size_t ks_size;

	switch(keyLen) {
 4024120:	00800604 	movi	r2,24
	g_aes_isbox[0x7c] = 1;
	g_aes_isbox[0x63] = 0;
}

aes_ctx_t *aes_alloc_ctx(unsigned char *key, unsigned long keyLen)
{
 4024124:	dc800315 	stw	r18,12(sp)
 4024128:	dc000115 	stw	r16,4(sp)
 402412c:	dfc00a15 	stw	ra,40(sp)
 4024130:	df000915 	stw	fp,36(sp)
 4024134:	ddc00815 	stw	r23,32(sp)
 4024138:	dd800715 	stw	r22,28(sp)
 402413c:	dd400615 	stw	r21,24(sp)
 4024140:	dd000515 	stw	r20,20(sp)
 4024144:	dcc00415 	stw	r19,16(sp)
 4024148:	dc400215 	stw	r17,8(sp)
 402414c:	2821883a 	mov	r16,r5
 4024150:	2025883a 	mov	r18,r4
	aes_ctx_t *ctx;
	size_t rounds;
	size_t ks_size;

	switch(keyLen) {
 4024154:	2880a526 	beq	r5,r2,40243ec <aes_alloc_ctx+0x2d0>
 4024158:	00800804 	movi	r2,32
 402415c:	2880a526 	beq	r5,r2,40243f4 <aes_alloc_ctx+0x2d8>
 4024160:	00800404 	movi	r2,16
 4024164:	2880a526 	beq	r5,r2,40243fc <aes_alloc_ctx+0x2e0>
		defaut:
			return NULL;
	}

	ks_size = 4*(rounds+1)*sizeof(unsigned long);
	ctx = malloc(sizeof(aes_ctx_t)+ks_size);
 4024168:	8808913a 	slli	r4,r17,4
 402416c:	21000a04 	addi	r4,r4,40
 4024170:	4026c740 	call	4026c74 <malloc>
 4024174:	102f883a 	mov	r23,r2
	if(ctx) {
 4024178:	10008b26 	beq	r2,zero,40243a8 <aes_alloc_ctx+0x28c>
		ctx->rounds = rounds;
		ctx->kcol = keyLen/4;
 402417c:	8026d0ba 	srli	r19,r16,2
		memcpy(ctx->keysched, key, keyLen);
 4024180:	11000604 	addi	r4,r2,24
	}

	ks_size = 4*(rounds+1)*sizeof(unsigned long);
	ctx = malloc(sizeof(aes_ctx_t)+ks_size);
	if(ctx) {
		ctx->rounds = rounds;
 4024184:	14400515 	stw	r17,20(r2)
		ctx->kcol = keyLen/4;
 4024188:	14c00415 	stw	r19,16(r2)
		memcpy(ctx->keysched, key, keyLen);
 402418c:	900b883a 	mov	r5,r18
 4024190:	800d883a 	mov	r6,r16
 4024194:	40273c80 	call	40273c8 <memcpy>
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4024198:	b8c00517 	ldw	r3,20(r23)
 402419c:	bc400417 	ldw	r17,16(r23)
	ctx = malloc(sizeof(aes_ctx_t)+ks_size);
	if(ctx) {
		ctx->rounds = rounds;
		ctx->kcol = keyLen/4;
		memcpy(ctx->keysched, key, keyLen);
		ctx->keysched[43] = 0;
 40241a0:	b8003115 	stw	zero,196(r23)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 40241a4:	18c7883a 	add	r3,r3,r3
 40241a8:	18c7883a 	add	r3,r3,r3
 40241ac:	19000104 	addi	r4,r3,4
 40241b0:	8827883a 	mov	r19,r17
 40241b4:	89007c2e 	bgeu	r17,r4,40243a8 <aes_alloc_ctx+0x28c>
 40241b8:	88ffff24 	muli	r3,r17,-4
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
 40241bc:	8c45883a 	add	r2,r17,r17
 40241c0:	014100f4 	movhi	r5,1027
 40241c4:	2944f904 	addi	r5,r5,5092
 40241c8:	1085883a 	add	r2,r2,r2
 40241cc:	1dc7883a 	add	r3,r3,r23
 40241d0:	29400083 	ldbu	r5,2(r5)
 40241d4:	10c7883a 	add	r3,r2,r3
 40241d8:	10800504 	addi	r2,r2,20
 40241dc:	b8a9883a 	add	r20,r23,r2
 40241e0:	2039883a 	mov	fp,r4
 40241e4:	1d400604 	addi	r21,r3,24
 40241e8:	04800044 	movi	r18,1
 40241ec:	058100f4 	movhi	r22,1027
 40241f0:	b584b904 	addi	r22,r22,4836
 40241f4:	d9400015 	stw	r5,0(sp)
 40241f8:	00004206 	br	4024304 <aes_alloc_ctx+0x1e8>
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
 40241fc:	8804913a 	slli	r2,r17,4
 4024200:	00c100f4 	movhi	r3,1027
 4024204:	18f72704 	addi	r3,r3,-9060
 4024208:	14c4b03a 	or	r2,r2,r19
 402420c:	10c5883a 	add	r2,r2,r3
 4024210:	10800003 	ldbu	r2,0(r2)
 4024214:	14c5383a 	mul	r2,r2,r19
 4024218:	8887c83a 	sub	r3,r17,r2
 402421c:	1800431e 	bne	r3,zero,402432c <aes_alloc_ctx+0x210>
inline unsigned long aes_rotword(unsigned long w)
{
	// May seem a bit different from the spec
	// It was changed because unsigned long is represented with little-endian convention on x86
	// Should not depend on architecture, but this is only a POC
	return ((w & 0x000000ff) << 24) |
 4024220:	80ffc00c 	andi	r3,r16,65280
 4024224:	813fffec 	andhi	r4,r16,65535
 4024228:	1806d23a 	srli	r3,r3,8
 402422c:	8004963a 	slli	r2,r16,24
 4024230:	2008d23a 	srli	r4,r4,8
 4024234:	10c4b03a 	or	r2,r2,r3
 4024238:	1104b03a 	or	r2,r2,r4

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
 402423c:	10ffc00c 	andi	r3,r2,65280
 4024240:	11003fec 	andhi	r4,r2,255
 4024244:	100ad63a 	srli	r5,r2,24
 4024248:	1806d23a 	srli	r3,r3,8
 402424c:	2008d43a 	srli	r4,r4,16
 4024250:	2d8b883a 	add	r5,r5,r22
 4024254:	1d87883a 	add	r3,r3,r22
 4024258:	2589883a 	add	r4,r4,r22
 402425c:	1a000003 	ldbu	r8,0(r3)
 4024260:	21800003 	ldbu	r6,0(r4)
 4024264:	29c00003 	ldbu	r7,0(r5)
 4024268:	10803fcc 	andi	r2,r2,255
 402426c:	1585883a 	add	r2,r2,r22
 4024270:	10c00003 	ldbu	r3,0(r2)
 4024274:	4010923a 	slli	r8,r8,8
 4024278:	300c943a 	slli	r6,r6,16
 402427c:	380e963a 	slli	r7,r7,24
 4024280:	1a06b03a 	or	r3,r3,r8
 4024284:	31ccb03a 	or	r6,r6,r7
 4024288:	1986b03a 	or	r3,r3,r6
 402428c:	90e0f03a 	xor	r16,r18,r3
			rcon = aes_mul(rcon, 2);
 4024290:	90001526 	beq	r18,zero,40242e8 <aes_alloc_ctx+0x1cc>
 4024294:	00c100f4 	movhi	r3,1027
 4024298:	18c4f904 	addi	r3,r3,5092
 402429c:	90c5883a 	add	r2,r18,r3
 40242a0:	10c00003 	ldbu	r3,0(r2)
 40242a4:	d9400017 	ldw	r5,0(sp)
 40242a8:	008003c4 	movi	r2,15
 40242ac:	1965883a 	add	r18,r3,r5
 40242b0:	91003fd4 	ori	r4,r18,255
 40242b4:	11004936 	bltu	r2,r4,40243dc <aes_alloc_ctx+0x2c0>
 40242b8:	9004913a 	slli	r2,r18,4
 40242bc:	00c100f4 	movhi	r3,1027
 40242c0:	18f72704 	addi	r3,r3,-9060
 40242c4:	10803fd4 	ori	r2,r2,255
 40242c8:	10c5883a 	add	r2,r2,r3
 40242cc:	10800003 	ldbu	r2,0(r2)
 40242d0:	10c03fe4 	muli	r3,r2,255
 40242d4:	008100f4 	movhi	r2,1027
 40242d8:	10843904 	addi	r2,r2,4324
 40242dc:	90c7c83a 	sub	r3,r18,r3
 40242e0:	10c5883a 	add	r2,r2,r3
 40242e4:	14800003 	ldbu	r18,0(r2)
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 40242e8:	a8800017 	ldw	r2,0(r21)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 40242ec:	8c400044 	addi	r17,r17,1
 40242f0:	ad400104 	addi	r21,r21,4
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 40242f4:	8084f03a 	xor	r2,r16,r2
 40242f8:	a0800115 	stw	r2,4(r20)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 40242fc:	a5000104 	addi	r20,r20,4
 4024300:	8f00292e 	bgeu	r17,fp,40243a8 <aes_alloc_ctx+0x28c>
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
 4024304:	8cc6b03a 	or	r3,r17,r19
 4024308:	008003c4 	movi	r2,15
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
 402430c:	a4000017 	ldw	r16,0(r20)
		if(!(i%ctx->kcol)) {
 4024310:	10ffba2e 	bgeu	r2,r3,40241fc <aes_alloc_ctx+0xe0>
 4024314:	8809883a 	mov	r4,r17
 4024318:	980b883a 	mov	r5,r19
 402431c:	40265d40 	call	40265d4 <__divsi3>
 4024320:	14c5383a 	mul	r2,r2,r19
 4024324:	8887c83a 	sub	r3,r17,r2
 4024328:	183fbd26 	beq	r3,zero,4024220 <aes_alloc_ctx+0x104>
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
 402432c:	00800184 	movi	r2,6
 4024330:	14ffed0e 	bge	r2,r19,40242e8 <aes_alloc_ctx+0x1cc>
 4024334:	00800104 	movi	r2,4
 4024338:	18bfeb1e 	bne	r3,r2,40242e8 <aes_alloc_ctx+0x1cc>
	return ctx;
}

inline unsigned long aes_subword(unsigned long w)
{
	return g_aes_sbox[w & 0x000000ff] |
 402433c:	80bfc00c 	andi	r2,r16,65280
 4024340:	80c03fec 	andhi	r3,r16,255
 4024344:	800ad63a 	srli	r5,r16,24
 4024348:	1004d23a 	srli	r2,r2,8
 402434c:	1806d43a 	srli	r3,r3,16
 4024350:	2d8b883a 	add	r5,r5,r22
 4024354:	1585883a 	add	r2,r2,r22
 4024358:	1d87883a 	add	r3,r3,r22
 402435c:	11c00003 	ldbu	r7,0(r2)
 4024360:	19000003 	ldbu	r4,0(r3)
 4024364:	29800003 	ldbu	r6,0(r5)
 4024368:	80803fcc 	andi	r2,r16,255
 402436c:	1585883a 	add	r2,r2,r22
 4024370:	10c00003 	ldbu	r3,0(r2)
 4024374:	380e923a 	slli	r7,r7,8
 4024378:	2008943a 	slli	r4,r4,16
 402437c:	300c963a 	slli	r6,r6,24
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4024380:	a8800017 	ldw	r2,0(r21)
	return ctx;
}

inline unsigned long aes_subword(unsigned long w)
{
	return g_aes_sbox[w & 0x000000ff] |
 4024384:	19c6b03a 	or	r3,r3,r7
 4024388:	2188b03a 	or	r4,r4,r6
 402438c:	1920b03a 	or	r16,r3,r4
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4024390:	8084f03a 	xor	r2,r16,r2
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 4024394:	8c400044 	addi	r17,r17,1
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
		} else if(ctx->kcol > 6 && i%ctx->kcol == 4)
			temp = aes_subword(temp);
		ctx->keysched[i] = ctx->keysched[i-ctx->kcol] ^ temp;
 4024398:	a0800115 	stw	r2,4(r20)
	unsigned long temp;
	unsigned long rcon;
	register int i;

	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
 402439c:	ad400104 	addi	r21,r21,4
 40243a0:	a5000104 	addi	r20,r20,4
 40243a4:	8f3fd736 	bltu	r17,fp,4024304 <aes_alloc_ctx+0x1e8>
		ctx->keysched[43] = 0;
		aes_keyexpansion(ctx);
	}

	return ctx;
}
 40243a8:	b805883a 	mov	r2,r23
 40243ac:	dfc00a17 	ldw	ra,40(sp)
 40243b0:	df000917 	ldw	fp,36(sp)
 40243b4:	ddc00817 	ldw	r23,32(sp)
 40243b8:	dd800717 	ldw	r22,28(sp)
 40243bc:	dd400617 	ldw	r21,24(sp)
 40243c0:	dd000517 	ldw	r20,20(sp)
 40243c4:	dcc00417 	ldw	r19,16(sp)
 40243c8:	dc800317 	ldw	r18,12(sp)
 40243cc:	dc400217 	ldw	r17,8(sp)
 40243d0:	dc000117 	ldw	r16,4(sp)
 40243d4:	dec00b04 	addi	sp,sp,44
 40243d8:	f800283a 	ret
	rcon = 0x00000001;
	for(i = ctx->kcol; i < (4*(ctx->rounds+1)); i++) {
		temp = ctx->keysched[i-1];
		if(!(i%ctx->kcol)) {
			temp = aes_subword(aes_rotword(temp)) ^ rcon;
			rcon = aes_mul(rcon, 2);
 40243dc:	9009883a 	mov	r4,r18
 40243e0:	01403fc4 	movi	r5,255
 40243e4:	40265d40 	call	40265d4 <__divsi3>
 40243e8:	003fb906 	br	40242d0 <aes_alloc_ctx+0x1b4>
	size_t ks_size;

	switch(keyLen) {
		case 16: // 128-bit key
			rounds = 10;
			break;
 40243ec:	04400304 	movi	r17,12
 40243f0:	003f5d06 	br	4024168 <aes_alloc_ctx+0x4c>
{
	aes_ctx_t *ctx;
	size_t rounds;
	size_t ks_size;

	switch(keyLen) {
 40243f4:	04400384 	movi	r17,14
 40243f8:	003f5b06 	br	4024168 <aes_alloc_ctx+0x4c>
 40243fc:	04400284 	movi	r17,10
 4024400:	003f5906 	br	4024168 <aes_alloc_ctx+0x4c>

04024404 <csleep>:
	printf("\n************************\n");
}
#endif

void csleep(alt_u32 cycles)
{
 4024404:	defffe04 	addi	sp,sp,-8
 4024408:	dc400015 	stw	r17,0(sp)
 402440c:	dfc00115 	stw	ra,4(sp)
 4024410:	2023883a 	mov	r17,r4
	alt_u32 t_start = alt_timestamp();
 4024414:	402b42c0 	call	402b42c <alt_timestamp>
	alt_u32 t_target = t_start + cycles;
 4024418:	1463883a 	add	r17,r2,r17
 402441c:	00000106 	br	4024424 <csleep+0x20>
	while (alt_timestamp() < t_target)
		__asm__("nop");
 4024420:	0001883a 	nop

void csleep(alt_u32 cycles)
{
	alt_u32 t_start = alt_timestamp();
	alt_u32 t_target = t_start + cycles;
	while (alt_timestamp() < t_target)
 4024424:	402b42c0 	call	402b42c <alt_timestamp>
 4024428:	147ffd36 	bltu	r2,r17,4024420 <csleep+0x1c>
		__asm__("nop");
}
 402442c:	dfc00117 	ldw	ra,4(sp)
 4024430:	dc400017 	ldw	r17,0(sp)
 4024434:	dec00204 	addi	sp,sp,8
 4024438:	f800283a 	ret

0402443c <spi_pow_testbench>:
	return t_mbc_run;
}

alt_u8 len = 0x04;
alt_u8 data[] = {0xAA, 0xAA, 0xAA, 0xAA};
int spi_pow_testbench() {
 402443c:	defffc04 	addi	sp,sp,-16
 4024440:	dfc00315 	stw	ra,12(sp)
	/*spi_tx_char(data[0], SPI_0_BASE);
	spi_tx_char(data[1], SPI_0_BASE);
	spi_tx_char(data[2], SPI_0_BASE);
	spi_tx_char(data[3], SPI_0_BASE);*/
	t_spi_xmit_begin = alt_timestamp();
 4024444:	402b42c0 	call	402b42c <alt_timestamp>
	SPI_WRITE(len, data);
 4024448:	d1a00a03 	ldbu	r6,-32728(gp)
 402444c:	01010134 	movhi	r4,1028
 4024450:	21040804 	addi	r4,r4,4128
 4024454:	000b883a 	mov	r5,zero
 4024458:	d1e00a44 	addi	r7,gp,-32727
 402445c:	d8000015 	stw	zero,0(sp)
 4024460:	d8000115 	stw	zero,4(sp)
 4024464:	d8000215 	stw	zero,8(sp)
int spi_pow_testbench() {
	/*spi_tx_char(data[0], SPI_0_BASE);
	spi_tx_char(data[1], SPI_0_BASE);
	spi_tx_char(data[2], SPI_0_BASE);
	spi_tx_char(data[3], SPI_0_BASE);*/
	t_spi_xmit_begin = alt_timestamp();
 4024468:	d0a6a415 	stw	r2,-25968(gp)
	SPI_WRITE(len, data);
 402446c:	402b0500 	call	402b050 <alt_avalon_spi_command>
	t_spi_xmit_end = alt_timestamp();
 4024470:	402b42c0 	call	402b42c <alt_timestamp>
	t_spi_xmit = (t_spi_xmit_end - t_spi_xmit_begin);
 4024474:	d0e6a417 	ldw	r3,-25968(gp)
	spi_tx_char(data[1], SPI_0_BASE);
	spi_tx_char(data[2], SPI_0_BASE);
	spi_tx_char(data[3], SPI_0_BASE);*/
	t_spi_xmit_begin = alt_timestamp();
	SPI_WRITE(len, data);
	t_spi_xmit_end = alt_timestamp();
 4024478:	d0a69615 	stw	r2,-26024(gp)
	t_spi_xmit = (t_spi_xmit_end - t_spi_xmit_begin);
 402447c:	10c5c83a 	sub	r2,r2,r3
 4024480:	d0a6be15 	stw	r2,-25864(gp)
	return t_spi_xmit;

}
 4024484:	dfc00317 	ldw	ra,12(sp)
 4024488:	dec00404 	addi	sp,sp,16
 402448c:	f800283a 	ret

04024490 <ci_testbench>:
#if RUN_CPU_TESTS

	volatile char b [] = {12, 14, 14, 12, 8, 14, 8, 12};
	volatile char g [] = {15, 15, 14, 13, 12, 12, 12, 13};
	volatile char r [] = {11, 12, 10, 12, 11, 12, 14, 14};
int ci_testbench() {
 4024490:	defffa04 	addi	sp,sp,-24
 4024494:	dfc00515 	stw	ra,20(sp)
 4024498:	dd000415 	stw	r20,16(sp)
 402449c:	dcc00315 	stw	r19,12(sp)
 40244a0:	dc800215 	stw	r18,8(sp)
 40244a4:	dc400115 	stw	r17,4(sp)
 40244a8:	dc000015 	stw	r16,0(sp)
	int numPx = 108;
	int i, j, sumR = 0, sumG = 0, sumB = 0;
	int temp = 0, result = 0;
	sumB = sumG = sumR = 0;
	t_ci_run_begin = alt_timestamp();
 40244ac:	402b42c0 	call	402b42c <alt_timestamp>
 40244b0:	d0a6b615 	stw	r2,-25896(gp)
	EX_BEGIN();
 40244b4:	00c03fc4 	movi	r3,255
 40244b8:	00810134 	movhi	r2,1028
 40244bc:	10843404 	addi	r2,r2,4304
 40244c0:	10c00035 	stwio	r3,0(r2)
 40244c4:	000f883a 	mov	r7,zero
 40244c8:	d2a00004 	addi	r10,gp,-32768
 40244cc:	d2600204 	addi	r9,gp,-32760
 40244d0:	d2200404 	addi	r8,gp,-32752
 40244d4:	02c01b04 	movi	r11,108
	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 40244d8:	3a85883a 	add	r2,r7,r10
		sumG = sumG + g[i];
 40244dc:	3a47883a 	add	r3,r7,r9
		sumR = sumR + r[i];
 40244e0:	3a09883a 	add	r4,r7,r8
	int i, j, sumR = 0, sumG = 0, sumB = 0;
	int temp = 0, result = 0;
	sumB = sumG = sumR = 0;
	t_ci_run_begin = alt_timestamp();
	EX_BEGIN();
	for (i = 0; i < numPx; i = i + 1) {
 40244e4:	39c00044 	addi	r7,r7,1
		sumB = sumB + b[i];
 40244e8:	11400003 	ldbu	r5,0(r2)
		sumG = sumG + g[i];
 40244ec:	19800003 	ldbu	r6,0(r3)
		sumR = sumR + r[i];
 40244f0:	20800003 	ldbu	r2,0(r4)
	int i, j, sumR = 0, sumG = 0, sumB = 0;
	int temp = 0, result = 0;
	sumB = sumG = sumR = 0;
	t_ci_run_begin = alt_timestamp();
	EX_BEGIN();
	for (i = 0; i < numPx; i = i + 1) {
 40244f4:	3afff81e 	bne	r7,r11,40244d8 <ci_testbench+0x48>
	}
	sumB = sumB / numPx;
	sumG = ((sumG / numPx) << 8);
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	EX_END();
 40244f8:	00810134 	movhi	r2,1028
 40244fc:	10843404 	addi	r2,r2,4304
 4024500:	10000035 	stwio	zero,0(r2)
 4024504:	000f883a 	mov	r7,zero
 4024508:	02c01b04 	movi	r11,108
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 402450c:	3a85883a 	add	r2,r7,r10
		sumG = sumG + g[i];
 4024510:	3a47883a 	add	r3,r7,r9
		sumR = sumR + r[i];
 4024514:	3a09883a 	add	r4,r7,r8
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	EX_END();
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
 4024518:	39c00044 	addi	r7,r7,1
		sumB = sumB + b[i];
 402451c:	11400003 	ldbu	r5,0(r2)
		sumG = sumG + g[i];
 4024520:	19800003 	ldbu	r6,0(r3)
		sumR = sumR + r[i];
 4024524:	20800003 	ldbu	r2,0(r4)
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	EX_END();
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
 4024528:	3afff81e 	bne	r7,r11,402450c <ci_testbench+0x7c>
 402452c:	000f883a 	mov	r7,zero
 4024530:	0021883a 	mov	r16,zero
 4024534:	0025883a 	mov	r18,zero
 4024538:	0023883a 	mov	r17,zero
 402453c:	02c01b04 	movi	r11,108
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 4024540:	3a89883a 	add	r4,r7,r10
		sumG = sumG + g[i];
 4024544:	3a4b883a 	add	r5,r7,r9
		sumR = sumR + r[i];
 4024548:	3a0d883a 	add	r6,r7,r8
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 402454c:	20800003 	ldbu	r2,0(r4)
		sumG = sumG + g[i];
 4024550:	28c00003 	ldbu	r3,0(r5)
		sumR = sumR + r[i];
 4024554:	31000003 	ldbu	r4,0(r6)
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 4024558:	10803fcc 	andi	r2,r2,255
		sumG = sumG + g[i];
 402455c:	18c03fcc 	andi	r3,r3,255
		sumR = sumR + r[i];
 4024560:	21003fcc 	andi	r4,r4,255
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 4024564:	1080201c 	xori	r2,r2,128
		sumG = sumG + g[i];
 4024568:	18c0201c 	xori	r3,r3,128
		sumR = sumR + r[i];
 402456c:	2100201c 	xori	r4,r4,128
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
		sumB = sumB + b[i];
 4024570:	10bfe004 	addi	r2,r2,-128
		sumG = sumG + g[i];
 4024574:	18ffe004 	addi	r3,r3,-128
		sumR = sumR + r[i];
 4024578:	213fe004 	addi	r4,r4,-128
	sumG = ((sumG / numPx) << 8);
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
 402457c:	39c00044 	addi	r7,r7,1
		sumB = sumB + b[i];
 4024580:	88a3883a 	add	r17,r17,r2
		sumG = sumG + g[i];
 4024584:	90e5883a 	add	r18,r18,r3
		sumR = sumR + r[i];
 4024588:	8121883a 	add	r16,r16,r4
	sumG = ((sumG / numPx) << 8);
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;
	sumB = sumG = sumR = 0;

	for (i = 0; i < numPx; i = i + 1) {
 402458c:	3affec1e 	bne	r7,r11,4024540 <ci_testbench+0xb0>
	sumB = sumB / numPx;
	sumG = ((sumG / numPx) << 8);
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;

	t_ci_run_end = alt_timestamp();
 4024590:	402b42c0 	call	402b42c <alt_timestamp>
	t_ci_run = (t_ci_run_end - t_ci_run_begin) / 3;
 4024594:	d166b617 	ldw	r5,-25896(gp)
 4024598:	00eaaaf4 	movhi	r3,43691
 402459c:	18eaaac4 	addi	r3,r3,-21845
	sumB = sumB / numPx;
	sumG = ((sumG / numPx) << 8);
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;

	t_ci_run_end = alt_timestamp();
 40245a0:	d0a69515 	stw	r2,-26028(gp)
	t_ci_run = (t_ci_run_end - t_ci_run_begin) / 3;
 40245a4:	114bc83a 	sub	r5,r2,r5
 40245a8:	28e8383a 	mulxuu	r20,r5,r3
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("CI: %08x\n", temp);
 40245ac:	81801b14 	ori	r6,r16,108
 40245b0:	00c003c4 	movi	r3,15
	sumG = ((sumG / numPx) << 8);
	sumR = ((sumR / numPx) << 16);
	temp = sumR + sumB + sumG;

	t_ci_run_end = alt_timestamp();
	t_ci_run = (t_ci_run_end - t_ci_run_begin) / 3;
 40245b4:	a004d07a 	srli	r2,r20,1
 40245b8:	01c01b04 	movi	r7,108
 40245bc:	d0a6ae15 	stw	r2,-25928(gp)
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("CI: %08x\n", temp);
 40245c0:	19802836 	bltu	r3,r6,4024664 <ci_testbench+0x1d4>
 40245c4:	8004913a 	slli	r2,r16,4
 40245c8:	00c100f4 	movhi	r3,1027
 40245cc:	18f72704 	addi	r3,r3,-9060
 40245d0:	11c4b03a 	or	r2,r2,r7
 40245d4:	10c5883a 	add	r2,r2,r3
 40245d8:	10800003 	ldbu	r2,0(r2)
 40245dc:	88c01b14 	ori	r3,r17,108
 40245e0:	1026943a 	slli	r19,r2,16
 40245e4:	008003c4 	movi	r2,15
 40245e8:	10c02536 	bltu	r2,r3,4024680 <ci_testbench+0x1f0>
 40245ec:	8804913a 	slli	r2,r17,4
 40245f0:	00c100f4 	movhi	r3,1027
 40245f4:	18f72704 	addi	r3,r3,-9060
 40245f8:	10801b14 	ori	r2,r2,108
 40245fc:	10c5883a 	add	r2,r2,r3
 4024600:	14000003 	ldbu	r16,0(r2)
 4024604:	90c01b14 	ori	r3,r18,108
 4024608:	008003c4 	movi	r2,15
 402460c:	10c02336 	bltu	r2,r3,402469c <ci_testbench+0x20c>
 4024610:	9004913a 	slli	r2,r18,4
 4024614:	00c100f4 	movhi	r3,1027
 4024618:	18f72704 	addi	r3,r3,-9060
 402461c:	10801b14 	ori	r2,r2,108
 4024620:	10c5883a 	add	r2,r2,r3
 4024624:	10800003 	ldbu	r2,0(r2)
 4024628:	100a923a 	slli	r5,r2,8
 402462c:	010100f4 	movhi	r4,1027
 4024630:	21355104 	addi	r4,r4,-10940
 4024634:	814b883a 	add	r5,r16,r5
 4024638:	994b883a 	add	r5,r19,r5
 402463c:	40274140 	call	4027414 <printf>
#endif
	return t_ci_run;
}
 4024640:	d0a6ae17 	ldw	r2,-25928(gp)
 4024644:	dfc00517 	ldw	ra,20(sp)
 4024648:	dd000417 	ldw	r20,16(sp)
 402464c:	dcc00317 	ldw	r19,12(sp)
 4024650:	dc800217 	ldw	r18,8(sp)
 4024654:	dc400117 	ldw	r17,4(sp)
 4024658:	dc000017 	ldw	r16,0(sp)
 402465c:	dec00604 	addi	sp,sp,24
 4024660:	f800283a 	ret
	temp = sumR + sumB + sumG;

	t_ci_run_end = alt_timestamp();
	t_ci_run = (t_ci_run_end - t_ci_run_begin) / 3;
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("CI: %08x\n", temp);
 4024664:	8009883a 	mov	r4,r16
 4024668:	380b883a 	mov	r5,r7
 402466c:	40265d40 	call	40265d4 <__divsi3>
 4024670:	1026943a 	slli	r19,r2,16
 4024674:	88c01b14 	ori	r3,r17,108
 4024678:	008003c4 	movi	r2,15
 402467c:	10ffdb2e 	bgeu	r2,r3,40245ec <ci_testbench+0x15c>
 4024680:	8809883a 	mov	r4,r17
 4024684:	01401b04 	movi	r5,108
 4024688:	40265d40 	call	40265d4 <__divsi3>
 402468c:	1021883a 	mov	r16,r2
 4024690:	90c01b14 	ori	r3,r18,108
 4024694:	008003c4 	movi	r2,15
 4024698:	10ffdd2e 	bgeu	r2,r3,4024610 <ci_testbench+0x180>
 402469c:	9009883a 	mov	r4,r18
 40246a0:	01401b04 	movi	r5,108
 40246a4:	40265d40 	call	40265d4 <__divsi3>
 40246a8:	003fdf06 	br	4024628 <ci_testbench+0x198>

040246ac <mbc_testbench>:
#endif
	return t_des_run;
}
#endif

int mbc_testbench(){
 40246ac:	deffff04 	addi	sp,sp,-4
 40246b0:	dfc00015 	stw	ra,0(sp)
	t_mbc_run_begin = alt_timestamp();
 40246b4:	402b42c0 	call	402b42c <alt_timestamp>
 40246b8:	d0a6bc15 	stw	r2,-25872(gp)
	EX_BEGIN();
 40246bc:	00c10134 	movhi	r3,1028
 40246c0:	18c43404 	addi	r3,r3,4304
 40246c4:	00803fc4 	movi	r2,255
 40246c8:	18800035 	stwio	r2,0(r3)
	MBC_START();
 40246cc:	0009c032 	custom	0,r4,zero,zero
	EX_END();
 40246d0:	18000035 	stwio	zero,0(r3)
	t_mbc_run_end = alt_timestamp();
 40246d4:	402b42c0 	call	402b42c <alt_timestamp>
	t_mbc_run = (t_mbc_run_end - t_mbc_run_begin);
 40246d8:	d0e6bc17 	ldw	r3,-25872(gp)
int mbc_testbench(){
	t_mbc_run_begin = alt_timestamp();
	EX_BEGIN();
	MBC_START();
	EX_END();
	t_mbc_run_end = alt_timestamp();
 40246dc:	d0a6a815 	stw	r2,-25952(gp)
	t_mbc_run = (t_mbc_run_end - t_mbc_run_begin);
 40246e0:	10c5c83a 	sub	r2,r2,r3
 40246e4:	d0a6b515 	stw	r2,-25900(gp)
	return t_mbc_run;
}
 40246e8:	dfc00017 	ldw	ra,0(sp)
 40246ec:	dec00104 	addi	sp,sp,4
 40246f0:	f800283a 	ret

040246f4 <des_testbench>:
}

volatile unsigned char dst[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
volatile unsigned char key2[8] = { 0x5B, 0x5A, 0x57, 0x67, 0x6A, 0x56, 0x67, 0X6E };
volatile unsigned char src[8] = { 0x67, 0x5A, 0x69, 0x67, 0x5E, 0x5A, 0x6B, 0x5A };
int des_testbench(){
 40246f4:	defff904 	addi	sp,sp,-28
 40246f8:	ddc00515 	stw	r23,20(sp)
 40246fc:	dfc00615 	stw	ra,24(sp)
 4024700:	dd800415 	stw	r22,16(sp)
 4024704:	dd400315 	stw	r21,12(sp)
 4024708:	dcc00215 	stw	r19,8(sp)
 402470c:	dc400115 	stw	r17,4(sp)
 4024710:	dc000015 	stw	r16,0(sp)
	t_des_run_begin = alt_timestamp();
 4024714:	402b42c0 	call	402b42c <alt_timestamp>
 4024718:	d0a6c415 	stw	r2,-25840(gp)
	EX_BEGIN();
 402471c:	05c10134 	movhi	r23,1028
 4024720:	bdc43404 	addi	r23,r23,4304
 4024724:	00803fc4 	movi	r2,255
 4024728:	b8800035 	stwio	r2,0(r23)
	auth_DEShash(dst, key2, src);
 402472c:	d5a69204 	addi	r22,gp,-26040
 4024730:	d4e00604 	addi	r19,gp,-32744
 4024734:	d5600804 	addi	r21,gp,-32736
 4024738:	b009883a 	mov	r4,r22
 402473c:	980b883a 	mov	r5,r19
 4024740:	a80d883a 	mov	r6,r21
 4024744:	402032c0 	call	402032c <auth_DEShash>
	EX_END();
 4024748:	b8000035 	stwio	zero,0(r23)
	auth_DEShash(dst, key2, src);
 402474c:	b009883a 	mov	r4,r22
 4024750:	980b883a 	mov	r5,r19
 4024754:	a80d883a 	mov	r6,r21
 4024758:	402032c0 	call	402032c <auth_DEShash>
	auth_DEShash(dst, key2, src);
 402475c:	a80d883a 	mov	r6,r21
 4024760:	b009883a 	mov	r4,r22
 4024764:	980b883a 	mov	r5,r19
 4024768:	402032c0 	call	402032c <auth_DEShash>
	t_des_run_end = alt_timestamp();
 402476c:	402b42c0 	call	402b42c <alt_timestamp>
	t_des_run = (t_des_run_end - t_des_run_begin) / 3;
 4024770:	d0e6c417 	ldw	r3,-25840(gp)
 4024774:	016aaaf4 	movhi	r5,43691
 4024778:	296aaac4 	addi	r5,r5,-21845
	EX_BEGIN();
	auth_DEShash(dst, key2, src);
	EX_END();
	auth_DEShash(dst, key2, src);
	auth_DEShash(dst, key2, src);
	t_des_run_end = alt_timestamp();
 402477c:	d0a6af15 	stw	r2,-25924(gp)
	t_des_run = (t_des_run_end - t_des_run_begin) / 3;
 4024780:	10c7c83a 	sub	r3,r2,r3
 4024784:	1962383a 	mulxuu	r17,r3,r5
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("DES: ");
 4024788:	010100f4 	movhi	r4,1027
 402478c:	21355404 	addi	r4,r4,-10928
	int i;
	for(i = 0; i < 8; i = i + 1)
		printf("%02x ", dst[i]);
 4024790:	04c100f4 	movhi	r19,1027
 4024794:	9cf55604 	addi	r19,r19,-10920
	auth_DEShash(dst, key2, src);
	EX_END();
	auth_DEShash(dst, key2, src);
	auth_DEShash(dst, key2, src);
	t_des_run_end = alt_timestamp();
	t_des_run = (t_des_run_end - t_des_run_begin) / 3;
 4024798:	8804d07a 	srli	r2,r17,1
 402479c:	d0a69f15 	stw	r2,-25988(gp)
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("DES: ");
 40247a0:	40274140 	call	4027414 <printf>
	int i;
	for(i = 0; i < 8; i = i + 1)
		printf("%02x ", dst[i]);
 40247a4:	d1669203 	ldbu	r5,-26040(gp)
 40247a8:	9809883a 	mov	r4,r19
 40247ac:	29403fcc 	andi	r5,r5,255
 40247b0:	40274140 	call	4027414 <printf>
 40247b4:	b1400043 	ldbu	r5,1(r22)
 40247b8:	9809883a 	mov	r4,r19
 40247bc:	29403fcc 	andi	r5,r5,255
 40247c0:	40274140 	call	4027414 <printf>
 40247c4:	b1400083 	ldbu	r5,2(r22)
 40247c8:	9809883a 	mov	r4,r19
 40247cc:	29403fcc 	andi	r5,r5,255
 40247d0:	40274140 	call	4027414 <printf>
 40247d4:	b14000c3 	ldbu	r5,3(r22)
 40247d8:	9809883a 	mov	r4,r19
 40247dc:	29403fcc 	andi	r5,r5,255
 40247e0:	40274140 	call	4027414 <printf>
 40247e4:	b1400103 	ldbu	r5,4(r22)
 40247e8:	9809883a 	mov	r4,r19
 40247ec:	29403fcc 	andi	r5,r5,255
 40247f0:	40274140 	call	4027414 <printf>
 40247f4:	b1400143 	ldbu	r5,5(r22)
 40247f8:	9809883a 	mov	r4,r19
 40247fc:	29403fcc 	andi	r5,r5,255
 4024800:	40274140 	call	4027414 <printf>
 4024804:	b1400183 	ldbu	r5,6(r22)
 4024808:	9809883a 	mov	r4,r19
 402480c:	29403fcc 	andi	r5,r5,255
 4024810:	40274140 	call	4027414 <printf>
 4024814:	b14001c3 	ldbu	r5,7(r22)
 4024818:	9809883a 	mov	r4,r19
 402481c:	29403fcc 	andi	r5,r5,255
 4024820:	40274140 	call	4027414 <printf>
	printf("\n");
 4024824:	01000284 	movi	r4,10
 4024828:	40274ac0 	call	40274ac <putchar>
#endif
	return t_des_run;
}
 402482c:	d0a69f17 	ldw	r2,-25988(gp)
 4024830:	dfc00617 	ldw	ra,24(sp)
 4024834:	ddc00517 	ldw	r23,20(sp)
 4024838:	dd800417 	ldw	r22,16(sp)
 402483c:	dd400317 	ldw	r21,12(sp)
 4024840:	dcc00217 	ldw	r19,8(sp)
 4024844:	dc400117 	ldw	r17,4(sp)
 4024848:	dc000017 	ldw	r16,0(sp)
 402484c:	dec00704 	addi	sp,sp,28
 4024850:	f800283a 	ret

04024854 <fir_testbench>:
/* FIR */
//*****//
volatile char sum0[16] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
volatile int co0[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0X0B, 0X0C, 0X0D, 0X0F };
volatile int in0[16] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,	0x0A, 0X0B, 0X0C, 0X0D, 0X0F };
alt_u32 fir_testbench() {
 4024854:	defffb04 	addi	sp,sp,-20
 4024858:	dfc00415 	stw	ra,16(sp)
 402485c:	dd000315 	stw	r20,12(sp)
 4024860:	dcc00215 	stw	r19,8(sp)
 4024864:	dc800115 	stw	r18,4(sp)
 4024868:	dc000015 	stw	r16,0(sp)

	int i, j;
	int N = 16;
	t_fir_run_begin = alt_timestamp();
 402486c:	402b42c0 	call	402b42c <alt_timestamp>
 4024870:	d0a6a115 	stw	r2,-25980(gp)
	EX_BEGIN();
 4024874:	01c10134 	movhi	r7,1028
 4024878:	39c43404 	addi	r7,r7,4304
 402487c:	00803fc4 	movi	r2,255
 4024880:	38800035 	stwio	r2,0(r7)
	sum0[0] = sum0[0] * in0[0];
 4024884:	040100f4 	movhi	r16,1027
 4024888:	84042b04 	addi	r16,r16,4268
 402488c:	80800003 	ldbu	r2,0(r16)
 4024890:	010100f4 	movhi	r4,1027
 4024894:	21371704 	addi	r4,r4,-9124
 4024898:	20c00017 	ldw	r3,0(r4)
 402489c:	10803fcc 	andi	r2,r2,255
 40248a0:	1080201c 	xori	r2,r2,128
 40248a4:	10bfe004 	addi	r2,r2,-128
 40248a8:	10c5383a 	mul	r2,r2,r3
	for (i = 1; i < N; i++) {
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
 40248ac:	014100f4 	movhi	r5,1027
 40248b0:	29770704 	addi	r5,r5,-9188

	int i, j;
	int N = 16;
	t_fir_run_begin = alt_timestamp();
	EX_BEGIN();
	sum0[0] = sum0[0] * in0[0];
 40248b4:	80800005 	stb	r2,0(r16)
	for (i = 1; i < N; i++) {
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
 40248b8:	81800003 	ldbu	r6,0(r16)
 40248bc:	28800117 	ldw	r2,4(r5)
 40248c0:	20c00117 	ldw	r3,4(r4)
 40248c4:	10c5383a 	mul	r2,r2,r3
 40248c8:	1185883a 	add	r2,r2,r6
 40248cc:	80800045 	stb	r2,1(r16)
 40248d0:	81800043 	ldbu	r6,1(r16)
 40248d4:	28800217 	ldw	r2,8(r5)
 40248d8:	20c00217 	ldw	r3,8(r4)
 40248dc:	10c5383a 	mul	r2,r2,r3
 40248e0:	1185883a 	add	r2,r2,r6
 40248e4:	80800085 	stb	r2,2(r16)
 40248e8:	81800083 	ldbu	r6,2(r16)
 40248ec:	28800317 	ldw	r2,12(r5)
 40248f0:	20c00317 	ldw	r3,12(r4)
 40248f4:	10c5383a 	mul	r2,r2,r3
 40248f8:	1185883a 	add	r2,r2,r6
 40248fc:	808000c5 	stb	r2,3(r16)
 4024900:	818000c3 	ldbu	r6,3(r16)
 4024904:	28800417 	ldw	r2,16(r5)
 4024908:	20c00417 	ldw	r3,16(r4)
 402490c:	10c5383a 	mul	r2,r2,r3
 4024910:	1185883a 	add	r2,r2,r6
 4024914:	80800105 	stb	r2,4(r16)
 4024918:	81800103 	ldbu	r6,4(r16)
 402491c:	28800517 	ldw	r2,20(r5)
 4024920:	20c00517 	ldw	r3,20(r4)
 4024924:	10c5383a 	mul	r2,r2,r3
 4024928:	1185883a 	add	r2,r2,r6
 402492c:	80800145 	stb	r2,5(r16)
 4024930:	81800143 	ldbu	r6,5(r16)
 4024934:	28800617 	ldw	r2,24(r5)
 4024938:	20c00617 	ldw	r3,24(r4)
 402493c:	10c5383a 	mul	r2,r2,r3
 4024940:	1185883a 	add	r2,r2,r6
 4024944:	80800185 	stb	r2,6(r16)
 4024948:	81800183 	ldbu	r6,6(r16)
 402494c:	28800717 	ldw	r2,28(r5)
 4024950:	20c00717 	ldw	r3,28(r4)
 4024954:	10c5383a 	mul	r2,r2,r3
 4024958:	1185883a 	add	r2,r2,r6
 402495c:	808001c5 	stb	r2,7(r16)
 4024960:	818001c3 	ldbu	r6,7(r16)
 4024964:	28800817 	ldw	r2,32(r5)
 4024968:	20c00817 	ldw	r3,32(r4)
 402496c:	10c5383a 	mul	r2,r2,r3
 4024970:	1185883a 	add	r2,r2,r6
 4024974:	80800205 	stb	r2,8(r16)
 4024978:	81800203 	ldbu	r6,8(r16)
 402497c:	28800917 	ldw	r2,36(r5)
 4024980:	20c00917 	ldw	r3,36(r4)
 4024984:	10c5383a 	mul	r2,r2,r3
 4024988:	1185883a 	add	r2,r2,r6
 402498c:	80800245 	stb	r2,9(r16)
 4024990:	81800243 	ldbu	r6,9(r16)
 4024994:	28800a17 	ldw	r2,40(r5)
 4024998:	20c00a17 	ldw	r3,40(r4)
 402499c:	10c5383a 	mul	r2,r2,r3
 40249a0:	1185883a 	add	r2,r2,r6
 40249a4:	80800285 	stb	r2,10(r16)
 40249a8:	81800283 	ldbu	r6,10(r16)
 40249ac:	28800b17 	ldw	r2,44(r5)
 40249b0:	20c00b17 	ldw	r3,44(r4)
 40249b4:	10c5383a 	mul	r2,r2,r3
 40249b8:	1185883a 	add	r2,r2,r6
 40249bc:	808002c5 	stb	r2,11(r16)
 40249c0:	818002c3 	ldbu	r6,11(r16)
 40249c4:	28800c17 	ldw	r2,48(r5)
 40249c8:	20c00c17 	ldw	r3,48(r4)
 40249cc:	10c5383a 	mul	r2,r2,r3
 40249d0:	1185883a 	add	r2,r2,r6
 40249d4:	80800305 	stb	r2,12(r16)
 40249d8:	81800303 	ldbu	r6,12(r16)
 40249dc:	28800d17 	ldw	r2,52(r5)
 40249e0:	20c00d17 	ldw	r3,52(r4)
 40249e4:	10c5383a 	mul	r2,r2,r3
 40249e8:	1185883a 	add	r2,r2,r6
 40249ec:	80800345 	stb	r2,13(r16)
 40249f0:	81800343 	ldbu	r6,13(r16)
 40249f4:	28800e17 	ldw	r2,56(r5)
 40249f8:	20c00e17 	ldw	r3,56(r4)
 40249fc:	10c5383a 	mul	r2,r2,r3
 4024a00:	1185883a 	add	r2,r2,r6
 4024a04:	80800385 	stb	r2,14(r16)
 4024a08:	81800383 	ldbu	r6,14(r16)
 4024a0c:	28800f17 	ldw	r2,60(r5)
 4024a10:	20c00f17 	ldw	r3,60(r4)
 4024a14:	10c5383a 	mul	r2,r2,r3
 4024a18:	1185883a 	add	r2,r2,r6
 4024a1c:	808003c5 	stb	r2,15(r16)
	}
	EX_END();
 4024a20:	38000035 	stwio	zero,0(r7)
	for(i = 0; i < 16; i = i + 1)
			sum0[i] = 0;
 4024a24:	80000005 	stb	zero,0(r16)
 4024a28:	80000045 	stb	zero,1(r16)
 4024a2c:	80000085 	stb	zero,2(r16)
 4024a30:	800000c5 	stb	zero,3(r16)
 4024a34:	80000105 	stb	zero,4(r16)
 4024a38:	80000145 	stb	zero,5(r16)
 4024a3c:	80000185 	stb	zero,6(r16)
 4024a40:	800001c5 	stb	zero,7(r16)
 4024a44:	80000205 	stb	zero,8(r16)
 4024a48:	80000245 	stb	zero,9(r16)
 4024a4c:	80000285 	stb	zero,10(r16)
 4024a50:	800002c5 	stb	zero,11(r16)
 4024a54:	80000305 	stb	zero,12(r16)
 4024a58:	80000345 	stb	zero,13(r16)
 4024a5c:	80000385 	stb	zero,14(r16)
 4024a60:	800003c5 	stb	zero,15(r16)
	sum0[0] = sum0[0] * in0[0];
 4024a64:	80800003 	ldbu	r2,0(r16)
 4024a68:	20c00017 	ldw	r3,0(r4)
	t_fir_run_end = alt_timestamp();
	t_fir_run = (t_fir_run_end - t_fir_run_begin) / 3;
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("FIR: ");
	for(i = 0; i < 16; i = i + 1)
		printf("%02x ", sum0[i]);
 4024a6c:	048100f4 	movhi	r18,1027
 4024a70:	94b55604 	addi	r18,r18,-10920
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
	}
	EX_END();
	for(i = 0; i < 16; i = i + 1)
			sum0[i] = 0;
	sum0[0] = sum0[0] * in0[0];
 4024a74:	10803fcc 	andi	r2,r2,255
 4024a78:	1080201c 	xori	r2,r2,128
 4024a7c:	10bfe004 	addi	r2,r2,-128
 4024a80:	10c5383a 	mul	r2,r2,r3
 4024a84:	80800005 	stb	r2,0(r16)
	for (i = 1; i < N; i++) {
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
 4024a88:	81800003 	ldbu	r6,0(r16)
 4024a8c:	28800117 	ldw	r2,4(r5)
 4024a90:	20c00117 	ldw	r3,4(r4)
 4024a94:	10c5383a 	mul	r2,r2,r3
 4024a98:	1185883a 	add	r2,r2,r6
 4024a9c:	80800045 	stb	r2,1(r16)
 4024aa0:	81800043 	ldbu	r6,1(r16)
 4024aa4:	28800217 	ldw	r2,8(r5)
 4024aa8:	20c00217 	ldw	r3,8(r4)
 4024aac:	10c5383a 	mul	r2,r2,r3
 4024ab0:	1185883a 	add	r2,r2,r6
 4024ab4:	80800085 	stb	r2,2(r16)
 4024ab8:	81800083 	ldbu	r6,2(r16)
 4024abc:	28800317 	ldw	r2,12(r5)
 4024ac0:	20c00317 	ldw	r3,12(r4)
 4024ac4:	10c5383a 	mul	r2,r2,r3
 4024ac8:	1185883a 	add	r2,r2,r6
 4024acc:	808000c5 	stb	r2,3(r16)
 4024ad0:	818000c3 	ldbu	r6,3(r16)
 4024ad4:	28800417 	ldw	r2,16(r5)
 4024ad8:	20c00417 	ldw	r3,16(r4)
 4024adc:	10c5383a 	mul	r2,r2,r3
 4024ae0:	1185883a 	add	r2,r2,r6
 4024ae4:	80800105 	stb	r2,4(r16)
 4024ae8:	81800103 	ldbu	r6,4(r16)
 4024aec:	28800517 	ldw	r2,20(r5)
 4024af0:	20c00517 	ldw	r3,20(r4)
 4024af4:	10c5383a 	mul	r2,r2,r3
 4024af8:	1185883a 	add	r2,r2,r6
 4024afc:	80800145 	stb	r2,5(r16)
 4024b00:	81800143 	ldbu	r6,5(r16)
 4024b04:	28800617 	ldw	r2,24(r5)
 4024b08:	20c00617 	ldw	r3,24(r4)
 4024b0c:	10c5383a 	mul	r2,r2,r3
 4024b10:	1185883a 	add	r2,r2,r6
 4024b14:	80800185 	stb	r2,6(r16)
 4024b18:	81800183 	ldbu	r6,6(r16)
 4024b1c:	28800717 	ldw	r2,28(r5)
 4024b20:	20c00717 	ldw	r3,28(r4)
 4024b24:	10c5383a 	mul	r2,r2,r3
 4024b28:	1185883a 	add	r2,r2,r6
 4024b2c:	808001c5 	stb	r2,7(r16)
 4024b30:	818001c3 	ldbu	r6,7(r16)
 4024b34:	28800817 	ldw	r2,32(r5)
 4024b38:	20c00817 	ldw	r3,32(r4)
 4024b3c:	10c5383a 	mul	r2,r2,r3
 4024b40:	1185883a 	add	r2,r2,r6
 4024b44:	80800205 	stb	r2,8(r16)
 4024b48:	81800203 	ldbu	r6,8(r16)
 4024b4c:	28800917 	ldw	r2,36(r5)
 4024b50:	20c00917 	ldw	r3,36(r4)
 4024b54:	10c5383a 	mul	r2,r2,r3
 4024b58:	1185883a 	add	r2,r2,r6
 4024b5c:	80800245 	stb	r2,9(r16)
 4024b60:	81800243 	ldbu	r6,9(r16)
 4024b64:	28800a17 	ldw	r2,40(r5)
 4024b68:	20c00a17 	ldw	r3,40(r4)
 4024b6c:	10c5383a 	mul	r2,r2,r3
 4024b70:	1185883a 	add	r2,r2,r6
 4024b74:	80800285 	stb	r2,10(r16)
 4024b78:	81800283 	ldbu	r6,10(r16)
 4024b7c:	28800b17 	ldw	r2,44(r5)
 4024b80:	20c00b17 	ldw	r3,44(r4)
 4024b84:	10c5383a 	mul	r2,r2,r3
 4024b88:	1185883a 	add	r2,r2,r6
 4024b8c:	808002c5 	stb	r2,11(r16)
 4024b90:	818002c3 	ldbu	r6,11(r16)
 4024b94:	28800c17 	ldw	r2,48(r5)
 4024b98:	20c00c17 	ldw	r3,48(r4)
 4024b9c:	10c5383a 	mul	r2,r2,r3
 4024ba0:	1185883a 	add	r2,r2,r6
 4024ba4:	80800305 	stb	r2,12(r16)
 4024ba8:	81800303 	ldbu	r6,12(r16)
 4024bac:	28800d17 	ldw	r2,52(r5)
 4024bb0:	20c00d17 	ldw	r3,52(r4)
 4024bb4:	10c5383a 	mul	r2,r2,r3
 4024bb8:	1185883a 	add	r2,r2,r6
 4024bbc:	80800345 	stb	r2,13(r16)
 4024bc0:	81800343 	ldbu	r6,13(r16)
 4024bc4:	28800e17 	ldw	r2,56(r5)
 4024bc8:	20c00e17 	ldw	r3,56(r4)
 4024bcc:	10c5383a 	mul	r2,r2,r3
 4024bd0:	1185883a 	add	r2,r2,r6
 4024bd4:	80800385 	stb	r2,14(r16)
 4024bd8:	81800383 	ldbu	r6,14(r16)
 4024bdc:	28800f17 	ldw	r2,60(r5)
 4024be0:	20c00f17 	ldw	r3,60(r4)
 4024be4:	10c5383a 	mul	r2,r2,r3
 4024be8:	1185883a 	add	r2,r2,r6
 4024bec:	808003c5 	stb	r2,15(r16)
	}
	for(i = 0; i < 16; i = i + 1)
		sum0[i] = 0;
 4024bf0:	80000005 	stb	zero,0(r16)
 4024bf4:	80000045 	stb	zero,1(r16)
 4024bf8:	80000085 	stb	zero,2(r16)
 4024bfc:	800000c5 	stb	zero,3(r16)
 4024c00:	80000105 	stb	zero,4(r16)
 4024c04:	80000145 	stb	zero,5(r16)
 4024c08:	80000185 	stb	zero,6(r16)
 4024c0c:	800001c5 	stb	zero,7(r16)
 4024c10:	80000205 	stb	zero,8(r16)
 4024c14:	80000245 	stb	zero,9(r16)
 4024c18:	80000285 	stb	zero,10(r16)
 4024c1c:	800002c5 	stb	zero,11(r16)
 4024c20:	80000305 	stb	zero,12(r16)
 4024c24:	80000345 	stb	zero,13(r16)
 4024c28:	80000385 	stb	zero,14(r16)
 4024c2c:	800003c5 	stb	zero,15(r16)

	sum0[0] = sum0[0] * in0[0];
 4024c30:	80800003 	ldbu	r2,0(r16)
 4024c34:	20c00017 	ldw	r3,0(r4)
 4024c38:	10803fcc 	andi	r2,r2,255
 4024c3c:	1080201c 	xori	r2,r2,128
 4024c40:	10bfe004 	addi	r2,r2,-128
 4024c44:	10c5383a 	mul	r2,r2,r3
 4024c48:	80800005 	stb	r2,0(r16)
	for (i = 1; i < N; i++) {
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
 4024c4c:	81800003 	ldbu	r6,0(r16)
 4024c50:	28800117 	ldw	r2,4(r5)
 4024c54:	20c00117 	ldw	r3,4(r4)
 4024c58:	10c5383a 	mul	r2,r2,r3
 4024c5c:	1185883a 	add	r2,r2,r6
 4024c60:	80800045 	stb	r2,1(r16)
 4024c64:	81800043 	ldbu	r6,1(r16)
 4024c68:	28800217 	ldw	r2,8(r5)
 4024c6c:	20c00217 	ldw	r3,8(r4)
 4024c70:	10c5383a 	mul	r2,r2,r3
 4024c74:	1185883a 	add	r2,r2,r6
 4024c78:	80800085 	stb	r2,2(r16)
 4024c7c:	81800083 	ldbu	r6,2(r16)
 4024c80:	28800317 	ldw	r2,12(r5)
 4024c84:	20c00317 	ldw	r3,12(r4)
 4024c88:	10c5383a 	mul	r2,r2,r3
 4024c8c:	1185883a 	add	r2,r2,r6
 4024c90:	808000c5 	stb	r2,3(r16)
 4024c94:	818000c3 	ldbu	r6,3(r16)
 4024c98:	28800417 	ldw	r2,16(r5)
 4024c9c:	20c00417 	ldw	r3,16(r4)
 4024ca0:	10c5383a 	mul	r2,r2,r3
 4024ca4:	1185883a 	add	r2,r2,r6
 4024ca8:	80800105 	stb	r2,4(r16)
 4024cac:	81800103 	ldbu	r6,4(r16)
 4024cb0:	28800517 	ldw	r2,20(r5)
 4024cb4:	20c00517 	ldw	r3,20(r4)
 4024cb8:	10c5383a 	mul	r2,r2,r3
 4024cbc:	1185883a 	add	r2,r2,r6
 4024cc0:	80800145 	stb	r2,5(r16)
 4024cc4:	81800143 	ldbu	r6,5(r16)
 4024cc8:	28800617 	ldw	r2,24(r5)
 4024ccc:	20c00617 	ldw	r3,24(r4)
 4024cd0:	10c5383a 	mul	r2,r2,r3
 4024cd4:	1185883a 	add	r2,r2,r6
 4024cd8:	80800185 	stb	r2,6(r16)
 4024cdc:	81800183 	ldbu	r6,6(r16)
 4024ce0:	28800717 	ldw	r2,28(r5)
 4024ce4:	20c00717 	ldw	r3,28(r4)
 4024ce8:	10c5383a 	mul	r2,r2,r3
 4024cec:	1185883a 	add	r2,r2,r6
 4024cf0:	808001c5 	stb	r2,7(r16)
 4024cf4:	818001c3 	ldbu	r6,7(r16)
 4024cf8:	28800817 	ldw	r2,32(r5)
 4024cfc:	20c00817 	ldw	r3,32(r4)
 4024d00:	10c5383a 	mul	r2,r2,r3
 4024d04:	1185883a 	add	r2,r2,r6
 4024d08:	80800205 	stb	r2,8(r16)
 4024d0c:	81800203 	ldbu	r6,8(r16)
 4024d10:	28800917 	ldw	r2,36(r5)
 4024d14:	20c00917 	ldw	r3,36(r4)
 4024d18:	10c5383a 	mul	r2,r2,r3
 4024d1c:	1185883a 	add	r2,r2,r6
 4024d20:	80800245 	stb	r2,9(r16)
 4024d24:	81800243 	ldbu	r6,9(r16)
 4024d28:	28800a17 	ldw	r2,40(r5)
 4024d2c:	20c00a17 	ldw	r3,40(r4)
 4024d30:	10c5383a 	mul	r2,r2,r3
 4024d34:	1185883a 	add	r2,r2,r6
 4024d38:	80800285 	stb	r2,10(r16)
 4024d3c:	81800283 	ldbu	r6,10(r16)
 4024d40:	28800b17 	ldw	r2,44(r5)
 4024d44:	20c00b17 	ldw	r3,44(r4)
 4024d48:	10c5383a 	mul	r2,r2,r3
 4024d4c:	1185883a 	add	r2,r2,r6
 4024d50:	808002c5 	stb	r2,11(r16)
 4024d54:	818002c3 	ldbu	r6,11(r16)
 4024d58:	28800c17 	ldw	r2,48(r5)
 4024d5c:	20c00c17 	ldw	r3,48(r4)
 4024d60:	10c5383a 	mul	r2,r2,r3
 4024d64:	1185883a 	add	r2,r2,r6
 4024d68:	80800305 	stb	r2,12(r16)
 4024d6c:	81800303 	ldbu	r6,12(r16)
 4024d70:	28800d17 	ldw	r2,52(r5)
 4024d74:	20c00d17 	ldw	r3,52(r4)
 4024d78:	10c5383a 	mul	r2,r2,r3
 4024d7c:	1185883a 	add	r2,r2,r6
 4024d80:	80800345 	stb	r2,13(r16)
 4024d84:	81800343 	ldbu	r6,13(r16)
 4024d88:	28800e17 	ldw	r2,56(r5)
 4024d8c:	20c00e17 	ldw	r3,56(r4)
 4024d90:	10c5383a 	mul	r2,r2,r3
 4024d94:	1185883a 	add	r2,r2,r6
 4024d98:	80800385 	stb	r2,14(r16)
 4024d9c:	81800383 	ldbu	r6,14(r16)
 4024da0:	28800f17 	ldw	r2,60(r5)
 4024da4:	20c00f17 	ldw	r3,60(r4)
 4024da8:	10c5383a 	mul	r2,r2,r3
 4024dac:	1185883a 	add	r2,r2,r6
 4024db0:	808003c5 	stb	r2,15(r16)
	}

	t_fir_run_end = alt_timestamp();
 4024db4:	402b42c0 	call	402b42c <alt_timestamp>
	t_fir_run = (t_fir_run_end - t_fir_run_begin) / 3;
 4024db8:	d0e6a117 	ldw	r3,-25980(gp)
 4024dbc:	016aaaf4 	movhi	r5,43691
 4024dc0:	296aaac4 	addi	r5,r5,-21845
	sum0[0] = sum0[0] * in0[0];
	for (i = 1; i < N; i++) {
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
	}

	t_fir_run_end = alt_timestamp();
 4024dc4:	d0a6ba15 	stw	r2,-25880(gp)
	t_fir_run = (t_fir_run_end - t_fir_run_begin) / 3;
 4024dc8:	10c7c83a 	sub	r3,r2,r3
 4024dcc:	1968383a 	mulxuu	r20,r3,r5
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("FIR: ");
 4024dd0:	010100f4 	movhi	r4,1027
 4024dd4:	21355804 	addi	r4,r4,-10912
	for (i = 1; i < N; i++) {
		sum0[i] = sum0[i - 1] + co0[i] * in0[i];
	}

	t_fir_run_end = alt_timestamp();
	t_fir_run = (t_fir_run_end - t_fir_run_begin) / 3;
 4024dd8:	a004d07a 	srli	r2,r20,1
 4024ddc:	d0a6ab15 	stw	r2,-25940(gp)
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	printf("FIR: ");
 4024de0:	40274140 	call	4027414 <printf>
	for(i = 0; i < 16; i = i + 1)
		printf("%02x ", sum0[i]);
 4024de4:	81400003 	ldbu	r5,0(r16)
 4024de8:	9009883a 	mov	r4,r18
 4024dec:	29403fcc 	andi	r5,r5,255
 4024df0:	2940201c 	xori	r5,r5,128
 4024df4:	297fe004 	addi	r5,r5,-128
 4024df8:	40274140 	call	4027414 <printf>
 4024dfc:	81400043 	ldbu	r5,1(r16)
 4024e00:	9009883a 	mov	r4,r18
 4024e04:	29403fcc 	andi	r5,r5,255
 4024e08:	2940201c 	xori	r5,r5,128
 4024e0c:	297fe004 	addi	r5,r5,-128
 4024e10:	40274140 	call	4027414 <printf>
 4024e14:	81400083 	ldbu	r5,2(r16)
 4024e18:	9009883a 	mov	r4,r18
 4024e1c:	29403fcc 	andi	r5,r5,255
 4024e20:	2940201c 	xori	r5,r5,128
 4024e24:	297fe004 	addi	r5,r5,-128
 4024e28:	40274140 	call	4027414 <printf>
 4024e2c:	814000c3 	ldbu	r5,3(r16)
 4024e30:	9009883a 	mov	r4,r18
 4024e34:	29403fcc 	andi	r5,r5,255
 4024e38:	2940201c 	xori	r5,r5,128
 4024e3c:	297fe004 	addi	r5,r5,-128
 4024e40:	40274140 	call	4027414 <printf>
 4024e44:	81400103 	ldbu	r5,4(r16)
 4024e48:	9009883a 	mov	r4,r18
 4024e4c:	29403fcc 	andi	r5,r5,255
 4024e50:	2940201c 	xori	r5,r5,128
 4024e54:	297fe004 	addi	r5,r5,-128
 4024e58:	40274140 	call	4027414 <printf>
 4024e5c:	81400143 	ldbu	r5,5(r16)
 4024e60:	9009883a 	mov	r4,r18
 4024e64:	29403fcc 	andi	r5,r5,255
 4024e68:	2940201c 	xori	r5,r5,128
 4024e6c:	297fe004 	addi	r5,r5,-128
 4024e70:	40274140 	call	4027414 <printf>
 4024e74:	81400183 	ldbu	r5,6(r16)
 4024e78:	9009883a 	mov	r4,r18
 4024e7c:	29403fcc 	andi	r5,r5,255
 4024e80:	2940201c 	xori	r5,r5,128
 4024e84:	297fe004 	addi	r5,r5,-128
 4024e88:	40274140 	call	4027414 <printf>
 4024e8c:	814001c3 	ldbu	r5,7(r16)
 4024e90:	9009883a 	mov	r4,r18
 4024e94:	29403fcc 	andi	r5,r5,255
 4024e98:	2940201c 	xori	r5,r5,128
 4024e9c:	297fe004 	addi	r5,r5,-128
 4024ea0:	40274140 	call	4027414 <printf>
 4024ea4:	81400203 	ldbu	r5,8(r16)
 4024ea8:	9009883a 	mov	r4,r18
 4024eac:	29403fcc 	andi	r5,r5,255
 4024eb0:	2940201c 	xori	r5,r5,128
 4024eb4:	297fe004 	addi	r5,r5,-128
 4024eb8:	40274140 	call	4027414 <printf>
 4024ebc:	81400243 	ldbu	r5,9(r16)
 4024ec0:	9009883a 	mov	r4,r18
 4024ec4:	29403fcc 	andi	r5,r5,255
 4024ec8:	2940201c 	xori	r5,r5,128
 4024ecc:	297fe004 	addi	r5,r5,-128
 4024ed0:	40274140 	call	4027414 <printf>
 4024ed4:	81400283 	ldbu	r5,10(r16)
 4024ed8:	9009883a 	mov	r4,r18
 4024edc:	29403fcc 	andi	r5,r5,255
 4024ee0:	2940201c 	xori	r5,r5,128
 4024ee4:	297fe004 	addi	r5,r5,-128
 4024ee8:	40274140 	call	4027414 <printf>
 4024eec:	814002c3 	ldbu	r5,11(r16)
 4024ef0:	9009883a 	mov	r4,r18
 4024ef4:	29403fcc 	andi	r5,r5,255
 4024ef8:	2940201c 	xori	r5,r5,128
 4024efc:	297fe004 	addi	r5,r5,-128
 4024f00:	40274140 	call	4027414 <printf>
 4024f04:	81400303 	ldbu	r5,12(r16)
 4024f08:	9009883a 	mov	r4,r18
 4024f0c:	29403fcc 	andi	r5,r5,255
 4024f10:	2940201c 	xori	r5,r5,128
 4024f14:	297fe004 	addi	r5,r5,-128
 4024f18:	40274140 	call	4027414 <printf>
 4024f1c:	81400343 	ldbu	r5,13(r16)
 4024f20:	9009883a 	mov	r4,r18
 4024f24:	29403fcc 	andi	r5,r5,255
 4024f28:	2940201c 	xori	r5,r5,128
 4024f2c:	297fe004 	addi	r5,r5,-128
 4024f30:	40274140 	call	4027414 <printf>
 4024f34:	81400383 	ldbu	r5,14(r16)
 4024f38:	9009883a 	mov	r4,r18
 4024f3c:	29403fcc 	andi	r5,r5,255
 4024f40:	2940201c 	xori	r5,r5,128
 4024f44:	297fe004 	addi	r5,r5,-128
 4024f48:	40274140 	call	4027414 <printf>
 4024f4c:	814003c3 	ldbu	r5,15(r16)
 4024f50:	9009883a 	mov	r4,r18
 4024f54:	29403fcc 	andi	r5,r5,255
 4024f58:	2940201c 	xori	r5,r5,128
 4024f5c:	297fe004 	addi	r5,r5,-128
 4024f60:	40274140 	call	4027414 <printf>
	printf("\n");
 4024f64:	01000284 	movi	r4,10
 4024f68:	40274ac0 	call	40274ac <putchar>
#endif
	return t_fir_run;
}
 4024f6c:	d0a6ab17 	ldw	r2,-25940(gp)
 4024f70:	dfc00417 	ldw	ra,16(sp)
 4024f74:	dd000317 	ldw	r20,12(sp)
 4024f78:	dcc00217 	ldw	r19,8(sp)
 4024f7c:	dc800117 	ldw	r18,4(sp)
 4024f80:	dc000017 	ldw	r16,0(sp)
 4024f84:	dec00504 	addi	sp,sp,20
 4024f88:	f800283a 	ret

04024f8c <aes_testbench>:

volatile unsigned char key[KEY_128] = "uber strong key!";
volatile unsigned char ptext[16] = "Attack at dawn!";
volatile unsigned char decptext[16];
volatile unsigned char ctext[16];
int aes_testbench() {
 4024f8c:	defffa04 	addi	sp,sp,-24
 4024f90:	dfc00515 	stw	ra,20(sp)
 4024f94:	dd000415 	stw	r20,16(sp)
 4024f98:	dcc00315 	stw	r19,12(sp)
 4024f9c:	dc800215 	stw	r18,8(sp)
 4024fa0:	dc400115 	stw	r17,4(sp)
 4024fa4:	dc000015 	stw	r16,0(sp)
	aes_ctx_t *ctx;

	init_aes();
 4024fa8:	4022b9c0 	call	4022b9c <init_aes>
	ctx = aes_alloc_ctx(key, sizeof(key));
 4024fac:	010100f4 	movhi	r4,1027
 4024fb0:	2136ff04 	addi	r4,r4,-9220
 4024fb4:	01400404 	movi	r5,16
 4024fb8:	402411c0 	call	402411c <aes_alloc_ctx>
 4024fbc:	1029883a 	mov	r20,r2
	if (!ctx) {
 4024fc0:	10008126 	beq	r2,zero,40251c8 <aes_testbench+0x23c>
		return;
	}
	t_aes_run_begin = alt_timestamp();
 4024fc4:	402b42c0 	call	402b42c <alt_timestamp>
 4024fc8:	d0a6b915 	stw	r2,-25884(gp)
	EX_BEGIN();
 4024fcc:	04410134 	movhi	r17,1028
 4024fd0:	8c443404 	addi	r17,r17,4304
 4024fd4:	00803fc4 	movi	r2,255
 4024fd8:	88800035 	stwio	r2,0(r17)
	aes_encrypt(ctx, ptext, ctext);
 4024fdc:	040100f4 	movhi	r16,1027
 4024fe0:	84053d04 	addi	r16,r16,5364
 4024fe4:	a009883a 	mov	r4,r20
 4024fe8:	014100f4 	movhi	r5,1027
 4024fec:	29770304 	addi	r5,r5,-9204
 4024ff0:	800d883a 	mov	r6,r16
 4024ff4:	4022dc80 	call	4022dc8 <aes_encrypt>
	EX_END();
 4024ff8:	88000035 	stwio	zero,0(r17)
	aes_encrypt(ctx, ptext, ctext);
 4024ffc:	800d883a 	mov	r6,r16
 4025000:	a009883a 	mov	r4,r20
 4025004:	014100f4 	movhi	r5,1027
 4025008:	29770304 	addi	r5,r5,-9204
 402500c:	4022dc80 	call	4022dc8 <aes_encrypt>
	aes_encrypt(ctx, ptext, ctext);
 4025010:	800d883a 	mov	r6,r16
 4025014:	a009883a 	mov	r4,r20
 4025018:	014100f4 	movhi	r5,1027
 402501c:	29770304 	addi	r5,r5,-9204
 4025020:	4022dc80 	call	4022dc8 <aes_encrypt>
	t_aes_run_end = alt_timestamp();
 4025024:	402b42c0 	call	402b42c <alt_timestamp>
	t_aes_run = (t_aes_run_end - t_aes_run_begin) / 3;
 4025028:	d0e6b917 	ldw	r3,-25884(gp)
 402502c:	016aaaf4 	movhi	r5,43691
 4025030:	296aaac4 	addi	r5,r5,-21845
	EX_BEGIN();
	aes_encrypt(ctx, ptext, ctext);
	EX_END();
	aes_encrypt(ctx, ptext, ctext);
	aes_encrypt(ctx, ptext, ctext);
	t_aes_run_end = alt_timestamp();
 4025034:	d0a6a915 	stw	r2,-25948(gp)
	t_aes_run = (t_aes_run_end - t_aes_run_begin) / 3;
 4025038:	10c7c83a 	sub	r3,r2,r3
 402503c:	1966383a 	mulxuu	r19,r3,r5
	aes_free_ctx(ctx);
 4025040:	a009883a 	mov	r4,r20
	aes_encrypt(ctx, ptext, ctext);
	EX_END();
	aes_encrypt(ctx, ptext, ctext);
	aes_encrypt(ctx, ptext, ctext);
	t_aes_run_end = alt_timestamp();
	t_aes_run = (t_aes_run_end - t_aes_run_begin) / 3;
 4025044:	9804d07a 	srli	r2,r19,1
 4025048:	d0a6c215 	stw	r2,-25848(gp)
	aes_free_ctx(ctx);
 402504c:	40213580 	call	4021358 <aes_free_ctx>
#if RUN_CPU_TESTS & ~RUN_CPU_ENERGY_TESTS
	int i = 0;
	printf("AES: ");
 4025050:	010100f4 	movhi	r4,1027
 4025054:	21355a04 	addi	r4,r4,-10904
 4025058:	40274140 	call	4027414 <printf>
	for(i = 0; i < 16; i = i + 1)
		printf("%02x ", ctext[i]);
 402505c:	81400003 	ldbu	r5,0(r16)
 4025060:	010100f4 	movhi	r4,1027
 4025064:	21355604 	addi	r4,r4,-10920
 4025068:	29403fcc 	andi	r5,r5,255
 402506c:	40274140 	call	4027414 <printf>
 4025070:	81400043 	ldbu	r5,1(r16)
 4025074:	010100f4 	movhi	r4,1027
 4025078:	21355604 	addi	r4,r4,-10920
 402507c:	29403fcc 	andi	r5,r5,255
 4025080:	40274140 	call	4027414 <printf>
 4025084:	81400083 	ldbu	r5,2(r16)
 4025088:	010100f4 	movhi	r4,1027
 402508c:	21355604 	addi	r4,r4,-10920
 4025090:	29403fcc 	andi	r5,r5,255
 4025094:	40274140 	call	4027414 <printf>
 4025098:	814000c3 	ldbu	r5,3(r16)
 402509c:	010100f4 	movhi	r4,1027
 40250a0:	21355604 	addi	r4,r4,-10920
 40250a4:	29403fcc 	andi	r5,r5,255
 40250a8:	40274140 	call	4027414 <printf>
 40250ac:	81400103 	ldbu	r5,4(r16)
 40250b0:	010100f4 	movhi	r4,1027
 40250b4:	21355604 	addi	r4,r4,-10920
 40250b8:	29403fcc 	andi	r5,r5,255
 40250bc:	40274140 	call	4027414 <printf>
 40250c0:	81400143 	ldbu	r5,5(r16)
 40250c4:	010100f4 	movhi	r4,1027
 40250c8:	21355604 	addi	r4,r4,-10920
 40250cc:	29403fcc 	andi	r5,r5,255
 40250d0:	40274140 	call	4027414 <printf>
 40250d4:	81400183 	ldbu	r5,6(r16)
 40250d8:	010100f4 	movhi	r4,1027
 40250dc:	21355604 	addi	r4,r4,-10920
 40250e0:	29403fcc 	andi	r5,r5,255
 40250e4:	40274140 	call	4027414 <printf>
 40250e8:	814001c3 	ldbu	r5,7(r16)
 40250ec:	010100f4 	movhi	r4,1027
 40250f0:	21355604 	addi	r4,r4,-10920
 40250f4:	29403fcc 	andi	r5,r5,255
 40250f8:	40274140 	call	4027414 <printf>
 40250fc:	81400203 	ldbu	r5,8(r16)
 4025100:	010100f4 	movhi	r4,1027
 4025104:	21355604 	addi	r4,r4,-10920
 4025108:	29403fcc 	andi	r5,r5,255
 402510c:	40274140 	call	4027414 <printf>
 4025110:	81400243 	ldbu	r5,9(r16)
 4025114:	010100f4 	movhi	r4,1027
 4025118:	21355604 	addi	r4,r4,-10920
 402511c:	29403fcc 	andi	r5,r5,255
 4025120:	40274140 	call	4027414 <printf>
 4025124:	81400283 	ldbu	r5,10(r16)
 4025128:	010100f4 	movhi	r4,1027
 402512c:	21355604 	addi	r4,r4,-10920
 4025130:	29403fcc 	andi	r5,r5,255
 4025134:	40274140 	call	4027414 <printf>
 4025138:	814002c3 	ldbu	r5,11(r16)
 402513c:	010100f4 	movhi	r4,1027
 4025140:	21355604 	addi	r4,r4,-10920
 4025144:	29403fcc 	andi	r5,r5,255
 4025148:	40274140 	call	4027414 <printf>
 402514c:	81400303 	ldbu	r5,12(r16)
 4025150:	010100f4 	movhi	r4,1027
 4025154:	21355604 	addi	r4,r4,-10920
 4025158:	29403fcc 	andi	r5,r5,255
 402515c:	40274140 	call	4027414 <printf>
 4025160:	81400343 	ldbu	r5,13(r16)
 4025164:	010100f4 	movhi	r4,1027
 4025168:	21355604 	addi	r4,r4,-10920
 402516c:	29403fcc 	andi	r5,r5,255
 4025170:	40274140 	call	4027414 <printf>
 4025174:	81400383 	ldbu	r5,14(r16)
 4025178:	010100f4 	movhi	r4,1027
 402517c:	21355604 	addi	r4,r4,-10920
 4025180:	29403fcc 	andi	r5,r5,255
 4025184:	40274140 	call	4027414 <printf>
 4025188:	814003c3 	ldbu	r5,15(r16)
 402518c:	010100f4 	movhi	r4,1027
 4025190:	21355604 	addi	r4,r4,-10920
 4025194:	29403fcc 	andi	r5,r5,255
 4025198:	40274140 	call	4027414 <printf>
	printf("\n");
 402519c:	01000284 	movi	r4,10
 40251a0:	40274ac0 	call	40274ac <putchar>
#endif
	return t_aes_run;
}
 40251a4:	d0a6c217 	ldw	r2,-25848(gp)
 40251a8:	dfc00517 	ldw	ra,20(sp)
 40251ac:	dd000417 	ldw	r20,16(sp)
 40251b0:	dcc00317 	ldw	r19,12(sp)
 40251b4:	dc800217 	ldw	r18,8(sp)
 40251b8:	dc400117 	ldw	r17,4(sp)
 40251bc:	dc000017 	ldw	r16,0(sp)
 40251c0:	dec00604 	addi	sp,sp,24
 40251c4:	f800283a 	ret
 40251c8:	dfc00517 	ldw	ra,20(sp)
 40251cc:	dd000417 	ldw	r20,16(sp)
 40251d0:	dcc00317 	ldw	r19,12(sp)
 40251d4:	dc800217 	ldw	r18,8(sp)
 40251d8:	dc400117 	ldw	r17,4(sp)
 40251dc:	dc000017 	ldw	r16,0(sp)
 40251e0:	dec00604 	addi	sp,sp,24
 40251e4:	f800283a 	ret

040251e8 <spi_tx_char>:
void spi_tx_char(short tx_data, long spi_addr)
{
  int ctrlbyte;

/* select spi device #0 */
  IOWR(spi_addr, 5, 1);
 40251e8:	29c00504 	addi	r7,r5,20
 40251ec:	00800044 	movi	r2,1
 40251f0:	28800535 	stwio	r2,20(r5)

/* Assert SS_n */
  ctrlbyte = IORD(spi_addr, 3);
 40251f4:	29800304 	addi	r6,r5,12
 40251f8:	30800037 	ldwio	r2,0(r6)
  IOWR(spi_addr, 3, (ctrlbyte | ALTERA_AVALON_SPI_CONTROL_SSO_MSK));
 40251fc:	10810014 	ori	r2,r2,1024
 4025200:	28800335 	stwio	r2,12(r5)
 4025204:	28c00204 	addi	r3,r5,8

/* Transmit a byte: */
  while (!(IORD(spi_addr, 2) & ALTERA_AVALON_SPI_STATUS_TRDY_MSK));
 4025208:	18800037 	ldwio	r2,0(r3)
 402520c:	1080100c 	andi	r2,r2,64
 4025210:	103ffd26 	beq	r2,zero,4025208 <spi_tx_char+0x20>
  IOWR(spi_addr, 1, tx_data);
 4025214:	20bfffcc 	andi	r2,r4,65535
 4025218:	10a0001c 	xori	r2,r2,32768
 402521c:	10a00004 	addi	r2,r2,-32768
 4025220:	28800135 	stwio	r2,4(r5)

/* Wait until the last byte is transmitted: */
  while (!(IORD(spi_addr, 2) & ALTERA_AVALON_SPI_STATUS_TMT_MSK));
 4025224:	18800037 	ldwio	r2,0(r3)
 4025228:	1080080c 	andi	r2,r2,32
 402522c:	103ffd26 	beq	r2,zero,4025224 <spi_tx_char+0x3c>

/* Release SS_n: */
  IOWR(spi_addr, 3, IORD(spi_addr, 3) & ~ALTERA_AVALON_SPI_CONTROL_SSO_MSK );
 4025230:	30800037 	ldwio	r2,0(r6)
 4025234:	00feffc4 	movi	r3,-1025
 4025238:	10c4703a 	and	r2,r2,r3
 402523c:	30800035 	stwio	r2,0(r6)

/* Deselect all spis: */
  IOWR(spi_addr, 5, 0);
 4025240:	38000035 	stwio	zero,0(r7)

}
 4025244:	f800283a 	ret

04025248 <main>:
	return t_spi_xmit;

}

int main()
{
 4025248:	deffec04 	addi	sp,sp,-80
 402524c:	dfc01315 	stw	ra,76(sp)
 4025250:	df001215 	stw	fp,72(sp)
 4025254:	dcc00d15 	stw	r19,52(sp)
 4025258:	df000a04 	addi	fp,sp,40
 402525c:	dc000a15 	stw	r16,40(sp)
 4025260:	ddc01115 	stw	r23,68(sp)
 4025264:	dd801015 	stw	r22,64(sp)
 4025268:	dd400f15 	stw	r21,60(sp)
 402526c:	dd000e15 	stw	r20,56(sp)
 4025270:	dc800c15 	stw	r18,48(sp)
 4025274:	dc400b15 	stw	r17,44(sp)
	alt_flash_fd * fl_dev;

	alt_u32 sched_tbl_size;
	alt_u32 lut_size;

	alt_timestamp_start();
 4025278:	402b3880 	call	402b388 <alt_timestamp_start>
	t_init = alt_timestamp();
 402527c:	402b42c0 	call	402b42c <alt_timestamp>
 4025280:	d0a6a615 	stw	r2,-25960(gp)
	return t_spi_xmit;

}

int main()
{
 4025284:	e6fffd15 	stw	sp,-12(fp)

	alt_u32 sched_tbl_size;
	alt_u32 lut_size;

	alt_timestamp_start();
	t_init = alt_timestamp();
 4025288:	0021883a 	mov	r16,zero
 402528c:	04c00504 	movi	r19,20
	int oCnt;
	for(oCnt = 0; oCnt < 20; oCnt = oCnt + 1)
	{
		o0 = alt_timestamp();
 4025290:	402b42c0 	call	402b42c <alt_timestamp>
 4025294:	d0a6b215 	stw	r2,-25912(gp)
		o1 = alt_timestamp();
 4025298:	402b42c0 	call	402b42c <alt_timestamp>
		overhead = overhead + (o1 - o0);
 402529c:	d0e6b217 	ldw	r3,-25912(gp)
 40252a0:	d126bf17 	ldw	r4,-25860(gp)
	alt_u32 lut_size;

	alt_timestamp_start();
	t_init = alt_timestamp();
	int oCnt;
	for(oCnt = 0; oCnt < 20; oCnt = oCnt + 1)
 40252a4:	84000044 	addi	r16,r16,1
	{
		o0 = alt_timestamp();
		o1 = alt_timestamp();
		overhead = overhead + (o1 - o0);
 40252a8:	10c7c83a 	sub	r3,r2,r3
 40252ac:	1909883a 	add	r4,r3,r4
	t_init = alt_timestamp();
	int oCnt;
	for(oCnt = 0; oCnt < 20; oCnt = oCnt + 1)
	{
		o0 = alt_timestamp();
		o1 = alt_timestamp();
 40252b0:	d0a69715 	stw	r2,-26020(gp)
		overhead = overhead + (o1 - o0);
 40252b4:	d126bf15 	stw	r4,-25860(gp)
	alt_u32 lut_size;

	alt_timestamp_start();
	t_init = alt_timestamp();
	int oCnt;
	for(oCnt = 0; oCnt < 20; oCnt = oCnt + 1)
 40252b8:	84fff51e 	bne	r16,r19,4025290 <main+0x48>
	{
		o0 = alt_timestamp();
		o1 = alt_timestamp();
		overhead = overhead + (o1 - o0);
	}
	overhead = overhead / 20;
 40252bc:	00b33374 	movhi	r2,52429
 40252c0:	10b33344 	addi	r2,r2,-13107
 40252c4:	20a4383a 	mulxuu	r18,r4,r2
 40252c8:	9008d13a 	srli	r4,r18,4
 40252cc:	d126bf15 	stw	r4,-25860(gp)
	volatile alt_u32 res_fir, res_des, res_aes, res_ci;

	//res_aes = aes_testbench();
	//res_ci = ci_testbench();
	//res_des = des_testbench();
	res_fir = fir_testbench();
 40252d0:	40248540 	call	4024854 <fir_testbench>


	printf("\nTimestamp Driver Overhead Cycles: %i\n\n", overhead);
 40252d4:	d166bf17 	ldw	r5,-25860(gp)
 40252d8:	010100f4 	movhi	r4,1027
 40252dc:	21355c04 	addi	r4,r4,-10896
	volatile alt_u32 res_fir, res_des, res_aes, res_ci;

	//res_aes = aes_testbench();
	//res_ci = ci_testbench();
	//res_des = des_testbench();
	res_fir = fir_testbench();
 40252e0:	e0bff615 	stw	r2,-40(fp)


	printf("\nTimestamp Driver Overhead Cycles: %i\n\n", overhead);
 40252e4:	40274140 	call	4027414 <printf>
	//printf("AES CYCLES: %i\n", t_aes_run - overhead);
	//printf("CI CYCLES: %i\n", t_ci_run - overhead);
	//printf("DES CYCLES: %i\n", t_des_run - overhead);
	printf("FIR CYCLES: %i\n", t_fir_run - overhead);
 40252e8:	d0a6ab17 	ldw	r2,-25940(gp)
 40252ec:	d166bf17 	ldw	r5,-25860(gp)
 40252f0:	010100f4 	movhi	r4,1027
 40252f4:	21356604 	addi	r4,r4,-10856
 40252f8:	114bc83a 	sub	r5,r2,r5
 40252fc:	40274140 	call	4027414 <printf>
#endif


	alt_timestamp();
 4025300:	402b42c0 	call	402b42c <alt_timestamp>
	// init code here
	//

	//**************
	//	OPEN FLASH
	t_fl_open_begin = alt_timestamp();
 4025304:	402b42c0 	call	402b42c <alt_timestamp>
	fl_dev = alt_flash_open_dev(CFI_FLASH_0_NAME);
 4025308:	010100f4 	movhi	r4,1027
 402530c:	21356a04 	addi	r4,r4,-10840
	// init code here
	//

	//**************
	//	OPEN FLASH
	t_fl_open_begin = alt_timestamp();
 4025310:	d0a69915 	stw	r2,-26012(gp)
	fl_dev = alt_flash_open_dev(CFI_FLASH_0_NAME);
 4025314:	40282d40 	call	40282d4 <alt_flash_open_dev>
 4025318:	e0bfff15 	stw	r2,-4(fp)
	t_fl_open_end = alt_timestamp();
 402531c:	402b42c0 	call	402b42c <alt_timestamp>
	t_fl_open = t_fl_open_end - t_fl_open_begin;
 4025320:	d0e69917 	ldw	r3,-26012(gp)

	//**************
	//	OPEN FLASH
	t_fl_open_begin = alt_timestamp();
	fl_dev = alt_flash_open_dev(CFI_FLASH_0_NAME);
	t_fl_open_end = alt_timestamp();
 4025324:	d0a69c15 	stw	r2,-26000(gp)
	t_fl_open = t_fl_open_end - t_fl_open_begin;
 4025328:	10c5c83a 	sub	r2,r2,r3
 402532c:	d0a6bd15 	stw	r2,-25868(gp)
	//
	//**************

	if (fl_dev != NULL)
 4025330:	e0bfff17 	ldw	r2,-4(fp)
 4025334:	1000df26 	beq	r2,zero,40256b4 <main+0x46c>
 */
static __inline__ int __attribute__ ((always_inline)) alt_read_flash( 
                                      alt_flash_fd* fd, int offset, 
                                      void* dest_addr, int length )
{
  return fd->read( fd, offset, dest_addr, length );
 4025338:	10c00617 	ldw	r3,24(r2)
 402533c:	040100f4 	movhi	r16,1027
 4025340:	84053904 	addi	r16,r16,5348
 4025344:	800d883a 	mov	r6,r16
 4025348:	01c00404 	movi	r7,16
 402534c:	000b883a 	mov	r5,zero
 4025350:	1009883a 	mov	r4,r2
 4025354:	183ee83a 	callr	r3
		//
		//**************

		//**************
		//	PARSE HEADER
		t_hdr_parse_begin = alt_timestamp();
 4025358:	402b42c0 	call	402b42c <alt_timestamp>
		sched_tbl_size = mbc_header[10];
		sched_tbl_size = sched_tbl_size << 8;
		sched_tbl_size = sched_tbl_size | mbc_header[11];
		lut_size = mbc_header[13];
 402535c:	80c00343 	ldbu	r3,13(r16)
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[14];
 4025360:	81400383 	ldbu	r5,14(r16)
		//**************

		//**************
		//	PARSE HEADER
		t_hdr_parse_begin = alt_timestamp();
		sched_tbl_size = mbc_header[10];
 4025364:	81000283 	ldbu	r4,10(r16)
		sched_tbl_size = sched_tbl_size << 8;
		sched_tbl_size = sched_tbl_size | mbc_header[11];
		lut_size = mbc_header[13];
		lut_size = lut_size << 8;
 4025368:	1806923a 	slli	r3,r3,8
		//**************
		//	PARSE HEADER
		t_hdr_parse_begin = alt_timestamp();
		sched_tbl_size = mbc_header[10];
		sched_tbl_size = sched_tbl_size << 8;
		sched_tbl_size = sched_tbl_size | mbc_header[11];
 402536c:	838002c3 	ldbu	r14,11(r16)
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[15];
		char kernel_name[9];
		int k = 0;
		for(k = 0; k < 8; k = k + 1){
			kernel_name[k] = mbc_header[k];
 4025370:	82000083 	ldbu	r8,2(r16)
		sched_tbl_size = mbc_header[10];
		sched_tbl_size = sched_tbl_size << 8;
		sched_tbl_size = sched_tbl_size | mbc_header[11];
		lut_size = mbc_header[13];
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[14];
 4025374:	1946b03a 	or	r3,r3,r5
		lut_size = lut_size << 8;
 4025378:	1806923a 	slli	r3,r3,8
		lut_size = lut_size | mbc_header[15];
 402537c:	814003c3 	ldbu	r5,15(r16)
		char kernel_name[9];
		int k = 0;
		for(k = 0; k < 8; k = k + 1){
			kernel_name[k] = mbc_header[k];
 4025380:	824000c3 	ldbu	r9,3(r16)
 4025384:	82800103 	ldbu	r10,4(r16)
 4025388:	82c00143 	ldbu	r11,5(r16)
 402538c:	83000183 	ldbu	r12,6(r16)
 4025390:	834001c3 	ldbu	r13,7(r16)
 4025394:	81800003 	ldbu	r6,0(r16)
 4025398:	81c00043 	ldbu	r7,1(r16)

		//**************
		//	PARSE HEADER
		t_hdr_parse_begin = alt_timestamp();
		sched_tbl_size = mbc_header[10];
		sched_tbl_size = sched_tbl_size << 8;
 402539c:	2008923a 	slli	r4,r4,8
		sched_tbl_size = sched_tbl_size | mbc_header[11];
		lut_size = mbc_header[13];
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[14];
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[15];
 40253a0:	1946b03a 	or	r3,r3,r5
		char kernel_name[9];
		int k = 0;
		for(k = 0; k < 8; k = k + 1){
			kernel_name[k] = mbc_header[k];
 40253a4:	e23ff785 	stb	r8,-34(fp)
		//**************
		//	PARSE HEADER
		t_hdr_parse_begin = alt_timestamp();
		sched_tbl_size = mbc_header[10];
		sched_tbl_size = sched_tbl_size << 8;
		sched_tbl_size = sched_tbl_size | mbc_header[11];
 40253a8:	23a6b03a 	or	r19,r4,r14
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[15];
		char kernel_name[9];
		int k = 0;
		for(k = 0; k < 8; k = k + 1){
			kernel_name[k] = mbc_header[k];
 40253ac:	e27ff7c5 	stb	r9,-33(fp)
 40253b0:	e2bff805 	stb	r10,-32(fp)
 40253b4:	e2fff845 	stb	r11,-31(fp)
 40253b8:	e33ff885 	stb	r12,-30(fp)
 40253bc:	e37ff8c5 	stb	r13,-29(fp)
 40253c0:	e1bff705 	stb	r6,-36(fp)
 40253c4:	e1fff745 	stb	r7,-35(fp)
		sched_tbl_size = sched_tbl_size | mbc_header[11];
		lut_size = mbc_header[13];
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[14];
		lut_size = lut_size << 8;
		lut_size = lut_size | mbc_header[15];
 40253c8:	e0fffa15 	stw	r3,-24(fp)
		//
		//**************

		//**************
		//	PARSE HEADER
		t_hdr_parse_begin = alt_timestamp();
 40253cc:	d0a6a515 	stw	r2,-25964(gp)
		char kernel_name[9];
		int k = 0;
		for(k = 0; k < 8; k = k + 1){
			kernel_name[k] = mbc_header[k];
		}
		kernel_name[8] = '\0';
 40253d0:	e03ff905 	stb	zero,-28(fp)
		t_hdr_parse_end = alt_timestamp();
 40253d4:	402b42c0 	call	402b42c <alt_timestamp>
		t_hdr_parse = t_hdr_parse_end - t_hdr_parse_begin;
 40253d8:	d0e6a517 	ldw	r3,-25964(gp)
		//
		//**************

		printf("\n***BEGIN CONFIG INFO***\n\n");
 40253dc:	010100f4 	movhi	r4,1027
 40253e0:	21356f04 	addi	r4,r4,-10820
		int k = 0;
		for(k = 0; k < 8; k = k + 1){
			kernel_name[k] = mbc_header[k];
		}
		kernel_name[8] = '\0';
		t_hdr_parse_end = alt_timestamp();
 40253e4:	d0a6a015 	stw	r2,-25984(gp)
		t_hdr_parse = t_hdr_parse_end - t_hdr_parse_begin;
 40253e8:	10c5c83a 	sub	r2,r2,r3
 40253ec:	d0a6a715 	stw	r2,-25956(gp)
		//
		//**************

		printf("\n***BEGIN CONFIG INFO***\n\n");
 40253f0:	40275600 	call	4027560 <puts>
		printf("KERNEL NAME: \t%s\n", kernel_name);
 40253f4:	e17ff704 	addi	r5,fp,-36
 40253f8:	010100f4 	movhi	r4,1027
 40253fc:	21357604 	addi	r4,r4,-10792
 4025400:	40274140 	call	4027414 <printf>
		printf("MAHA TARGET: \t0x%02x\n", mbc_header[8]);
 4025404:	81400203 	ldbu	r5,8(r16)
 4025408:	010100f4 	movhi	r4,1027
 402540c:	21357b04 	addi	r4,r4,-10772

#if RC_SCH
		//**************
		//	READ SCHED -- sched immediately follows header
		alt_u32 sched_offset = HEADER_START_ADDR + MBC_HEADER_SIZE;
		alt_u32 num_instr = sched_tbl_size / 4;
 4025410:	9824d0ba 	srli	r18,r19,2
		//
		//**************

		printf("\n***BEGIN CONFIG INFO***\n\n");
		printf("KERNEL NAME: \t%s\n", kernel_name);
		printf("MAHA TARGET: \t0x%02x\n", mbc_header[8]);
 4025414:	40274140 	call	4027414 <printf>
		printf("SCHED TABLE SIZE: \t0x%02x\n", sched_tbl_size);
 4025418:	010100f4 	movhi	r4,1027
 402541c:	21358104 	addi	r4,r4,-10748
 4025420:	980b883a 	mov	r5,r19
 4025424:	40274140 	call	4027414 <printf>
		printf("MLBS CONFIGURED: \t0x%02x\n", mbc_header[12]);
 4025428:	81400303 	ldbu	r5,12(r16)
 402542c:	010100f4 	movhi	r4,1027
 4025430:	21358804 	addi	r4,r4,-10720
	t_fl_open_end = alt_timestamp();
	t_fl_open = t_fl_open_end - t_fl_open_begin;
	//
	//**************

	if (fl_dev != NULL)
 4025434:	e6fffb15 	stw	sp,-20(fp)

		printf("\n***BEGIN CONFIG INFO***\n\n");
		printf("KERNEL NAME: \t%s\n", kernel_name);
		printf("MAHA TARGET: \t0x%02x\n", mbc_header[8]);
		printf("SCHED TABLE SIZE: \t0x%02x\n", sched_tbl_size);
		printf("MLBS CONFIGURED: \t0x%02x\n", mbc_header[12]);
 4025438:	40274140 	call	4027414 <printf>
		printf("LUT SIZE: \t\t0x%02x\n", lut_size);
 402543c:	e17ffa17 	ldw	r5,-24(fp)
 4025440:	010100f4 	movhi	r4,1027
 4025444:	21358f04 	addi	r4,r4,-10692
 4025448:	40274140 	call	4027414 <printf>
		printf("\n***END CONFIG INFO***\n");
 402544c:	010100f4 	movhi	r4,1027
 4025450:	21359404 	addi	r4,r4,-10672
 4025454:	40275600 	call	4027560 <puts>
#if RC_SCH
		//**************
		//	READ SCHED -- sched immediately follows header
		alt_u32 sched_offset = HEADER_START_ADDR + MBC_HEADER_SIZE;
		alt_u32 num_instr = sched_tbl_size / 4;
		alt_u32 sched_buf[num_instr]; // sched tbl stored in bytes, but we want 32b vals
 4025458:	9487883a 	add	r3,r18,r18
 402545c:	18c7883a 	add	r3,r3,r3
 4025460:	008000b4 	movhi	r2,2
 4025464:	10bfff04 	addi	r2,r2,-4
 4025468:	18c00184 	addi	r3,r3,6
 402546c:	1886703a 	and	r3,r3,r2
 4025470:	d8f7c83a 	sub	sp,sp,r3
		t_sch_rd_begin = alt_timestamp();
 4025474:	402b42c0 	call	402b42c <alt_timestamp>
 4025478:	e13fff17 	ldw	r4,-4(fp)
 402547c:	01400404 	movi	r5,16
 4025480:	d80d883a 	mov	r6,sp
 4025484:	20c00617 	ldw	r3,24(r4)
 4025488:	980f883a 	mov	r7,r19
 402548c:	d0a6b715 	stw	r2,-25892(gp)
 4025490:	183ee83a 	callr	r3
		alt_read_flash(fl_dev, sched_offset, sched_buf, sched_tbl_size);
		t_sch_rd_end = alt_timestamp();
 4025494:	402b42c0 	call	402b42c <alt_timestamp>
		t_sch_rd = t_sch_rd_end - t_sch_rd_begin;
 4025498:	d0e6b717 	ldw	r3,-25892(gp)
		alt_u32 sched_offset = HEADER_START_ADDR + MBC_HEADER_SIZE;
		alt_u32 num_instr = sched_tbl_size / 4;
		alt_u32 sched_buf[num_instr]; // sched tbl stored in bytes, but we want 32b vals
		t_sch_rd_begin = alt_timestamp();
		alt_read_flash(fl_dev, sched_offset, sched_buf, sched_tbl_size);
		t_sch_rd_end = alt_timestamp();
 402549c:	d0a69415 	stw	r2,-26032(gp)
#if RC_SCH
		//**************
		//	READ SCHED -- sched immediately follows header
		alt_u32 sched_offset = HEADER_START_ADDR + MBC_HEADER_SIZE;
		alt_u32 num_instr = sched_tbl_size / 4;
		alt_u32 sched_buf[num_instr]; // sched tbl stored in bytes, but we want 32b vals
 40254a0:	d821883a 	mov	r16,sp
		t_sch_rd_begin = alt_timestamp();
		alt_read_flash(fl_dev, sched_offset, sched_buf, sched_tbl_size);
		t_sch_rd_end = alt_timestamp();
		t_sch_rd = t_sch_rd_end - t_sch_rd_begin;
 40254a4:	10c5c83a 	sub	r2,r2,r3
 40254a8:	d0a6c115 	stw	r2,-25852(gp)

		//**************
		//	WRITE SCHED
		int addr = 0;
		int temp = 0;
		for(addr = 0; addr < num_instr; addr = addr + 1)
 40254ac:	90001026 	beq	r18,zero,40254f0 <main+0x2a8>
 40254b0:	0023883a 	mov	r17,zero
		{
			t_sch_cfg_begin = alt_timestamp();
 40254b4:	402b42c0 	call	402b42c <alt_timestamp>
			temp = addr | SCH_CFG;
			MBC_CFG_MEM(temp, sched_buf[addr]);
 40254b8:	81000017 	ldw	r4,0(r16)
 40254bc:	88c01034 	orhi	r3,r17,64
		//	WRITE SCHED
		int addr = 0;
		int temp = 0;
		for(addr = 0; addr < num_instr; addr = addr + 1)
		{
			t_sch_cfg_begin = alt_timestamp();
 40254c0:	d0a6aa15 	stw	r2,-25944(gp)
			temp = addr | SCH_CFG;
			MBC_CFG_MEM(temp, sched_buf[addr]);
 40254c4:	1907c072 	custom	1,r3,r3,r4
			t_sch_cfg_end = alt_timestamp();
 40254c8:	402b42c0 	call	402b42c <alt_timestamp>
			t_sch_cfg = t_sch_cfg + (t_sch_cfg_end - t_sch_cfg_begin);
 40254cc:	d126aa17 	ldw	r4,-25944(gp)
 40254d0:	d0e6c017 	ldw	r3,-25856(gp)

		//**************
		//	WRITE SCHED
		int addr = 0;
		int temp = 0;
		for(addr = 0; addr < num_instr; addr = addr + 1)
 40254d4:	8c400044 	addi	r17,r17,1
		{
			t_sch_cfg_begin = alt_timestamp();
			temp = addr | SCH_CFG;
			MBC_CFG_MEM(temp, sched_buf[addr]);
			t_sch_cfg_end = alt_timestamp();
			t_sch_cfg = t_sch_cfg + (t_sch_cfg_end - t_sch_cfg_begin);
 40254d8:	1109c83a 	sub	r4,r2,r4
 40254dc:	1907883a 	add	r3,r3,r4
 40254e0:	d0e6c015 	stw	r3,-25856(gp)
		for(addr = 0; addr < num_instr; addr = addr + 1)
		{
			t_sch_cfg_begin = alt_timestamp();
			temp = addr | SCH_CFG;
			MBC_CFG_MEM(temp, sched_buf[addr]);
			t_sch_cfg_end = alt_timestamp();
 40254e4:	d0a69815 	stw	r2,-26016(gp)

		//**************
		//	WRITE SCHED
		int addr = 0;
		int temp = 0;
		for(addr = 0; addr < num_instr; addr = addr + 1)
 40254e8:	84000104 	addi	r16,r16,4
 40254ec:	947ff11e 	bne	r18,r17,40254b4 <main+0x26c>
 40254f0:	e53ffa17 	ldw	r20,-24(fp)
 40254f4:	00880004 	movi	r2,8192
 40254f8:	15006c36 	bltu	r2,r20,40256ac <main+0x464>
			lut_buf_size = FL_MAX_BUF_SIZE;
		else
			lut_buf_size = lut_size;

		// this should be 1 if lut_size < FL_MAX_BUF_SIZE otherwise basically ceiling function.
		alt_u32 fl_reads = 1 + (lut_size / FL_MAX_BUF_SIZE);
 40254fc:	e0bffa17 	ldw	r2,-24(fp)
		alt_u8 lut_buf[lut_buf_size];
 4025500:	00c08034 	movhi	r3,512
 4025504:	18ffff04 	addi	r3,r3,-4
			lut_buf_size = FL_MAX_BUF_SIZE;
		else
			lut_buf_size = lut_size;

		// this should be 1 if lut_size < FL_MAX_BUF_SIZE otherwise basically ceiling function.
		alt_u32 fl_reads = 1 + (lut_size / FL_MAX_BUF_SIZE);
 4025508:	1004d37a 	srli	r2,r2,13
 402550c:	e0bffc15 	stw	r2,-16(fp)
 4025510:	e13ffc17 	ldw	r4,-16(fp)
		alt_u8 lut_buf[lut_buf_size];
 4025514:	a0800184 	addi	r2,r20,6
 4025518:	10c4703a 	and	r2,r2,r3
 402551c:	d8b7c83a 	sub	sp,sp,r2
			lut_buf_size = FL_MAX_BUF_SIZE;
		else
			lut_buf_size = lut_size;

		// this should be 1 if lut_size < FL_MAX_BUF_SIZE otherwise basically ceiling function.
		alt_u32 fl_reads = 1 + (lut_size / FL_MAX_BUF_SIZE);
 4025520:	21000044 	addi	r4,r4,1
 4025524:	e13ffe15 	stw	r4,-8(fp)
		alt_u8 lut_buf[lut_buf_size];
 4025528:	d82b883a 	mov	r21,sp
		int cRead = 0;
		int lut_entry = 0;
		for (cRead = 0; cRead < fl_reads; cRead = cRead + 1)
 402552c:	20003526 	beq	r4,zero,4025604 <main+0x3bc>
#endif

#if RC_LUT
		//**************
		//	READ LUT - LUT follows sched tbl in memory
		alt_u32 lut_offset = sched_offset + sched_tbl_size;
 4025530:	9d800404 	addi	r22,r19,16
 4025534:	002f883a 	mov	r23,zero
 4025538:	0021883a 	mov	r16,zero
		int cRead = 0;
		int lut_entry = 0;
		for (cRead = 0; cRead < fl_reads; cRead = cRead + 1)
		{
			// read from lut_offset
			t_lut_rd_begin = alt_timestamp();
 402553c:	402b42c0 	call	402b42c <alt_timestamp>
 4025540:	e13fff17 	ldw	r4,-4(fp)
 4025544:	b00b883a 	mov	r5,r22
 4025548:	a80d883a 	mov	r6,r21
 402554c:	20c00617 	ldw	r3,24(r4)
 4025550:	a00f883a 	mov	r7,r20
 4025554:	d0a6ad15 	stw	r2,-25932(gp)
 4025558:	183ee83a 	callr	r3
			alt_read_flash(fl_dev, lut_offset, lut_buf, lut_buf_size);
			t_lut_rd_end = alt_timestamp();
 402555c:	402b42c0 	call	402b42c <alt_timestamp>
			t_lut_rd = t_lut_rd + (t_lut_rd_end - t_lut_rd_begin); // increment total time
 4025560:	d126ad17 	ldw	r4,-25932(gp)
 4025564:	d0e69b17 	ldw	r3,-26004(gp)
		for (cRead = 0; cRead < fl_reads; cRead = cRead + 1)
		{
			// read from lut_offset
			t_lut_rd_begin = alt_timestamp();
			alt_read_flash(fl_dev, lut_offset, lut_buf, lut_buf_size);
			t_lut_rd_end = alt_timestamp();
 4025568:	d0a6b415 	stw	r2,-25904(gp)
			t_lut_rd = t_lut_rd + (t_lut_rd_end - t_lut_rd_begin); // increment total time
 402556c:	1105c83a 	sub	r2,r2,r4
 4025570:	1887883a 	add	r3,r3,r2
			}
#endif
			// configure LUT memory with buffered data
			// on all but the last loop the # entries to write = lut_buf_size
			// on last loop there will be variable # entries to write (between 1 and lut_buf_size - 1)
			if(cRead == fl_reads - 1)
 4025574:	e0bffc17 	ldw	r2,-16(fp)
		{
			// read from lut_offset
			t_lut_rd_begin = alt_timestamp();
			alt_read_flash(fl_dev, lut_offset, lut_buf, lut_buf_size);
			t_lut_rd_end = alt_timestamp();
			t_lut_rd = t_lut_rd + (t_lut_rd_end - t_lut_rd_begin); // increment total time
 4025578:	d0e69b15 	stw	r3,-26004(gp)
			}
#endif
			// configure LUT memory with buffered data
			// on all but the last loop the # entries to write = lut_buf_size
			// on last loop there will be variable # entries to write (between 1 and lut_buf_size - 1)
			if(cRead == fl_reads - 1)
 402557c:	14001c26 	beq	r2,r16,40255f0 <main+0x3a8>
 4025580:	a025883a 	mov	r18,r20
				lut_entries_read = (lut_size % lut_buf_size);
			else
				lut_entries_read = lut_buf_size;
			alt_u32 addr;
			for(lut_entry = 0; lut_entry < lut_entries_read; lut_entry = lut_entry + 1)
 4025584:	90001426 	beq	r18,zero,40255d8 <main+0x390>
 4025588:	a427383a 	mul	r19,r20,r16
 402558c:	0023883a 	mov	r17,zero
 4025590:	0021883a 	mov	r16,zero
			{
				addr = ((cRead * lut_buf_size) + lut_entry) | LUT_CFG;
				t_lut_cfg_begin = alt_timestamp();
 4025594:	402b42c0 	call	402b42c <alt_timestamp>
				MBC_CFG_MEM(addr, lut_buf[lut_entry]);
 4025598:	ac09883a 	add	r4,r21,r16
 402559c:	21400003 	ldbu	r5,0(r4)
 40255a0:	9c47883a 	add	r3,r19,r17
 40255a4:	18c00834 	orhi	r3,r3,32
				lut_entries_read = lut_buf_size;
			alt_u32 addr;
			for(lut_entry = 0; lut_entry < lut_entries_read; lut_entry = lut_entry + 1)
			{
				addr = ((cRead * lut_buf_size) + lut_entry) | LUT_CFG;
				t_lut_cfg_begin = alt_timestamp();
 40255a8:	d0a69e15 	stw	r2,-25992(gp)
				MBC_CFG_MEM(addr, lut_buf[lut_entry]);
 40255ac:	1947c072 	custom	1,r3,r3,r5
				t_lut_cfg_end = alt_timestamp();
 40255b0:	402b42c0 	call	402b42c <alt_timestamp>
				t_lut_cfg = t_lut_cfg + (t_lut_cfg_end - t_lut_cfg_begin);
 40255b4:	d1269e17 	ldw	r4,-25992(gp)
 40255b8:	d0e69a17 	ldw	r3,-26008(gp)
			if(cRead == fl_reads - 1)
				lut_entries_read = (lut_size % lut_buf_size);
			else
				lut_entries_read = lut_buf_size;
			alt_u32 addr;
			for(lut_entry = 0; lut_entry < lut_entries_read; lut_entry = lut_entry + 1)
 40255bc:	84000044 	addi	r16,r16,1
			{
				addr = ((cRead * lut_buf_size) + lut_entry) | LUT_CFG;
				t_lut_cfg_begin = alt_timestamp();
				MBC_CFG_MEM(addr, lut_buf[lut_entry]);
				t_lut_cfg_end = alt_timestamp();
				t_lut_cfg = t_lut_cfg + (t_lut_cfg_end - t_lut_cfg_begin);
 40255c0:	1109c83a 	sub	r4,r2,r4
 40255c4:	1907883a 	add	r3,r3,r4
 40255c8:	d0e69a15 	stw	r3,-26008(gp)
			for(lut_entry = 0; lut_entry < lut_entries_read; lut_entry = lut_entry + 1)
			{
				addr = ((cRead * lut_buf_size) + lut_entry) | LUT_CFG;
				t_lut_cfg_begin = alt_timestamp();
				MBC_CFG_MEM(addr, lut_buf[lut_entry]);
				t_lut_cfg_end = alt_timestamp();
 40255cc:	d0a6bb15 	stw	r2,-25876(gp)
			if(cRead == fl_reads - 1)
				lut_entries_read = (lut_size % lut_buf_size);
			else
				lut_entries_read = lut_buf_size;
			alt_u32 addr;
			for(lut_entry = 0; lut_entry < lut_entries_read; lut_entry = lut_entry + 1)
 40255d0:	8023883a 	mov	r17,r16
 40255d4:	84bfef1e 	bne	r16,r18,4025594 <main+0x34c>
		// this should be 1 if lut_size < FL_MAX_BUF_SIZE otherwise basically ceiling function.
		alt_u32 fl_reads = 1 + (lut_size / FL_MAX_BUF_SIZE);
		alt_u8 lut_buf[lut_buf_size];
		int cRead = 0;
		int lut_entry = 0;
		for (cRead = 0; cRead < fl_reads; cRead = cRead + 1)
 40255d8:	e13ffe17 	ldw	r4,-8(fp)
 40255dc:	bdc00044 	addi	r23,r23,1
 40255e0:	b821883a 	mov	r16,r23
 40255e4:	b9000726 	beq	r23,r4,4025604 <main+0x3bc>
				t_lut_cfg_end = alt_timestamp();
				t_lut_cfg = t_lut_cfg + (t_lut_cfg_end - t_lut_cfg_begin);
			}

			// increment offset
			lut_offset = lut_offset + lut_buf_size;
 40255e8:	b52d883a 	add	r22,r22,r20
 40255ec:	003fd306 	br	402553c <main+0x2f4>
#endif
			// configure LUT memory with buffered data
			// on all but the last loop the # entries to write = lut_buf_size
			// on last loop there will be variable # entries to write (between 1 and lut_buf_size - 1)
			if(cRead == fl_reads - 1)
				lut_entries_read = (lut_size % lut_buf_size);
 40255f0:	e13ffa17 	ldw	r4,-24(fp)
 40255f4:	a00b883a 	mov	r5,r20
 40255f8:	402669c0 	call	402669c <__umodsi3>
 40255fc:	1025883a 	mov	r18,r2
 4025600:	003fe006 	br	4025584 <main+0x33c>
		}
#endif
		// everything should be configured by now, so run the kernel(s)
#if !RUN_CPU_ENERGY_TESTS
		alt_u32 res_mbc;
		printf("MBC\n");
 4025604:	010100f4 	movhi	r4,1027
 4025608:	21359a04 	addi	r4,r4,-10648
 402560c:	40275600 	call	4027560 <puts>
		int m = 0;
		for(m = 0; m < 1; m = m + 1)
		{
			printf("%i:\t", m);
 4025610:	000b883a 	mov	r5,zero
 4025614:	010100f4 	movhi	r4,1027
 4025618:	21359b04 	addi	r4,r4,-10644
 402561c:	40274140 	call	4027414 <printf>
	return t_des_run;
}
#endif

int mbc_testbench(){
	t_mbc_run_begin = alt_timestamp();
 4025620:	402b42c0 	call	402b42c <alt_timestamp>
 4025624:	d0a6bc15 	stw	r2,-25872(gp)
	EX_BEGIN();
 4025628:	00c10134 	movhi	r3,1028
 402562c:	18c43404 	addi	r3,r3,4304
 4025630:	00803fc4 	movi	r2,255
 4025634:	18800035 	stwio	r2,0(r3)
	MBC_START();
 4025638:	0009c032 	custom	0,r4,zero,zero
	EX_END();
 402563c:	18000035 	stwio	zero,0(r3)
	t_mbc_run_end = alt_timestamp();
 4025640:	402b42c0 	call	402b42c <alt_timestamp>
	t_mbc_run = (t_mbc_run_end - t_mbc_run_begin);
 4025644:	d0e6bc17 	ldw	r3,-25872(gp)
		for(m = 0; m < 1; m = m + 1)
		{
			printf("%i:\t", m);
			res_mbc = mbc_testbench();
		//	measure_power();
			printf("\t%i\n", res_mbc - overhead);
 4025648:	d166bf17 	ldw	r5,-25860(gp)
 402564c:	010100f4 	movhi	r4,1027
 4025650:	21359d04 	addi	r4,r4,-10636
	t_mbc_run_begin = alt_timestamp();
	EX_BEGIN();
	MBC_START();
	EX_END();
	t_mbc_run_end = alt_timestamp();
	t_mbc_run = (t_mbc_run_end - t_mbc_run_begin);
 4025654:	10c7c83a 	sub	r3,r2,r3
		for(m = 0; m < 1; m = m + 1)
		{
			printf("%i:\t", m);
			res_mbc = mbc_testbench();
		//	measure_power();
			printf("\t%i\n", res_mbc - overhead);
 4025658:	194bc83a 	sub	r5,r3,r5
	t_mbc_run_begin = alt_timestamp();
	EX_BEGIN();
	MBC_START();
	EX_END();
	t_mbc_run_end = alt_timestamp();
	t_mbc_run = (t_mbc_run_end - t_mbc_run_begin);
 402565c:	d0e6b515 	stw	r3,-25900(gp)
int mbc_testbench(){
	t_mbc_run_begin = alt_timestamp();
	EX_BEGIN();
	MBC_START();
	EX_END();
	t_mbc_run_end = alt_timestamp();
 4025660:	d0a6a815 	stw	r2,-25952(gp)
		for(m = 0; m < 1; m = m + 1)
		{
			printf("%i:\t", m);
			res_mbc = mbc_testbench();
		//	measure_power();
			printf("\t%i\n", res_mbc - overhead);
 4025664:	40274140 	call	4027414 <printf>
			alt_timestamp_start();
 4025668:	402b3880 	call	402b388 <alt_timestamp_start>
 402566c:	e6fffb17 	ldw	sp,-20(fp)
#if PROFILING
	print_times();
#endif

  return 0;
}
 4025670:	e6fffd17 	ldw	sp,-12(fp)
 4025674:	0005883a 	mov	r2,zero
 4025678:	e037883a 	mov	sp,fp
 402567c:	dfc00917 	ldw	ra,36(sp)
 4025680:	df000817 	ldw	fp,32(sp)
 4025684:	ddc00717 	ldw	r23,28(sp)
 4025688:	dd800617 	ldw	r22,24(sp)
 402568c:	dd400517 	ldw	r21,20(sp)
 4025690:	dd000417 	ldw	r20,16(sp)
 4025694:	dcc00317 	ldw	r19,12(sp)
 4025698:	dc800217 	ldw	r18,8(sp)
 402569c:	dc400117 	ldw	r17,4(sp)
 40256a0:	dc000017 	ldw	r16,0(sp)
 40256a4:	dec00a04 	addi	sp,sp,40
 40256a8:	f800283a 	ret

		//**************
		//	WRITE SCHED
		int addr = 0;
		int temp = 0;
		for(addr = 0; addr < num_instr; addr = addr + 1)
 40256ac:	1029883a 	mov	r20,r2
 40256b0:	003f9206 	br	40254fc <main+0x2b4>
			alt_timestamp_start();
		}
#endif

	} else {
		printf("\n***Flash access NOT successful!***\n");
 40256b4:	010100f4 	movhi	r4,1027
 40256b8:	21359f04 	addi	r4,r4,-10628
 40256bc:	40275600 	call	4027560 <puts>
 40256c0:	003feb06 	br	4025670 <main+0x428>

040256c4 <reset_power_tick>:
    return bSuccess;
 }
int tick = 0;
void reset_power_tick()
{
	tick = 0;
 40256c4:	d026c515 	stw	zero,-25836(gp)
}
 40256c8:	f800283a 	ret

040256cc <POWER_SPI_RW>:
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock


// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN, bool bSGL, alt_u32 *pValue)
{
 40256cc:	defff704 	addi	sp,sp,-36
    const int nMaxWait = 1000000;
    
    //
    Config8 = 0x80; 
    Config8 |= (bEN)?0x20:0x00;
    Config8 |= (bSGL)?0x10:0x00;
 40256d0:	d8800917 	ldw	r2,36(sp)
    int i, nWait = 0, nZeroCnt;
    const int nMaxWait = 1000000;
    
    //
    Config8 = 0x80; 
    Config8 |= (bEN)?0x20:0x00;
 40256d4:	300cc03a 	cmpne	r6,r6,zero
    Config8 |= (bSGL)?0x10:0x00;
    Config8 |= (bSIGN)?0x08:0x00;
 40256d8:	380ec03a 	cmpne	r7,r7,zero
    const int nMaxWait = 1000000;
    
    //
    Config8 = 0x80; 
    Config8 |= (bEN)?0x20:0x00;
    Config8 |= (bSGL)?0x10:0x00;
 40256dc:	1004c03a 	cmpne	r2,r2,zero
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock


// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN, bool bSGL, alt_u32 *pValue)
{
 40256e0:	dcc00315 	stw	r19,12(sp)
 40256e4:	dc800215 	stw	r18,8(sp)
 40256e8:	dc400115 	stw	r17,4(sp)
    const int nMaxWait = 1000000;
    
    //
    Config8 = 0x80; 
    Config8 |= (bEN)?0x20:0x00;
    Config8 |= (bSGL)?0x10:0x00;
 40256ec:	1024913a 	slli	r18,r2,4
    int i, nWait = 0, nZeroCnt;
    const int nMaxWait = 1000000;
    
    //
    Config8 = 0x80; 
    Config8 |= (bEN)?0x20:0x00;
 40256f0:	3026917a 	slli	r19,r6,5
    Config8 |= (bSGL)?0x10:0x00;
    Config8 |= (bSIGN)?0x08:0x00;
 40256f4:	382290fa 	slli	r17,r7,3
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock


// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN, bool bSGL, alt_u32 *pValue)
{
 40256f8:	dc000015 	stw	r16,0(sp)
    Config8 |= (bEN)?0x20:0x00;
    Config8 |= (bSGL)?0x10:0x00;
    Config8 |= (bSIGN)?0x08:0x00;
    Config8 |= NextChannel & 0x07; // channel
    
    SPI_FO(0); // use internal conversion clock
 40256fc:	00810134 	movhi	r2,1028
 4025700:	10842004 	addi	r2,r2,4224
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock


// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN, bool bSGL, alt_u32 *pValue)
{
 4025704:	2821883a 	mov	r16,r5
 4025708:	dfc00815 	stw	ra,32(sp)
 402570c:	ddc00715 	stw	r23,28(sp)
 4025710:	dd800615 	stw	r22,24(sp)
 4025714:	dd400515 	stw	r21,20(sp)
 4025718:	dd000415 	stw	r20,16(sp)
    Config8 |= (bEN)?0x20:0x00;
    Config8 |= (bSGL)?0x10:0x00;
    Config8 |= (bSIGN)?0x08:0x00;
    Config8 |= NextChannel & 0x07; // channel
    
    SPI_FO(0); // use internal conversion clock
 402571c:	10000035 	stwio	zero,0(r2)
    SPI_SCK(0);  // set low to active extenal serial clock mode.
 4025720:	00c10134 	movhi	r3,1028
 4025724:	18c43004 	addi	r3,r3,4288
 4025728:	18000035 	stwio	zero,0(r3)
    SPI_CS_N(IcIndex, 0);  // chip select: active
 402572c:	21003fcc 	andi	r4,r4,255
 4025730:	00800084 	movi	r2,2
 4025734:	2008c03a 	cmpne	r4,r4,zero
 4025738:	1109c83a 	sub	r4,r2,r4
 402573c:	18fff404 	addi	r3,r3,-48
 4025740:	19000035 	stwio	r4,0(r3)
    SPI_DELAY;
 4025744:	010003c4 	movi	r4,15
 4025748:	40285e80 	call	40285e8 <usleep>
 402574c:	05410134 	movhi	r21,1028
 4025750:	ad442c04 	addi	r21,r21,4272
 4025754:	0007883a 	mov	r3,zero
 4025758:	05800044 	movi	r22,1
 402575c:	010003f4 	movhi	r4,15
 4025760:	21109004 	addi	r4,r4,16960
 4025764:	00000206 	br	4025770 <POWER_SPI_RW+0xa4>
    
    // wait for converion end (when conversion done, SPI_SDO is low)
    while(SPI_SDO && nWait < nMaxWait){
 4025768:	19000526 	beq	r3,r4,4025780 <POWER_SPI_RW+0xb4>
        nWait++;
 402576c:	18c00044 	addi	r3,r3,1
    SPI_SCK(0);  // set low to active extenal serial clock mode.
    SPI_CS_N(IcIndex, 0);  // chip select: active
    SPI_DELAY;
    
    // wait for converion end (when conversion done, SPI_SDO is low)
    while(SPI_SDO && nWait < nMaxWait){
 4025770:	a8800037 	ldwio	r2,0(r21)
 4025774:	1080004c 	andi	r2,r2,1
 4025778:	1005003a 	cmpeq	r2,r2,zero
 402577c:	103ffa26 	beq	r2,zero,4025768 <POWER_SPI_RW+0x9c>
        nWait++;
    }
    
    if (SPI_SDO){
 4025780:	a8800037 	ldwio	r2,0(r21)
 4025784:	1080004c 	andi	r2,r2,1
 4025788:	1005003a 	cmpeq	r2,r2,zero
 402578c:	10009b26 	beq	r2,zero,40259fc <POWER_SPI_RW+0x330>
    //
    Config8 = 0x80; 
    Config8 |= (bEN)?0x20:0x00;
    Config8 |= (bSGL)?0x10:0x00;
    Config8 |= (bSIGN)?0x08:0x00;
    Config8 |= NextChannel & 0x07; // channel
 4025790:	00bfe004 	movi	r2,-128
 4025794:	9884b03a 	or	r2,r19,r2
 4025798:	1484b03a 	or	r2,r2,r18
 402579c:	1444b03a 	or	r2,r2,r17
 40257a0:	840001cc 	andi	r16,r16,7
 40257a4:	80a0b03a 	or	r16,r16,r2
    }
    
    for(i=0;i<2;i++) // send config bits 7:6,
    // ignore EOC/ and DMY bits
    {
        SPI_SDI((Config8 & 0x80)?1:0);//sdi=nextch.7; // put data on pin
 40257a8:	80c03fcc 	andi	r3,r16,255
 40257ac:	18c0201c 	xori	r3,r3,128
 40257b0:	18ffe004 	addi	r3,r3,-128
 40257b4:	1806d7fa 	srli	r3,r3,31
 40257b8:	05010134 	movhi	r20,1028
 40257bc:	a5042804 	addi	r20,r20,4256
 40257c0:	a0c00035 	stwio	r3,0(r20)
        Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
 40257c4:	8421883a 	add	r16,r16,r16
        Value32 <<= 1;//result_0 = rl(result_0);// get ready to load lsb
        Value32 |= SPI_SDO;//result_0.0 = sdo; // load lsb
 40257c8:	ac800037 	ldwio	r18,0(r21)
        
        SPI_SCK(1);//sck=1; // clock high
 40257cc:	04c10134 	movhi	r19,1028
 40257d0:	9cc43004 	addi	r19,r19,4288
 40257d4:	9d800035 	stwio	r22,0(r19)
        SPI_DELAY;
 40257d8:	010003c4 	movi	r4,15
 40257dc:	40285e80 	call	40285e8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
 40257e0:	98000035 	stwio	zero,0(r19)
    }
    
    for(i=0;i<2;i++) // send config bits 7:6,
    // ignore EOC/ and DMY bits
    {
        SPI_SDI((Config8 & 0x80)?1:0);//sdi=nextch.7; // put data on pin
 40257e4:	84403fcc 	andi	r17,r16,255
 40257e8:	8c40201c 	xori	r17,r17,128
 40257ec:	8c7fe004 	addi	r17,r17,-128
 40257f0:	8822d7fa 	srli	r17,r17,31
        Value32 |= SPI_SDO;//result_0.0 = sdo; // load lsb
        
        SPI_SCK(1);//sck=1; // clock high
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
 40257f4:	010003c4 	movi	r4,15
 40257f8:	40285e80 	call	40285e8 <usleep>
    }
    
    for(i=0;i<2;i++) // send config bits 7:6,
    // ignore EOC/ and DMY bits
    {
        SPI_SDI((Config8 & 0x80)?1:0);//sdi=nextch.7; // put data on pin
 40257fc:	a4400035 	stwio	r17,0(r20)
        Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
        Value32 <<= 1;//result_0 = rl(result_0);// get ready to load lsb
 4025800:	9480004c 	andi	r18,r18,1
 4025804:	94a5883a 	add	r18,r18,r18
    
    for(i=0;i<2;i++) // send config bits 7:6,
    // ignore EOC/ and DMY bits
    {
        SPI_SDI((Config8 & 0x80)?1:0);//sdi=nextch.7; // put data on pin
        Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
 4025808:	8421883a 	add	r16,r16,r16
        Value32 <<= 1;//result_0 = rl(result_0);// get ready to load lsb
        Value32 |= SPI_SDO;//result_0.0 = sdo; // load lsb
 402580c:	a8800037 	ldwio	r2,0(r21)
 4025810:	1080004c 	andi	r2,r2,1
 4025814:	90a4b03a 	or	r18,r18,r2
        
        SPI_SCK(1);//sck=1; // clock high
 4025818:	9d800035 	stwio	r22,0(r19)
        SPI_DELAY;
 402581c:	010003c4 	movi	r4,15
 4025820:	40285e80 	call	40285e8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
 4025824:	98000035 	stwio	zero,0(r19)
        SPI_DELAY;
 4025828:	010003c4 	movi	r4,15
 402582c:	a02f883a 	mov	r23,r20
 4025830:	40285e80 	call	40285e8 <usleep>
 4025834:	0023883a 	mov	r17,zero
 4025838:	05810134 	movhi	r22,1028
 402583c:	b5842c04 	addi	r22,r22,4272
 4025840:	05000044 	movi	r20,1
 4025844:	05400204 	movi	r21,8
    }
    
    for(i=0;i<8;i++) // send config, read byte 3
    {
        SPI_SDI((Config8 & 0x80)?1:0);//sdi=nextch.7; // put data on pin
 4025848:	80803fcc 	andi	r2,r16,255
 402584c:	1080201c 	xori	r2,r2,128
 4025850:	10bfe004 	addi	r2,r2,-128
 4025854:	1004d7fa 	srli	r2,r2,31
 4025858:	b8800035 	stwio	r2,0(r23)
        Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
        
        Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
 402585c:	9487883a 	add	r3,r18,r18
    }
    
    for(i=0;i<8;i++) // send config, read byte 3
    {
        SPI_SDI((Config8 & 0x80)?1:0);//sdi=nextch.7; // put data on pin
        Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
 4025860:	8421883a 	add	r16,r16,r16
        
        Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
        Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
 4025864:	b0800037 	ldwio	r2,0(r22)
 4025868:	1080004c 	andi	r2,r2,1
 402586c:	18a4b03a 	or	r18,r3,r2
        
        SPI_SCK(1);//sck=1; // clock high
 4025870:	9d000035 	stwio	r20,0(r19)
        SPI_DELAY;
 4025874:	010003c4 	movi	r4,15
 4025878:	40285e80 	call	40285e8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
 402587c:	98000035 	stwio	zero,0(r19)
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // send config, read byte 3
 4025880:	8c400044 	addi	r17,r17,1
        Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
        
        SPI_SCK(1);//sck=1; // clock high
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
 4025884:	010003c4 	movi	r4,15
 4025888:	40285e80 	call	40285e8 <usleep>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // send config, read byte 3
 402588c:	8d7fee1e 	bne	r17,r21,4025848 <POWER_SPI_RW+0x17c>
 4025890:	0021883a 	mov	r16,zero
 4025894:	05410134 	movhi	r21,1028
 4025898:	ad442c04 	addi	r21,r21,4272
 402589c:	05000044 	movi	r20,1
 40258a0:	04410134 	movhi	r17,1028
 40258a4:	8c443004 	addi	r17,r17,4288
 40258a8:	04c00204 	movi	r19,8
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // read byte 2
    {
        Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
 40258ac:	9487883a 	add	r3,r18,r18
        Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
 40258b0:	a8800037 	ldwio	r2,0(r21)
 40258b4:	1080004c 	andi	r2,r2,1
 40258b8:	18a4b03a 	or	r18,r3,r2
        
        SPI_SCK(1);//sck=1; // clock high
 40258bc:	8d000035 	stwio	r20,0(r17)
        SPI_DELAY;
 40258c0:	010003c4 	movi	r4,15
 40258c4:	40285e80 	call	40285e8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
 40258c8:	88000035 	stwio	zero,0(r17)
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // read byte 2
 40258cc:	84000044 	addi	r16,r16,1
        Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
        
        SPI_SCK(1);//sck=1; // clock high
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
 40258d0:	010003c4 	movi	r4,15
 40258d4:	40285e80 	call	40285e8 <usleep>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // read byte 2
 40258d8:	84fff41e 	bne	r16,r19,40258ac <POWER_SPI_RW+0x1e0>
 40258dc:	0021883a 	mov	r16,zero
 40258e0:	05410134 	movhi	r21,1028
 40258e4:	ad442c04 	addi	r21,r21,4272
 40258e8:	05000044 	movi	r20,1
 40258ec:	04410134 	movhi	r17,1028
 40258f0:	8c443004 	addi	r17,r17,4288
 40258f4:	04c00204 	movi	r19,8
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // read byte 1
    {
        Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
 40258f8:	9487883a 	add	r3,r18,r18
        Value32 |= SPI_SDO;//result_1.0 = sdo; // load lsb
 40258fc:	a8800037 	ldwio	r2,0(r21)
 4025900:	1080004c 	andi	r2,r2,1
 4025904:	18a4b03a 	or	r18,r3,r2
        
        SPI_SCK(1);//sck=1; // clock high
 4025908:	8d000035 	stwio	r20,0(r17)
        SPI_DELAY;
 402590c:	010003c4 	movi	r4,15
 4025910:	40285e80 	call	40285e8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
 4025914:	88000035 	stwio	zero,0(r17)
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // read byte 1
 4025918:	84000044 	addi	r16,r16,1
        Value32 |= SPI_SDO;//result_1.0 = sdo; // load lsb
        
        SPI_SCK(1);//sck=1; // clock high
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
 402591c:	010003c4 	movi	r4,15
 4025920:	40285e80 	call	40285e8 <usleep>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<8;i++) // read byte 1
 4025924:	84fff41e 	bne	r16,r19,40258f8 <POWER_SPI_RW+0x22c>
 4025928:	0021883a 	mov	r16,zero
 402592c:	05410134 	movhi	r21,1028
 4025930:	ad442c04 	addi	r21,r21,4272
 4025934:	05000044 	movi	r20,1
 4025938:	04410134 	movhi	r17,1028
 402593c:	8c443004 	addi	r17,r17,4288
 4025940:	04c00184 	movi	r19,6
        SPI_DELAY;
    }
    
    for(i=0;i<6;i++) // read byte 0
    {
        Value32 <<= 1;//result_0 = rl(result_0);// get ready to load lsb
 4025944:	9487883a 	add	r3,r18,r18
        Value32 |= SPI_SDO;//result_0.0 = sdo; // load lsb
 4025948:	a8800037 	ldwio	r2,0(r21)
 402594c:	1080004c 	andi	r2,r2,1
 4025950:	18a4b03a 	or	r18,r3,r2
        
        SPI_SCK(1);//sck=1; // clock high
 4025954:	8d000035 	stwio	r20,0(r17)
        SPI_DELAY;
 4025958:	010003c4 	movi	r4,15
 402595c:	40285e80 	call	40285e8 <usleep>
        SPI_SCK(0);//sck=0; // clock low
 4025960:	88000035 	stwio	zero,0(r17)
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<6;i++) // read byte 0
 4025964:	84000044 	addi	r16,r16,1
        Value32 |= SPI_SDO;//result_0.0 = sdo; // load lsb
        
        SPI_SCK(1);//sck=1; // clock high
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
 4025968:	010003c4 	movi	r4,15
 402596c:	40285e80 	call	40285e8 <usleep>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    
    for(i=0;i<6;i++) // read byte 0
 4025970:	84fff41e 	bne	r16,r19,4025944 <POWER_SPI_RW+0x278>
        SPI_SCK(1);//sck=1; // clock high
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }
    SPI_SCK(1);
 4025974:	8d000035 	stwio	r20,0(r17)
    SPI_DELAY;
 4025978:	010003c4 	movi	r4,15
 402597c:	40285e80 	call	40285e8 <usleep>
    SPI_CS_N(IcIndex, 1);  // chip select: inactive
 4025980:	00c000c4 	movi	r3,3
 4025984:	00810134 	movhi	r2,1028
 4025988:	10842404 	addi	r2,r2,4240
 402598c:	10c00035 	stwio	r3,0(r2)
 4025990:	00c00044 	movi	r3,1
 4025994:	0009883a 	mov	r4,zero
 4025998:	000b883a 	mov	r5,zero
 402599c:	01800804 	movi	r6,32
    
    // check parity
    nZeroCnt = 0;
    Mask32 = 0x01;
    for(i=0;i<32;i++){
        if ((Value32 & Mask32) == 0x00){
 40259a0:	90c4703a 	and	r2,r18,r3
    SPI_CS_N(IcIndex, 1);  // chip select: inactive
    
    // check parity
    nZeroCnt = 0;
    Mask32 = 0x01;
    for(i=0;i<32;i++){
 40259a4:	21000044 	addi	r4,r4,1
        if ((Value32 & Mask32) == 0x00){
            nZeroCnt++;
        }
        Mask32 <<= 1;
 40259a8:	18c7883a 	add	r3,r3,r3
    
    // check parity
    nZeroCnt = 0;
    Mask32 = 0x01;
    for(i=0;i<32;i++){
        if ((Value32 & Mask32) == 0x00){
 40259ac:	1000011e 	bne	r2,zero,40259b4 <POWER_SPI_RW+0x2e8>
            nZeroCnt++;
 40259b0:	29400044 	addi	r5,r5,1
    SPI_CS_N(IcIndex, 1);  // chip select: inactive
    
    // check parity
    nZeroCnt = 0;
    Mask32 = 0x01;
    for(i=0;i<32;i++){
 40259b4:	21bffa1e 	bne	r4,r6,40259a0 <POWER_SPI_RW+0x2d4>
        if ((Value32 & Mask32) == 0x00){
            nZeroCnt++;
        }
        Mask32 <<= 1;
    }
    bSuccess = (nZeroCnt&0x01)?FALSE:TRUE;
 40259b8:	2880004c 	andi	r2,r5,1
 40259bc:	1005003a 	cmpeq	r2,r2,zero
 40259c0:	10000326 	beq	r2,zero,40259d0 <POWER_SPI_RW+0x304>
//        printf("Parity Check Error \r\n");
        return FALSE;
    }        
    
    
    *pValue = Value32;
 40259c4:	d8800a17 	ldw	r2,40(sp)
 40259c8:	14800015 	stw	r18,0(r2)
 40259cc:	00800044 	movi	r2,1
    
    return bSuccess;
}
 40259d0:	dfc00817 	ldw	ra,32(sp)
 40259d4:	ddc00717 	ldw	r23,28(sp)
 40259d8:	dd800617 	ldw	r22,24(sp)
 40259dc:	dd400517 	ldw	r21,20(sp)
 40259e0:	dd000417 	ldw	r20,16(sp)
 40259e4:	dcc00317 	ldw	r19,12(sp)
 40259e8:	dc800217 	ldw	r18,8(sp)
 40259ec:	dc400117 	ldw	r17,4(sp)
 40259f0:	dc000017 	ldw	r16,0(sp)
 40259f4:	dec00904 	addi	sp,sp,36
 40259f8:	f800283a 	ret
    while(SPI_SDO && nWait < nMaxWait){
        nWait++;
    }
    
    if (SPI_SDO){
        SPI_CS_N(IcIndex, 1);  // chip select: inactive
 40259fc:	00c000c4 	movi	r3,3
 4025a00:	00810134 	movhi	r2,1028
 4025a04:	10842404 	addi	r2,r2,4240
 4025a08:	10c00035 	stwio	r3,0(r2)
 4025a0c:	0005883a 	mov	r2,zero
 4025a10:	003fef06 	br	40259d0 <POWER_SPI_RW+0x304>

04025a14 <POWER_Read>:
    *pValue = Value32;
    
    return bSuccess;
}

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]){
 4025a14:	defff204 	addi	sp,sp,-56
    bool bSuccess = TRUE;
    int i,c, nPortIndex=0;
    int szPortNum[] = {POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM};
 4025a18:	00800204 	movi	r2,8
 4025a1c:	00c00104 	movi	r3,4
    *pValue = Value32;
    
    return bSuccess;
}

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]){
 4025a20:	ddc00c15 	stw	r23,48(sp)
 4025a24:	dd800b15 	stw	r22,44(sp)
 4025a28:	dd400a15 	stw	r21,40(sp)
 4025a2c:	dd000915 	stw	r20,36(sp)
 4025a30:	dfc00d15 	stw	ra,52(sp)
 4025a34:	dcc00815 	stw	r19,32(sp)
 4025a38:	dc800715 	stw	r18,28(sp)
 4025a3c:	dc400615 	stw	r17,24(sp)
 4025a40:	dc000515 	stw	r16,20(sp)
    bool bSuccess = TRUE;
    int i,c, nPortIndex=0;
    int szPortNum[] = {POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM};
 4025a44:	d8800315 	stw	r2,12(sp)
 4025a48:	d8c00415 	stw	r3,16(sp)
    *pValue = Value32;
    
    return bSuccess;
}

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]){
 4025a4c:	202f883a 	mov	r23,r4
    bool bSuccess = TRUE;
    int i,c, nPortIndex=0;
    int szPortNum[] = {POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM};
 4025a50:	002b883a 	mov	r21,zero
 4025a54:	0029883a 	mov	r20,zero
 4025a58:	dd800304 	addi	r22,sp,12
    const bool bEN=TRUE; // alwasy update next conversion channel
    const bool bSIGN=TRUE; // VolDrop = CH1-CH0
    const bool bSGL=FALSE; // GSGL=FALSE: Diff
    for(c=0;c<POWER_DEVICE_NUM && bSuccess;c = c + 1){
        NextChannel = 0;
        bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
 4025a5c:	01800044 	movi	r6,1
 4025a60:	a009883a 	mov	r4,r20
 4025a64:	000b883a 	mov	r5,zero
 4025a68:	300f883a 	mov	r7,r6
 4025a6c:	d8000015 	stw	zero,0(sp)
 4025a70:	ddc00115 	stw	r23,4(sp)
 4025a74:	40256cc0 	call	40256cc <POWER_SPI_RW>
        for(i=0;i<szPortNum[c] && bSuccess;i = i + 1){
 4025a78:	b4c00017 	ldw	r19,0(r22)
    const bool bEN=TRUE; // alwasy update next conversion channel
    const bool bSIGN=TRUE; // VolDrop = CH1-CH0
    const bool bSGL=FALSE; // GSGL=FALSE: Diff
    for(c=0;c<POWER_DEVICE_NUM && bSuccess;c = c + 1){
        NextChannel = 0;
        bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
 4025a7c:	1021883a 	mov	r16,r2
        for(i=0;i<szPortNum[c] && bSuccess;i = i + 1){
 4025a80:	04c01c0e 	bge	zero,r19,4025af4 <POWER_Read+0xe0>
 4025a84:	10001b26 	beq	r2,zero,4025af4 <POWER_Read+0xe0>
 4025a88:	04800044 	movi	r18,1
            NextChannel = i + 1;
            bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
 4025a8c:	04400044 	movi	r17,1
 4025a90:	91403fcc 	andi	r5,r18,255
 4025a94:	d8800204 	addi	r2,sp,8
 4025a98:	a009883a 	mov	r4,r20
 4025a9c:	880d883a 	mov	r6,r17
 4025aa0:	880f883a 	mov	r7,r17
 4025aa4:	d8000015 	stw	zero,0(sp)
 4025aa8:	d8800115 	stw	r2,4(sp)
 4025aac:	40256cc0 	call	40256cc <POWER_SPI_RW>
 4025ab0:	1021883a 	mov	r16,r2
    const bool bSIGN=TRUE; // VolDrop = CH1-CH0
    const bool bSGL=FALSE; // GSGL=FALSE: Diff
    for(c=0;c<POWER_DEVICE_NUM && bSuccess;c = c + 1){
        NextChannel = 0;
        bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
        for(i=0;i<szPortNum[c] && bSuccess;i = i + 1){
 4025ab4:	917fffc4 	addi	r5,r18,-1
            NextChannel = i + 1;
            bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
            if (bSuccess){
 4025ab8:	10001f26 	beq	r2,zero,4025b38 <POWER_Read+0x124>
                HEAD = (Value32 >> 30) & 0x03;
 4025abc:	d8c00217 	ldw	r3,8(sp)
                Channel = (Value32 >> 1) & 0x07;
                SIGN = (Value32 >> 4 ) & 0x01;
                SGL = (Value32 >> 5 ) & 0x01;
                PARITY = Value32 & 0x01;
                if (HEAD != 0){
 4025ac0:	1804d7ba 	srli	r2,r3,30
 4025ac4:	1000281e 	bne	r2,zero,4025b68 <POWER_Read+0x154>
                    printf("[%d]Unexpected HEAD\r\n",i);
                    bSuccess = FALSE;
                }else if (Channel != i){
 4025ac8:	1804d07a 	srli	r2,r3,1
 4025acc:	11c001cc 	andi	r7,r2,7
 4025ad0:	29c01d26 	beq	r5,r7,4025b48 <POWER_Read+0x134>
                    printf("[%d]Unexpected Channel. Expected:%d, Read:%d\r\n", i, i, Channel);
 4025ad4:	010100f4 	movhi	r4,1027
 4025ad8:	2135ae04 	addi	r4,r4,-10568
 4025adc:	280d883a 	mov	r6,r5
 4025ae0:	40274140 	call	4027414 <printf>
                    bSuccess = FALSE;
                }else if (SIGN ^ bSIGN){
                    printf("[%d]Unexpected SIGN\r\n",i);
 4025ae4:	0021883a 	mov	r16,zero
    const bool bSIGN=TRUE; // VolDrop = CH1-CH0
    const bool bSGL=FALSE; // GSGL=FALSE: Diff
    for(c=0;c<POWER_DEVICE_NUM && bSuccess;c = c + 1){
        NextChannel = 0;
        bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
        for(i=0;i<szPortNum[c] && bSuccess;i = i + 1){
 4025ae8:	94c00226 	beq	r18,r19,4025af4 <POWER_Read+0xe0>
 4025aec:	94800044 	addi	r18,r18,1
 4025af0:	803fe61e 	bne	r16,zero,4025a8c <POWER_Read+0x78>
    alt_u32 Value32;
    alt_u8 NextChannel,Channel, HEAD, SIGN, SGL, PARITY;
    const bool bEN=TRUE; // alwasy update next conversion channel
    const bool bSIGN=TRUE; // VolDrop = CH1-CH0
    const bool bSGL=FALSE; // GSGL=FALSE: Diff
    for(c=0;c<POWER_DEVICE_NUM && bSuccess;c = c + 1){
 4025af4:	a5000044 	addi	r20,r20,1
 4025af8:	00800084 	movi	r2,2
 4025afc:	a0800226 	beq	r20,r2,4025b08 <POWER_Read+0xf4>
 4025b00:	b5800104 	addi	r22,r22,4
 4025b04:	803fd51e 	bne	r16,zero,4025a5c <POWER_Read+0x48>
                printf("SPI Read Error\r\n");
            }
        } // for i
    } // for c
    return bSuccess;
 }
 4025b08:	8005883a 	mov	r2,r16
 4025b0c:	dfc00d17 	ldw	ra,52(sp)
 4025b10:	ddc00c17 	ldw	r23,48(sp)
 4025b14:	dd800b17 	ldw	r22,44(sp)
 4025b18:	dd400a17 	ldw	r21,40(sp)
 4025b1c:	dd000917 	ldw	r20,36(sp)
 4025b20:	dcc00817 	ldw	r19,32(sp)
 4025b24:	dc800717 	ldw	r18,28(sp)
 4025b28:	dc400617 	ldw	r17,24(sp)
 4025b2c:	dc000517 	ldw	r16,20(sp)
 4025b30:	dec00e04 	addi	sp,sp,56
 4025b34:	f800283a 	ret
                    bSuccess = FALSE;
                }
                if (bSuccess)
                    szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
            }else{
                printf("SPI Read Error\r\n");
 4025b38:	010100f4 	movhi	r4,1027
 4025b3c:	2135c004 	addi	r4,r4,-10496
 4025b40:	40275600 	call	4027560 <puts>
 4025b44:	003fe806 	br	4025ae8 <POWER_Read+0xd4>
                    printf("[%d]Unexpected HEAD\r\n",i);
                    bSuccess = FALSE;
                }else if (Channel != i){
                    printf("[%d]Unexpected Channel. Expected:%d, Read:%d\r\n", i, i, Channel);
                    bSuccess = FALSE;
                }else if (SIGN ^ bSIGN){
 4025b48:	1804d13a 	srli	r2,r3,4
 4025b4c:	1100004c 	andi	r4,r2,1
 4025b50:	24400a26 	beq	r4,r17,4025b7c <POWER_Read+0x168>
                    printf("[%d]Unexpected SIGN\r\n",i);
 4025b54:	010100f4 	movhi	r4,1027
 4025b58:	2135ba04 	addi	r4,r4,-10520
 4025b5c:	40274140 	call	4027414 <printf>
 4025b60:	0021883a 	mov	r16,zero
 4025b64:	003fe006 	br	4025ae8 <POWER_Read+0xd4>
                Channel = (Value32 >> 1) & 0x07;
                SIGN = (Value32 >> 4 ) & 0x01;
                SGL = (Value32 >> 5 ) & 0x01;
                PARITY = Value32 & 0x01;
                if (HEAD != 0){
                    printf("[%d]Unexpected HEAD\r\n",i);
 4025b68:	010100f4 	movhi	r4,1027
 4025b6c:	2135a804 	addi	r4,r4,-10592
 4025b70:	40274140 	call	4027414 <printf>
                    bSuccess = FALSE;
                }else if (Channel != i){
                    printf("[%d]Unexpected Channel. Expected:%d, Read:%d\r\n", i, i, Channel);
                    bSuccess = FALSE;
                }else if (SIGN ^ bSIGN){
                    printf("[%d]Unexpected SIGN\r\n",i);
 4025b74:	0021883a 	mov	r16,zero
 4025b78:	003fdb06 	br	4025ae8 <POWER_Read+0xd4>
                }else if (SGL ^ SGL){
                    printf("[%d]Unexpected SGL\r\n",i);
                    bSuccess = FALSE;
                }
                if (bSuccess)
                    szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
 4025b7c:	ad45883a 	add	r2,r21,r21
 4025b80:	1085883a 	add	r2,r2,r2
 4025b84:	15c5883a 	add	r2,r2,r23
 4025b88:	a92b883a 	add	r21,r21,r4
 4025b8c:	10c00015 	stw	r3,0(r2)
 4025b90:	003fd506 	br	4025ae8 <POWER_Read+0xd4>

04025b94 <measure_power>:
void reset_power_tick()
{
	tick = 0;
}
void measure_power()
 {
 4025b94:	deff2804 	addi	sp,sp,-864
 4025b98:	dd00d515 	stw	r20,852(sp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] =
			{ 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3, 2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };
 4025b9c:	dd001104 	addi	r20,sp,68
 4025ba0:	a009883a 	mov	r4,r20
 4025ba4:	000b883a 	mov	r5,zero
 4025ba8:	0180c004 	movi	r6,768
void reset_power_tick()
{
	tick = 0;
}
void measure_power()
 {
 4025bac:	dfc0d715 	stw	ra,860(sp)
 4025bb0:	dd40d615 	stw	r21,856(sp)
 4025bb4:	dcc0d415 	stw	r19,848(sp)
 4025bb8:	dc80d315 	stw	r18,844(sp)
 4025bbc:	dc40d215 	stw	r17,840(sp)
 4025bc0:	dc00d115 	stw	r16,836(sp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] =
			{ 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3, 2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };
 4025bc4:	40273f40 	call	40273f4 <memset>
 4025bc8:	00c100f4 	movhi	r3,1027
 4025bcc:	18f5e904 	addi	r3,r3,-10332
 4025bd0:	1a000203 	ldbu	r8,8(r3)
 4025bd4:	19c00117 	ldw	r7,4(r3)
 4025bd8:	18800017 	ldw	r2,0(r3)
 4025bdc:	d9001344 	addi	r4,sp,77
 4025be0:	000b883a 	mov	r5,zero
 4025be4:	01800dc4 	movi	r6,55
 4025be8:	d9c01215 	stw	r7,72(sp)
 4025bec:	da001305 	stb	r8,76(sp)
 4025bf0:	d8801115 	stw	r2,68(sp)
 4025bf4:	40273f40 	call	40273f4 <memset>
 4025bf8:	00c100f4 	movhi	r3,1027
 4025bfc:	18f5f904 	addi	r3,r3,-10268
 4025c00:	1a000183 	ldbu	r8,6(r3)
 4025c04:	19c0010b 	ldhu	r7,4(r3)
 4025c08:	18800017 	ldw	r2,0(r3)
 4025c0c:	d90022c4 	addi	r4,sp,139
 4025c10:	000b883a 	mov	r5,zero
 4025c14:	01800e44 	movi	r6,57
 4025c18:	d9c0220d 	sth	r7,136(sp)
 4025c1c:	da002285 	stb	r8,138(sp)
 4025c20:	d8802115 	stw	r2,132(sp)
 4025c24:	40273f40 	call	40273f4 <memset>
 4025c28:	00c100f4 	movhi	r3,1027
 4025c2c:	18f60904 	addi	r3,r3,-10204
 4025c30:	1a400303 	ldbu	r9,12(r3)
 4025c34:	19c00117 	ldw	r7,4(r3)
 4025c38:	1a000217 	ldw	r8,8(r3)
 4025c3c:	18800017 	ldw	r2,0(r3)
 4025c40:	d9003444 	addi	r4,sp,209
 4025c44:	000b883a 	mov	r5,zero
 4025c48:	01800cc4 	movi	r6,51
 4025c4c:	da403405 	stb	r9,208(sp)
 4025c50:	d9c03215 	stw	r7,200(sp)
 4025c54:	da003315 	stw	r8,204(sp)
 4025c58:	d8803115 	stw	r2,196(sp)
 4025c5c:	40273f40 	call	40273f4 <memset>
 4025c60:	00c100f4 	movhi	r3,1027
 4025c64:	18f61904 	addi	r3,r3,-10140
 4025c68:	1a000183 	ldbu	r8,6(r3)
 4025c6c:	19c0010b 	ldhu	r7,4(r3)
 4025c70:	18800017 	ldw	r2,0(r3)
 4025c74:	d90042c4 	addi	r4,sp,267
 4025c78:	000b883a 	mov	r5,zero
 4025c7c:	01800e44 	movi	r6,57
 4025c80:	d9c0420d 	sth	r7,264(sp)
 4025c84:	da004285 	stb	r8,266(sp)
 4025c88:	d8804115 	stw	r2,260(sp)
 4025c8c:	40273f40 	call	40273f4 <memset>
 4025c90:	00c100f4 	movhi	r3,1027
 4025c94:	18f62904 	addi	r3,r3,-10076
 4025c98:	1a400283 	ldbu	r9,10(r3)
 4025c9c:	19c00117 	ldw	r7,4(r3)
 4025ca0:	1a00020b 	ldhu	r8,8(r3)
 4025ca4:	18800017 	ldw	r2,0(r3)
 4025ca8:	d90053c4 	addi	r4,sp,335
 4025cac:	000b883a 	mov	r5,zero
 4025cb0:	01800d44 	movi	r6,53
 4025cb4:	d9c05215 	stw	r7,328(sp)
 4025cb8:	da00530d 	sth	r8,332(sp)
 4025cbc:	da405385 	stb	r9,334(sp)
 4025cc0:	d8805115 	stw	r2,324(sp)
 4025cc4:	40273f40 	call	40273f4 <memset>
 4025cc8:	00c100f4 	movhi	r3,1027
 4025ccc:	18f63904 	addi	r3,r3,-10012
 4025cd0:	1a400283 	ldbu	r9,10(r3)
 4025cd4:	19c00117 	ldw	r7,4(r3)
 4025cd8:	1a00020b 	ldhu	r8,8(r3)
 4025cdc:	18800017 	ldw	r2,0(r3)
 4025ce0:	d90063c4 	addi	r4,sp,399
 4025ce4:	000b883a 	mov	r5,zero
 4025ce8:	01800d44 	movi	r6,53
 4025cec:	d9c06215 	stw	r7,392(sp)
 4025cf0:	da00630d 	sth	r8,396(sp)
 4025cf4:	da406385 	stb	r9,398(sp)
 4025cf8:	d8806115 	stw	r2,388(sp)
 4025cfc:	40273f40 	call	40273f4 <memset>
 4025d00:	00c100f4 	movhi	r3,1027
 4025d04:	18f64904 	addi	r3,r3,-9948
 4025d08:	1a400283 	ldbu	r9,10(r3)
 4025d0c:	19c00117 	ldw	r7,4(r3)
 4025d10:	1a00020b 	ldhu	r8,8(r3)
 4025d14:	18800017 	ldw	r2,0(r3)
 4025d18:	d90073c4 	addi	r4,sp,463
 4025d1c:	000b883a 	mov	r5,zero
 4025d20:	01800d44 	movi	r6,53
 4025d24:	da407385 	stb	r9,462(sp)
 4025d28:	d9c07215 	stw	r7,456(sp)
 4025d2c:	da00730d 	sth	r8,460(sp)
 4025d30:	d8807115 	stw	r2,452(sp)
 4025d34:	40273f40 	call	40273f4 <memset>
 4025d38:	00c100f4 	movhi	r3,1027
 4025d3c:	18f65904 	addi	r3,r3,-9884
 4025d40:	1a000203 	ldbu	r8,8(r3)
 4025d44:	19c00117 	ldw	r7,4(r3)
 4025d48:	18800017 	ldw	r2,0(r3)
 4025d4c:	d9008344 	addi	r4,sp,525
 4025d50:	000b883a 	mov	r5,zero
 4025d54:	01800dc4 	movi	r6,55
 4025d58:	d9c08215 	stw	r7,520(sp)
 4025d5c:	da008305 	stb	r8,524(sp)
 4025d60:	d8808115 	stw	r2,516(sp)
 4025d64:	40273f40 	call	40273f4 <memset>
 4025d68:	00c100f4 	movhi	r3,1027
 4025d6c:	18f66904 	addi	r3,r3,-9820
 4025d70:	1a000203 	ldbu	r8,8(r3)
 4025d74:	19c00117 	ldw	r7,4(r3)
 4025d78:	18800017 	ldw	r2,0(r3)
 4025d7c:	d9009344 	addi	r4,sp,589
 4025d80:	000b883a 	mov	r5,zero
 4025d84:	01800dc4 	movi	r6,55
 4025d88:	d9c09215 	stw	r7,584(sp)
 4025d8c:	da009305 	stb	r8,588(sp)
 4025d90:	d8809115 	stw	r2,580(sp)
 4025d94:	40273f40 	call	40273f4 <memset>
 4025d98:	00c100f4 	movhi	r3,1027
 4025d9c:	18f67904 	addi	r3,r3,-9756
 4025da0:	1a000203 	ldbu	r8,8(r3)
 4025da4:	19c00117 	ldw	r7,4(r3)
 4025da8:	18800017 	ldw	r2,0(r3)
 4025dac:	d900a344 	addi	r4,sp,653
 4025db0:	000b883a 	mov	r5,zero
 4025db4:	01800dc4 	movi	r6,55
 4025db8:	d9c0a215 	stw	r7,648(sp)
 4025dbc:	da00a305 	stb	r8,652(sp)
 4025dc0:	d880a115 	stw	r2,644(sp)
 4025dc4:	40273f40 	call	40273f4 <memset>
 4025dc8:	00c100f4 	movhi	r3,1027
 4025dcc:	18f68904 	addi	r3,r3,-9692
 4025dd0:	008100f4 	movhi	r2,1027
 4025dd4:	10b69904 	addi	r2,r2,-9628
 4025dd8:	12c00217 	ldw	r11,8(r2)
 4025ddc:	11c00017 	ldw	r7,0(r2)
 4025de0:	12000117 	ldw	r8,4(r2)
 4025de4:	1b000283 	ldbu	r12,10(r3)
 4025de8:	1a400017 	ldw	r9,0(r3)
 4025dec:	18800117 	ldw	r2,4(r3)
 4025df0:	1a80020b 	ldhu	r10,8(r3)
 4025df4:	d900c3c4 	addi	r4,sp,783
 4025df8:	000b883a 	mov	r5,zero
 4025dfc:	01800d44 	movi	r6,53
 4025e00:	d9c0b115 	stw	r7,708(sp)
 4025e04:	da00b215 	stw	r8,712(sp)
 4025e08:	dac0b315 	stw	r11,716(sp)
 4025e0c:	da40c115 	stw	r9,772(sp)
 4025e10:	d880c215 	stw	r2,776(sp)
 4025e14:	da80c30d 	sth	r10,780(sp)
 4025e18:	db00c385 	stb	r12,782(sp)
 4025e1c:	d800b415 	stw	zero,720(sp)
 4025e20:	d800b515 	stw	zero,724(sp)
 4025e24:	d800b615 	stw	zero,728(sp)
 4025e28:	d800b715 	stw	zero,732(sp)
 4025e2c:	d800b815 	stw	zero,736(sp)
 4025e30:	d800b915 	stw	zero,740(sp)
 4025e34:	d800ba15 	stw	zero,744(sp)
 4025e38:	d800bb15 	stw	zero,748(sp)
 4025e3c:	d800bc15 	stw	zero,752(sp)
 4025e40:	d800bd15 	stw	zero,756(sp)
 4025e44:	d800be15 	stw	zero,760(sp)
 4025e48:	d800bf15 	stw	zero,764(sp)
 4025e4c:	d800c015 	stw	zero,768(sp)
 4025e50:	40273f40 	call	40273f4 <memset>

	bSuccess = POWER_Read(szVol);
 4025e54:	d9000504 	addi	r4,sp,20
 4025e58:	4025a140 	call	4025a14 <POWER_Read>
	if (bSuccess) {
 4025e5c:	10003326 	beq	r2,zero,4025f2c <measure_power+0x398>
		//for(i=0;i<POWER_PORT_NUM && bSuccess;i++){
		int i = 1;
		SIG = (szVol[i] >> 29) & 0x01;
 4025e60:	dd400617 	ldw	r21,24(sp)
		MSB = (szVol[i] >> 28) & 0x01;
 4025e64:	a804d73a 	srli	r2,r21,28
 4025e68:	1080004c 	andi	r2,r2,1
		RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
		if (MSB == 0)
 4025e6c:	1021003a 	cmpeq	r16,r2,zero
 4025e70:	8000371e 	bne	r16,zero,4025f50 <measure_power+0x3bc>
			fVolDrop = (float) (RESULT) / (float) 0x400000;
		else
			fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
		if (SIG && MSB) {
 4025e74:	a888002c 	andhi	r2,r21,8192
		//for(i=0;i<POWER_PORT_NUM && bSuccess;i++){
		int i = 1;
		SIG = (szVol[i] >> 29) & 0x01;
		MSB = (szVol[i] >> 28) & 0x01;
		RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
		if (MSB == 0)
 4025e78:	0027883a 	mov	r19,zero
			fVolDrop = (float) (RESULT) / (float) 0x400000;
		else
			fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
		if (SIG && MSB) {
 4025e7c:	10003d26 	beq	r2,zero,4025f74 <measure_power+0x3e0>
 4025e80:	80006426 	beq	r16,zero,4026014 <measure_power+0x480>
			fVolDrop = fVolDrop * 1000 * 1000;
			fCurrent = fCurrent * 1000 * 1000;
			fPower = fPower * 1000 * 1000;
			//printf("[%s:%06XH,Pos]  VolDrop:%f(V), Current:%f(A), Power:%f(W)\n", szName[i], (int)szVol[i], fVolDrop, fCurrent, fPower);
			// for energy assuming samples are 1 second apart, exactly. might need to add a system timer...
			printf("%i\t%i\t%i\t", (int)fVolDrop, (int)fCurrent, (int)fPower);
 4025e84:	04111eb4 	movhi	r16,17530
			fVol = fRef * 0.5;
			printf("[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n", szName[i],
					(int) szVol[i], fVol);
		} else if (SIG && !MSB) {
			fVol = fRef * 0.5 * fVolDrop;
			fCurrent = (fVolDrop / szRes[i]);
 4025e88:	9809883a 	mov	r4,r19
 4025e8c:	014ed174 	movhi	r5,15173
 4025e90:	2966e984 	addi	r5,r5,-25690
 4025e94:	40262040 	call	4026204 <__divsf3>
			fVolDrop = fVolDrop * 1000 * 1000;
			fCurrent = fCurrent * 1000 * 1000;
			fPower = fPower * 1000 * 1000;
			//printf("[%s:%06XH,Pos]  VolDrop:%f(V), Current:%f(A), Power:%f(W)\n", szName[i], (int)szVol[i], fVolDrop, fCurrent, fPower);
			// for energy assuming samples are 1 second apart, exactly. might need to add a system timer...
			printf("%i\t%i\t%i\t", (int)fVolDrop, (int)fCurrent, (int)fPower);
 4025e98:	9809883a 	mov	r4,r19
 4025e9c:	800b883a 	mov	r5,r16
			fVol = fRef * 0.5;
			printf("[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n", szName[i],
					(int) szVol[i], fVol);
		} else if (SIG && !MSB) {
			fVol = fRef * 0.5 * fVolDrop;
			fCurrent = (fVolDrop / szRes[i]);
 4025ea0:	1023883a 	mov	r17,r2
			fVolDrop = fVolDrop * 1000 * 1000;
			fCurrent = fCurrent * 1000 * 1000;
			fPower = fPower * 1000 * 1000;
			//printf("[%s:%06XH,Pos]  VolDrop:%f(V), Current:%f(A), Power:%f(W)\n", szName[i], (int)szVol[i], fVolDrop, fCurrent, fPower);
			// for energy assuming samples are 1 second apart, exactly. might need to add a system timer...
			printf("%i\t%i\t%i\t", (int)fVolDrop, (int)fCurrent, (int)fPower);
 4025ea4:	402603c0 	call	402603c <__mulsf3>
 4025ea8:	1009883a 	mov	r4,r2
 4025eac:	800b883a 	mov	r5,r16
 4025eb0:	402603c0 	call	402603c <__mulsf3>
 4025eb4:	1009883a 	mov	r4,r2
 4025eb8:	40263780 	call	4026378 <__fixsfsi>
 4025ebc:	800b883a 	mov	r5,r16
 4025ec0:	8809883a 	mov	r4,r17
 4025ec4:	102b883a 	mov	r21,r2
 4025ec8:	402603c0 	call	402603c <__mulsf3>
 4025ecc:	1009883a 	mov	r4,r2
 4025ed0:	800b883a 	mov	r5,r16
 4025ed4:	402603c0 	call	402603c <__mulsf3>
 4025ed8:	1009883a 	mov	r4,r2
 4025edc:	40263780 	call	4026378 <__fixsfsi>
 4025ee0:	014fd9b4 	movhi	r5,16230
 4025ee4:	29599984 	addi	r5,r5,26214
 4025ee8:	8809883a 	mov	r4,r17
 4025eec:	1027883a 	mov	r19,r2
 4025ef0:	402603c0 	call	402603c <__mulsf3>
 4025ef4:	1009883a 	mov	r4,r2
 4025ef8:	800b883a 	mov	r5,r16
 4025efc:	402603c0 	call	402603c <__mulsf3>
 4025f00:	1009883a 	mov	r4,r2
 4025f04:	800b883a 	mov	r5,r16
 4025f08:	402603c0 	call	402603c <__mulsf3>
 4025f0c:	1009883a 	mov	r4,r2
 4025f10:	40263780 	call	4026378 <__fixsfsi>
 4025f14:	a80b883a 	mov	r5,r21
 4025f18:	980d883a 	mov	r6,r19
 4025f1c:	100f883a 	mov	r7,r2
 4025f20:	010100f4 	movhi	r4,1027
 4025f24:	2135cd04 	addi	r4,r4,-10444
 4025f28:	40274140 	call	4027414 <printf>
			fVol = -fRef * 0.5;
			printf("[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n", szName[i],
					(int) szVol[i], fVol);
		}
	}
}
 4025f2c:	dfc0d717 	ldw	ra,860(sp)
 4025f30:	dd40d617 	ldw	r21,856(sp)
 4025f34:	dd00d517 	ldw	r20,852(sp)
 4025f38:	dcc0d417 	ldw	r19,848(sp)
 4025f3c:	dc80d317 	ldw	r18,844(sp)
 4025f40:	dc40d217 	ldw	r17,840(sp)
 4025f44:	dc00d117 	ldw	r16,836(sp)
 4025f48:	dec0d804 	addi	sp,sp,864
 4025f4c:	f800283a 	ret
		int i = 1;
		SIG = (szVol[i] >> 29) & 0x01;
		MSB = (szVol[i] >> 28) & 0x01;
		RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
		if (MSB == 0)
			fVolDrop = (float) (RESULT) / (float) 0x400000;
 4025f50:	a808913a 	slli	r4,r21,4
 4025f54:	2008d2ba 	srli	r4,r4,10
 4025f58:	40264600 	call	4026460 <__floatunsisf>
 4025f5c:	1009883a 	mov	r4,r2
 4025f60:	014d2034 	movhi	r5,13440
 4025f64:	402603c0 	call	402603c <__mulsf3>
 4025f68:	1027883a 	mov	r19,r2
		else
			fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
		if (SIG && MSB) {
 4025f6c:	a888002c 	andhi	r2,r21,8192
 4025f70:	103fc31e 	bne	r2,zero,4025e80 <measure_power+0x2ec>
			//printf("%i\t", (int)fCurrent);
			//printf("%i\t", (int)fPower);
			//printf("\n");
//			printf("%f\t", fEnergy = fEnergy + fPower);

		} else if (!SIG && MSB) {
 4025f74:	80000a26 	beq	r16,zero,4025fa0 <measure_power+0x40c>
			printf(
					"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
					szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
		} else if (!SIG && !MSB) {
			fVol = -fRef * 0.5;
			printf("[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n", szName[i],
 4025f78:	0005883a 	mov	r2,zero
 4025f7c:	00f00134 	movhi	r3,49156
 4025f80:	100f883a 	mov	r7,r2
 4025f84:	a1401004 	addi	r5,r20,64
 4025f88:	a80d883a 	mov	r6,r21
 4025f8c:	010100f4 	movhi	r4,1027
 4025f90:	2135e004 	addi	r4,r4,-10368
 4025f94:	d8c00015 	stw	r3,0(sp)
 4025f98:	40274140 	call	4027414 <printf>
 4025f9c:	003fe306 	br	4025f2c <measure_power+0x398>
			//printf("\n");
//			printf("%f\t", fEnergy = fEnergy + fPower);

		} else if (!SIG && MSB) {
			fVol = fRef * 0.5 * fVolDrop;
			fCurrent = fVolDrop / szRes[i];
 4025fa0:	014ed174 	movhi	r5,15173
 4025fa4:	2966e984 	addi	r5,r5,-25690
 4025fa8:	9809883a 	mov	r4,r19
 4025fac:	40262040 	call	4026204 <__divsf3>
 4025fb0:	1025883a 	mov	r18,r2
			fPower = szRefVol[i] * fCurrent;
			printf(
 4025fb4:	9809883a 	mov	r4,r19
 4025fb8:	402640c0 	call	402640c <__extendsfdf2>
 4025fbc:	9009883a 	mov	r4,r18
 4025fc0:	1021883a 	mov	r16,r2
 4025fc4:	1823883a 	mov	r17,r3
 4025fc8:	402640c0 	call	402640c <__extendsfdf2>
 4025fcc:	014fd9b4 	movhi	r5,16230
 4025fd0:	29599984 	addi	r5,r5,26214
 4025fd4:	9009883a 	mov	r4,r18
 4025fd8:	d8c00215 	stw	r3,8(sp)
 4025fdc:	d8800115 	stw	r2,4(sp)
 4025fe0:	402603c0 	call	402603c <__mulsf3>
 4025fe4:	1009883a 	mov	r4,r2
 4025fe8:	402640c0 	call	402640c <__extendsfdf2>
 4025fec:	a1401004 	addi	r5,r20,64
 4025ff0:	800f883a 	mov	r7,r16
 4025ff4:	a80d883a 	mov	r6,r21
 4025ff8:	010100f4 	movhi	r4,1027
 4025ffc:	2135d004 	addi	r4,r4,-10432
 4026000:	d8c00415 	stw	r3,16(sp)
 4026004:	d8800315 	stw	r2,12(sp)
 4026008:	dc400015 	stw	r17,0(sp)
 402600c:	40274140 	call	4027414 <printf>
 4026010:	003fc606 	br	4025f2c <measure_power+0x398>
			fVolDrop = (float) (RESULT) / (float) 0x400000;
		else
			fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
		if (SIG && MSB) {
			fVol = fRef * 0.5;
			printf("[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n", szName[i],
 4026014:	0005883a 	mov	r2,zero
 4026018:	00d00134 	movhi	r3,16388
 402601c:	100f883a 	mov	r7,r2
 4026020:	a1401004 	addi	r5,r20,64
 4026024:	a80d883a 	mov	r6,r21
 4026028:	010100f4 	movhi	r4,1027
 402602c:	2135c404 	addi	r4,r4,-10480
 4026030:	d8c00015 	stw	r3,0(sp)
 4026034:	40274140 	call	4027414 <printf>
 4026038:	003fbc06 	br	4025f2c <measure_power+0x398>

0402603c <__mulsf3>:
 402603c:	deffef04 	addi	sp,sp,-68
 4026040:	dc400f15 	stw	r17,60(sp)
 4026044:	dc400204 	addi	r17,sp,8
 4026048:	dc000e15 	stw	r16,56(sp)
 402604c:	d9000015 	stw	r4,0(sp)
 4026050:	d9400115 	stw	r5,4(sp)
 4026054:	d809883a 	mov	r4,sp
 4026058:	880b883a 	mov	r5,r17
 402605c:	dc000604 	addi	r16,sp,24
 4026060:	dfc01015 	stw	ra,64(sp)
 4026064:	40268840 	call	4026884 <__unpack_f>
 4026068:	d9000104 	addi	r4,sp,4
 402606c:	800b883a 	mov	r5,r16
 4026070:	40268840 	call	4026884 <__unpack_f>
 4026074:	d9000217 	ldw	r4,8(sp)
 4026078:	01400044 	movi	r5,1
 402607c:	00800104 	movi	r2,4
 4026080:	2900142e 	bgeu	r5,r4,40260d4 <__mulsf3+0x98>
 4026084:	d8c00617 	ldw	r3,24(sp)
 4026088:	28c0052e 	bgeu	r5,r3,40260a0 <__mulsf3+0x64>
 402608c:	20800f26 	beq	r4,r2,40260cc <__mulsf3+0x90>
 4026090:	18805726 	beq	r3,r2,40261f0 <__mulsf3+0x1b4>
 4026094:	00800084 	movi	r2,2
 4026098:	20800e26 	beq	r4,r2,40260d4 <__mulsf3+0x98>
 402609c:	1880181e 	bne	r3,r2,4026100 <__mulsf3+0xc4>
 40260a0:	d8c00717 	ldw	r3,28(sp)
 40260a4:	d8800317 	ldw	r2,12(sp)
 40260a8:	8009883a 	mov	r4,r16
 40260ac:	10c4c03a 	cmpne	r2,r2,r3
 40260b0:	d8800715 	stw	r2,28(sp)
 40260b4:	40267240 	call	4026724 <__pack_f>
 40260b8:	dfc01017 	ldw	ra,64(sp)
 40260bc:	dc400f17 	ldw	r17,60(sp)
 40260c0:	dc000e17 	ldw	r16,56(sp)
 40260c4:	dec01104 	addi	sp,sp,68
 40260c8:	f800283a 	ret
 40260cc:	00800084 	movi	r2,2
 40260d0:	18804926 	beq	r3,r2,40261f8 <__mulsf3+0x1bc>
 40260d4:	d8800317 	ldw	r2,12(sp)
 40260d8:	d8c00717 	ldw	r3,28(sp)
 40260dc:	8809883a 	mov	r4,r17
 40260e0:	10c4c03a 	cmpne	r2,r2,r3
 40260e4:	d8800315 	stw	r2,12(sp)
 40260e8:	40267240 	call	4026724 <__pack_f>
 40260ec:	dfc01017 	ldw	ra,64(sp)
 40260f0:	dc400f17 	ldw	r17,60(sp)
 40260f4:	dc000e17 	ldw	r16,56(sp)
 40260f8:	dec01104 	addi	sp,sp,68
 40260fc:	f800283a 	ret
 4026100:	d9400517 	ldw	r5,20(sp)
 4026104:	d8800917 	ldw	r2,36(sp)
 4026108:	288d383a 	mul	r6,r5,r2
 402610c:	288e383a 	mulxuu	r7,r5,r2
 4026110:	d8800417 	ldw	r2,16(sp)
 4026114:	d9400817 	ldw	r5,32(sp)
 4026118:	3807883a 	mov	r3,r7
 402611c:	10800084 	addi	r2,r2,2
 4026120:	2891883a 	add	r8,r5,r2
 4026124:	d8800317 	ldw	r2,12(sp)
 4026128:	d9400717 	ldw	r5,28(sp)
 402612c:	3009883a 	mov	r4,r6
 4026130:	da000c15 	stw	r8,48(sp)
 4026134:	1144c03a 	cmpne	r2,r2,r5
 4026138:	d8800b15 	stw	r2,44(sp)
 402613c:	3800070e 	bge	r7,zero,402615c <__mulsf3+0x120>
 4026140:	3880004c 	andi	r2,r7,1
 4026144:	1005003a 	cmpeq	r2,r2,zero
 4026148:	400b883a 	mov	r5,r8
 402614c:	10001e26 	beq	r2,zero,40261c8 <__mulsf3+0x18c>
 4026150:	1806d07a 	srli	r3,r3,1
 4026154:	29400044 	addi	r5,r5,1
 4026158:	d9400c15 	stw	r5,48(sp)
 402615c:	01500034 	movhi	r5,16384
 4026160:	297fffc4 	addi	r5,r5,-1
 4026164:	28c00b36 	bltu	r5,r3,4026194 <__mulsf3+0x158>
 4026168:	d8800c17 	ldw	r2,48(sp)
 402616c:	00000206 	br	4026178 <__mulsf3+0x13c>
 4026170:	2109883a 	add	r4,r4,r4
 4026174:	28c00636 	bltu	r5,r3,4026190 <__mulsf3+0x154>
 4026178:	10bfffc4 	addi	r2,r2,-1
 402617c:	18c7883a 	add	r3,r3,r3
 4026180:	203ffb0e 	bge	r4,zero,4026170 <__mulsf3+0x134>
 4026184:	18c00054 	ori	r3,r3,1
 4026188:	2109883a 	add	r4,r4,r4
 402618c:	28fffa2e 	bgeu	r5,r3,4026178 <__mulsf3+0x13c>
 4026190:	d8800c15 	stw	r2,48(sp)
 4026194:	19401fcc 	andi	r5,r3,127
 4026198:	00801004 	movi	r2,64
 402619c:	28800d26 	beq	r5,r2,40261d4 <__mulsf3+0x198>
 40261a0:	008000c4 	movi	r2,3
 40261a4:	d9000a04 	addi	r4,sp,40
 40261a8:	d8c00d15 	stw	r3,52(sp)
 40261ac:	d8800a15 	stw	r2,40(sp)
 40261b0:	40267240 	call	4026724 <__pack_f>
 40261b4:	dfc01017 	ldw	ra,64(sp)
 40261b8:	dc400f17 	ldw	r17,60(sp)
 40261bc:	dc000e17 	ldw	r16,56(sp)
 40261c0:	dec01104 	addi	sp,sp,68
 40261c4:	f800283a 	ret
 40261c8:	3004d07a 	srli	r2,r6,1
 40261cc:	11200034 	orhi	r4,r2,32768
 40261d0:	003fdf06 	br	4026150 <__mulsf3+0x114>
 40261d4:	1880200c 	andi	r2,r3,128
 40261d8:	103ff11e 	bne	r2,zero,40261a0 <__mulsf3+0x164>
 40261dc:	203ff026 	beq	r4,zero,40261a0 <__mulsf3+0x164>
 40261e0:	1947883a 	add	r3,r3,r5
 40261e4:	00bfe004 	movi	r2,-128
 40261e8:	1886703a 	and	r3,r3,r2
 40261ec:	003fec06 	br	40261a0 <__mulsf3+0x164>
 40261f0:	00800084 	movi	r2,2
 40261f4:	20bfaa1e 	bne	r4,r2,40260a0 <__mulsf3+0x64>
 40261f8:	010100f4 	movhi	r4,1027
 40261fc:	2136a904 	addi	r4,r4,-9564
 4026200:	003fb906 	br	40260e8 <__mulsf3+0xac>

04026204 <__divsf3>:
 4026204:	defff304 	addi	sp,sp,-52
 4026208:	dc400b15 	stw	r17,44(sp)
 402620c:	dc400204 	addi	r17,sp,8
 4026210:	dc000a15 	stw	r16,40(sp)
 4026214:	d9000015 	stw	r4,0(sp)
 4026218:	d9400115 	stw	r5,4(sp)
 402621c:	d809883a 	mov	r4,sp
 4026220:	880b883a 	mov	r5,r17
 4026224:	dc000604 	addi	r16,sp,24
 4026228:	dfc00c15 	stw	ra,48(sp)
 402622c:	40268840 	call	4026884 <__unpack_f>
 4026230:	d9000104 	addi	r4,sp,4
 4026234:	800b883a 	mov	r5,r16
 4026238:	40268840 	call	4026884 <__unpack_f>
 402623c:	d9000217 	ldw	r4,8(sp)
 4026240:	00800044 	movi	r2,1
 4026244:	01800104 	movi	r6,4
 4026248:	11000a2e 	bgeu	r2,r4,4026274 <__divsf3+0x70>
 402624c:	d9400617 	ldw	r5,24(sp)
 4026250:	1140432e 	bgeu	r2,r5,4026360 <__divsf3+0x15c>
 4026254:	d8800317 	ldw	r2,12(sp)
 4026258:	d8c00717 	ldw	r3,28(sp)
 402625c:	10c4f03a 	xor	r2,r2,r3
 4026260:	d8800315 	stw	r2,12(sp)
 4026264:	21800226 	beq	r4,r6,4026270 <__divsf3+0x6c>
 4026268:	00800084 	movi	r2,2
 402626c:	2080101e 	bne	r4,r2,40262b0 <__divsf3+0xac>
 4026270:	29000726 	beq	r5,r4,4026290 <__divsf3+0x8c>
 4026274:	8809883a 	mov	r4,r17
 4026278:	40267240 	call	4026724 <__pack_f>
 402627c:	dfc00c17 	ldw	ra,48(sp)
 4026280:	dc400b17 	ldw	r17,44(sp)
 4026284:	dc000a17 	ldw	r16,40(sp)
 4026288:	dec00d04 	addi	sp,sp,52
 402628c:	f800283a 	ret
 4026290:	010100f4 	movhi	r4,1027
 4026294:	2136a904 	addi	r4,r4,-9564
 4026298:	40267240 	call	4026724 <__pack_f>
 402629c:	dfc00c17 	ldw	ra,48(sp)
 40262a0:	dc400b17 	ldw	r17,44(sp)
 40262a4:	dc000a17 	ldw	r16,40(sp)
 40262a8:	dec00d04 	addi	sp,sp,52
 40262ac:	f800283a 	ret
 40262b0:	29802d26 	beq	r5,r6,4026368 <__divsf3+0x164>
 40262b4:	28801a26 	beq	r5,r2,4026320 <__divsf3+0x11c>
 40262b8:	d8c00417 	ldw	r3,16(sp)
 40262bc:	d8800817 	ldw	r2,32(sp)
 40262c0:	d9000517 	ldw	r4,20(sp)
 40262c4:	d9800917 	ldw	r6,36(sp)
 40262c8:	1885c83a 	sub	r2,r3,r2
 40262cc:	d8800415 	stw	r2,16(sp)
 40262d0:	2180032e 	bgeu	r4,r6,40262e0 <__divsf3+0xdc>
 40262d4:	10bfffc4 	addi	r2,r2,-1
 40262d8:	d8800415 	stw	r2,16(sp)
 40262dc:	2109883a 	add	r4,r4,r4
 40262e0:	01500034 	movhi	r5,16384
 40262e4:	0007883a 	mov	r3,zero
 40262e8:	0005883a 	mov	r2,zero
 40262ec:	01c007c4 	movi	r7,31
 40262f0:	10800044 	addi	r2,r2,1
 40262f4:	21800236 	bltu	r4,r6,4026300 <__divsf3+0xfc>
 40262f8:	1946b03a 	or	r3,r3,r5
 40262fc:	2189c83a 	sub	r4,r4,r6
 4026300:	280ad07a 	srli	r5,r5,1
 4026304:	2109883a 	add	r4,r4,r4
 4026308:	11fff91e 	bne	r2,r7,40262f0 <__divsf3+0xec>
 402630c:	19401fcc 	andi	r5,r3,127
 4026310:	00801004 	movi	r2,64
 4026314:	28800a26 	beq	r5,r2,4026340 <__divsf3+0x13c>
 4026318:	d8c00515 	stw	r3,20(sp)
 402631c:	003fd506 	br	4026274 <__divsf3+0x70>
 4026320:	8809883a 	mov	r4,r17
 4026324:	d9800215 	stw	r6,8(sp)
 4026328:	40267240 	call	4026724 <__pack_f>
 402632c:	dfc00c17 	ldw	ra,48(sp)
 4026330:	dc400b17 	ldw	r17,44(sp)
 4026334:	dc000a17 	ldw	r16,40(sp)
 4026338:	dec00d04 	addi	sp,sp,52
 402633c:	f800283a 	ret
 4026340:	1880200c 	andi	r2,r3,128
 4026344:	103ff41e 	bne	r2,zero,4026318 <__divsf3+0x114>
 4026348:	203ff326 	beq	r4,zero,4026318 <__divsf3+0x114>
 402634c:	1947883a 	add	r3,r3,r5
 4026350:	00bfe004 	movi	r2,-128
 4026354:	1886703a 	and	r3,r3,r2
 4026358:	d8c00515 	stw	r3,20(sp)
 402635c:	003fc506 	br	4026274 <__divsf3+0x70>
 4026360:	8009883a 	mov	r4,r16
 4026364:	003fc406 	br	4026278 <__divsf3+0x74>
 4026368:	8809883a 	mov	r4,r17
 402636c:	d8000515 	stw	zero,20(sp)
 4026370:	d8000415 	stw	zero,16(sp)
 4026374:	003fc006 	br	4026278 <__divsf3+0x74>

04026378 <__fixsfsi>:
 4026378:	defffa04 	addi	sp,sp,-24
 402637c:	d9000015 	stw	r4,0(sp)
 4026380:	d9400104 	addi	r5,sp,4
 4026384:	d809883a 	mov	r4,sp
 4026388:	dfc00515 	stw	ra,20(sp)
 402638c:	40268840 	call	4026884 <__unpack_f>
 4026390:	d8c00117 	ldw	r3,4(sp)
 4026394:	00800084 	movi	r2,2
 4026398:	1880041e 	bne	r3,r2,40263ac <__fixsfsi+0x34>
 402639c:	0005883a 	mov	r2,zero
 40263a0:	dfc00517 	ldw	ra,20(sp)
 40263a4:	dec00604 	addi	sp,sp,24
 40263a8:	f800283a 	ret
 40263ac:	00800044 	movi	r2,1
 40263b0:	10fffa2e 	bgeu	r2,r3,402639c <__fixsfsi+0x24>
 40263b4:	00800104 	movi	r2,4
 40263b8:	18800426 	beq	r3,r2,40263cc <__fixsfsi+0x54>
 40263bc:	d8800317 	ldw	r2,12(sp)
 40263c0:	103ff616 	blt	r2,zero,402639c <__fixsfsi+0x24>
 40263c4:	00c00784 	movi	r3,30
 40263c8:	1880070e 	bge	r3,r2,40263e8 <__fixsfsi+0x70>
 40263cc:	d8800217 	ldw	r2,8(sp)
 40263d0:	10000c1e 	bne	r2,zero,4026404 <__fixsfsi+0x8c>
 40263d4:	00a00034 	movhi	r2,32768
 40263d8:	10bfffc4 	addi	r2,r2,-1
 40263dc:	dfc00517 	ldw	ra,20(sp)
 40263e0:	dec00604 	addi	sp,sp,24
 40263e4:	f800283a 	ret
 40263e8:	1885c83a 	sub	r2,r3,r2
 40263ec:	d9000217 	ldw	r4,8(sp)
 40263f0:	d8c00417 	ldw	r3,16(sp)
 40263f4:	1884d83a 	srl	r2,r3,r2
 40263f8:	203fe926 	beq	r4,zero,40263a0 <__fixsfsi+0x28>
 40263fc:	0085c83a 	sub	r2,zero,r2
 4026400:	003fe706 	br	40263a0 <__fixsfsi+0x28>
 4026404:	00a00034 	movhi	r2,32768
 4026408:	003fe506 	br	40263a0 <__fixsfsi+0x28>

0402640c <__extendsfdf2>:
 402640c:	defff904 	addi	sp,sp,-28
 4026410:	d9000115 	stw	r4,4(sp)
 4026414:	d9400204 	addi	r5,sp,8
 4026418:	d9000104 	addi	r4,sp,4
 402641c:	dfc00615 	stw	ra,24(sp)
 4026420:	40268840 	call	4026884 <__unpack_f>
 4026424:	d9c00517 	ldw	r7,20(sp)
 4026428:	0011883a 	mov	r8,zero
 402642c:	400697ba 	slli	r3,r8,30
 4026430:	3812d0ba 	srli	r9,r7,2
 4026434:	380497ba 	slli	r2,r7,30
 4026438:	d9000217 	ldw	r4,8(sp)
 402643c:	d9400317 	ldw	r5,12(sp)
 4026440:	d9800417 	ldw	r6,16(sp)
 4026444:	48c6b03a 	or	r3,r9,r3
 4026448:	100f883a 	mov	r7,r2
 402644c:	d8c00015 	stw	r3,0(sp)
 4026450:	40265200 	call	4026520 <__make_dp>
 4026454:	dfc00617 	ldw	ra,24(sp)
 4026458:	dec00704 	addi	sp,sp,28
 402645c:	f800283a 	ret

04026460 <__floatunsisf>:
 4026460:	defff904 	addi	sp,sp,-28
 4026464:	dc400515 	stw	r17,20(sp)
 4026468:	dc000415 	stw	r16,16(sp)
 402646c:	dfc00615 	stw	ra,24(sp)
 4026470:	04400784 	movi	r17,30
 4026474:	2021883a 	mov	r16,r4
 4026478:	d8000115 	stw	zero,4(sp)
 402647c:	2000091e 	bne	r4,zero,40264a4 <__floatunsisf+0x44>
 4026480:	00800084 	movi	r2,2
 4026484:	d8800015 	stw	r2,0(sp)
 4026488:	d809883a 	mov	r4,sp
 402648c:	40267240 	call	4026724 <__pack_f>
 4026490:	dfc00617 	ldw	ra,24(sp)
 4026494:	dc400517 	ldw	r17,20(sp)
 4026498:	dc000417 	ldw	r16,16(sp)
 402649c:	dec00704 	addi	sp,sp,28
 40264a0:	f800283a 	ret
 40264a4:	008000c4 	movi	r2,3
 40264a8:	d9000315 	stw	r4,12(sp)
 40264ac:	d8800015 	stw	r2,0(sp)
 40264b0:	dc400215 	stw	r17,8(sp)
 40264b4:	40266a40 	call	40266a4 <__clzsi2>
 40264b8:	117fffc4 	addi	r5,r2,-1
 40264bc:	0147c83a 	sub	r3,zero,r5
 40264c0:	00800044 	movi	r2,1
 40264c4:	10c4983a 	sll	r2,r2,r3
 40264c8:	80c6d83a 	srl	r3,r16,r3
 40264cc:	8949c83a 	sub	r4,r17,r5
 40264d0:	10bfffc4 	addi	r2,r2,-1
 40264d4:	8084703a 	and	r2,r16,r2
 40264d8:	1004c03a 	cmpne	r2,r2,zero
 40264dc:	1886b03a 	or	r3,r3,r2
 40264e0:	28000c16 	blt	r5,zero,4026514 <__floatunsisf+0xb4>
 40264e4:	8144983a 	sll	r2,r16,r5
 40264e8:	8947c83a 	sub	r3,r17,r5
 40264ec:	283fe626 	beq	r5,zero,4026488 <__floatunsisf+0x28>
 40264f0:	d809883a 	mov	r4,sp
 40264f4:	d8800315 	stw	r2,12(sp)
 40264f8:	d8c00215 	stw	r3,8(sp)
 40264fc:	40267240 	call	4026724 <__pack_f>
 4026500:	dfc00617 	ldw	ra,24(sp)
 4026504:	dc400517 	ldw	r17,20(sp)
 4026508:	dc000417 	ldw	r16,16(sp)
 402650c:	dec00704 	addi	sp,sp,28
 4026510:	f800283a 	ret
 4026514:	d8c00315 	stw	r3,12(sp)
 4026518:	d9000215 	stw	r4,8(sp)
 402651c:	003fda06 	br	4026488 <__floatunsisf+0x28>

04026520 <__make_dp>:
 4026520:	defff904 	addi	sp,sp,-28
 4026524:	d8c00717 	ldw	r3,28(sp)
 4026528:	d9000015 	stw	r4,0(sp)
 402652c:	d809883a 	mov	r4,sp
 4026530:	dfc00515 	stw	ra,20(sp)
 4026534:	d9c00615 	stw	r7,24(sp)
 4026538:	d9400115 	stw	r5,4(sp)
 402653c:	d9800215 	stw	r6,8(sp)
 4026540:	d8c00415 	stw	r3,16(sp)
 4026544:	d9c00315 	stw	r7,12(sp)
 4026548:	402694c0 	call	402694c <__pack_d>
 402654c:	dfc00517 	ldw	ra,20(sp)
 4026550:	dec00704 	addi	sp,sp,28
 4026554:	f800283a 	ret

04026558 <udivmodsi4>:
 4026558:	29001b2e 	bgeu	r5,r4,40265c8 <udivmodsi4+0x70>
 402655c:	28001a16 	blt	r5,zero,40265c8 <udivmodsi4+0x70>
 4026560:	00800044 	movi	r2,1
 4026564:	0007883a 	mov	r3,zero
 4026568:	01c007c4 	movi	r7,31
 402656c:	00000306 	br	402657c <udivmodsi4+0x24>
 4026570:	19c01326 	beq	r3,r7,40265c0 <udivmodsi4+0x68>
 4026574:	18c00044 	addi	r3,r3,1
 4026578:	28000416 	blt	r5,zero,402658c <udivmodsi4+0x34>
 402657c:	294b883a 	add	r5,r5,r5
 4026580:	1085883a 	add	r2,r2,r2
 4026584:	293ffa36 	bltu	r5,r4,4026570 <udivmodsi4+0x18>
 4026588:	10000d26 	beq	r2,zero,40265c0 <udivmodsi4+0x68>
 402658c:	0007883a 	mov	r3,zero
 4026590:	21400236 	bltu	r4,r5,402659c <udivmodsi4+0x44>
 4026594:	2149c83a 	sub	r4,r4,r5
 4026598:	1886b03a 	or	r3,r3,r2
 402659c:	1004d07a 	srli	r2,r2,1
 40265a0:	280ad07a 	srli	r5,r5,1
 40265a4:	103ffa1e 	bne	r2,zero,4026590 <udivmodsi4+0x38>
 40265a8:	30000226 	beq	r6,zero,40265b4 <udivmodsi4+0x5c>
 40265ac:	2005883a 	mov	r2,r4
 40265b0:	f800283a 	ret
 40265b4:	1809883a 	mov	r4,r3
 40265b8:	2005883a 	mov	r2,r4
 40265bc:	f800283a 	ret
 40265c0:	0007883a 	mov	r3,zero
 40265c4:	003ff806 	br	40265a8 <udivmodsi4+0x50>
 40265c8:	00800044 	movi	r2,1
 40265cc:	0007883a 	mov	r3,zero
 40265d0:	003fef06 	br	4026590 <udivmodsi4+0x38>

040265d4 <__divsi3>:
 40265d4:	defffe04 	addi	sp,sp,-8
 40265d8:	dc000015 	stw	r16,0(sp)
 40265dc:	dfc00115 	stw	ra,4(sp)
 40265e0:	0021883a 	mov	r16,zero
 40265e4:	20000c16 	blt	r4,zero,4026618 <__divsi3+0x44>
 40265e8:	000d883a 	mov	r6,zero
 40265ec:	28000e16 	blt	r5,zero,4026628 <__divsi3+0x54>
 40265f0:	40265580 	call	4026558 <udivmodsi4>
 40265f4:	1007883a 	mov	r3,r2
 40265f8:	8005003a 	cmpeq	r2,r16,zero
 40265fc:	1000011e 	bne	r2,zero,4026604 <__divsi3+0x30>
 4026600:	00c7c83a 	sub	r3,zero,r3
 4026604:	1805883a 	mov	r2,r3
 4026608:	dfc00117 	ldw	ra,4(sp)
 402660c:	dc000017 	ldw	r16,0(sp)
 4026610:	dec00204 	addi	sp,sp,8
 4026614:	f800283a 	ret
 4026618:	0109c83a 	sub	r4,zero,r4
 402661c:	04000044 	movi	r16,1
 4026620:	000d883a 	mov	r6,zero
 4026624:	283ff20e 	bge	r5,zero,40265f0 <__divsi3+0x1c>
 4026628:	014bc83a 	sub	r5,zero,r5
 402662c:	8021003a 	cmpeq	r16,r16,zero
 4026630:	003fef06 	br	40265f0 <__divsi3+0x1c>

04026634 <__modsi3>:
 4026634:	deffff04 	addi	sp,sp,-4
 4026638:	dfc00015 	stw	ra,0(sp)
 402663c:	01800044 	movi	r6,1
 4026640:	2807883a 	mov	r3,r5
 4026644:	20000416 	blt	r4,zero,4026658 <__modsi3+0x24>
 4026648:	28000c16 	blt	r5,zero,402667c <__modsi3+0x48>
 402664c:	dfc00017 	ldw	ra,0(sp)
 4026650:	dec00104 	addi	sp,sp,4
 4026654:	40265581 	jmpi	4026558 <udivmodsi4>
 4026658:	0109c83a 	sub	r4,zero,r4
 402665c:	28000b16 	blt	r5,zero,402668c <__modsi3+0x58>
 4026660:	180b883a 	mov	r5,r3
 4026664:	01800044 	movi	r6,1
 4026668:	40265580 	call	4026558 <udivmodsi4>
 402666c:	0085c83a 	sub	r2,zero,r2
 4026670:	dfc00017 	ldw	ra,0(sp)
 4026674:	dec00104 	addi	sp,sp,4
 4026678:	f800283a 	ret
 402667c:	014bc83a 	sub	r5,zero,r5
 4026680:	dfc00017 	ldw	ra,0(sp)
 4026684:	dec00104 	addi	sp,sp,4
 4026688:	40265581 	jmpi	4026558 <udivmodsi4>
 402668c:	0147c83a 	sub	r3,zero,r5
 4026690:	003ff306 	br	4026660 <__modsi3+0x2c>

04026694 <__udivsi3>:
 4026694:	000d883a 	mov	r6,zero
 4026698:	40265581 	jmpi	4026558 <udivmodsi4>

0402669c <__umodsi3>:
 402669c:	01800044 	movi	r6,1
 40266a0:	40265581 	jmpi	4026558 <udivmodsi4>

040266a4 <__clzsi2>:
 40266a4:	00bfffd4 	movui	r2,65535
 40266a8:	11000e36 	bltu	r2,r4,40266e4 <__clzsi2+0x40>
 40266ac:	00803fc4 	movi	r2,255
 40266b0:	01400204 	movi	r5,8
 40266b4:	0007883a 	mov	r3,zero
 40266b8:	11001036 	bltu	r2,r4,40266fc <__clzsi2+0x58>
 40266bc:	000b883a 	mov	r5,zero
 40266c0:	20c6d83a 	srl	r3,r4,r3
 40266c4:	008100f4 	movhi	r2,1027
 40266c8:	10b6ad04 	addi	r2,r2,-9548
 40266cc:	1887883a 	add	r3,r3,r2
 40266d0:	18800003 	ldbu	r2,0(r3)
 40266d4:	00c00804 	movi	r3,32
 40266d8:	2885883a 	add	r2,r5,r2
 40266dc:	1885c83a 	sub	r2,r3,r2
 40266e0:	f800283a 	ret
 40266e4:	01400404 	movi	r5,16
 40266e8:	00804034 	movhi	r2,256
 40266ec:	10bfffc4 	addi	r2,r2,-1
 40266f0:	2807883a 	mov	r3,r5
 40266f4:	113ff22e 	bgeu	r2,r4,40266c0 <__clzsi2+0x1c>
 40266f8:	01400604 	movi	r5,24
 40266fc:	2807883a 	mov	r3,r5
 4026700:	20c6d83a 	srl	r3,r4,r3
 4026704:	008100f4 	movhi	r2,1027
 4026708:	10b6ad04 	addi	r2,r2,-9548
 402670c:	1887883a 	add	r3,r3,r2
 4026710:	18800003 	ldbu	r2,0(r3)
 4026714:	00c00804 	movi	r3,32
 4026718:	2885883a 	add	r2,r5,r2
 402671c:	1885c83a 	sub	r2,r3,r2
 4026720:	f800283a 	ret

04026724 <__pack_f>:
 4026724:	20c00017 	ldw	r3,0(r4)
 4026728:	01c00044 	movi	r7,1
 402672c:	21800317 	ldw	r6,12(r4)
 4026730:	21400117 	ldw	r5,4(r4)
 4026734:	38c02d2e 	bgeu	r7,r3,40267ec <__pack_f+0xc8>
 4026738:	00800104 	movi	r2,4
 402673c:	18802826 	beq	r3,r2,40267e0 <__pack_f+0xbc>
 4026740:	00800084 	movi	r2,2
 4026744:	18800126 	beq	r3,r2,402674c <__pack_f+0x28>
 4026748:	3000101e 	bne	r6,zero,402678c <__pack_f+0x68>
 402674c:	000d883a 	mov	r6,zero
 4026750:	0007883a 	mov	r3,zero
 4026754:	19003fcc 	andi	r4,r3,255
 4026758:	200895fa 	slli	r4,r4,23
 402675c:	00c02034 	movhi	r3,128
 4026760:	18ffffc4 	addi	r3,r3,-1
 4026764:	30c6703a 	and	r3,r6,r3
 4026768:	10a0002c 	andhi	r2,r2,32768
 402676c:	10c4b03a 	or	r2,r2,r3
 4026770:	280a97fa 	slli	r5,r5,31
 4026774:	1104b03a 	or	r2,r2,r4
 4026778:	00e00034 	movhi	r3,32768
 402677c:	18ffffc4 	addi	r3,r3,-1
 4026780:	10c4703a 	and	r2,r2,r3
 4026784:	1144b03a 	or	r2,r2,r5
 4026788:	f800283a 	ret
 402678c:	21000217 	ldw	r4,8(r4)
 4026790:	00bfe084 	movi	r2,-126
 4026794:	20801b16 	blt	r4,r2,4026804 <__pack_f+0xe0>
 4026798:	00801fc4 	movi	r2,127
 402679c:	11001016 	blt	r2,r4,40267e0 <__pack_f+0xbc>
 40267a0:	308e703a 	and	r7,r6,r2
 40267a4:	2087883a 	add	r3,r4,r2
 40267a8:	00801004 	movi	r2,64
 40267ac:	38800526 	beq	r7,r2,40267c4 <__pack_f+0xa0>
 40267b0:	31800fc4 	addi	r6,r6,63
 40267b4:	30000716 	blt	r6,zero,40267d4 <__pack_f+0xb0>
 40267b8:	300490ba 	slli	r2,r6,2
 40267bc:	100cd27a 	srli	r6,r2,9
 40267c0:	003fe406 	br	4026754 <__pack_f+0x30>
 40267c4:	3080200c 	andi	r2,r6,128
 40267c8:	103ffa26 	beq	r2,zero,40267b4 <__pack_f+0x90>
 40267cc:	31cd883a 	add	r6,r6,r7
 40267d0:	003ff806 	br	40267b4 <__pack_f+0x90>
 40267d4:	300cd07a 	srli	r6,r6,1
 40267d8:	18c00044 	addi	r3,r3,1
 40267dc:	003ff606 	br	40267b8 <__pack_f+0x94>
 40267e0:	000d883a 	mov	r6,zero
 40267e4:	00ffffc4 	movi	r3,-1
 40267e8:	003fda06 	br	4026754 <__pack_f+0x30>
 40267ec:	31800434 	orhi	r6,r6,16
 40267f0:	00802034 	movhi	r2,128
 40267f4:	10bfffc4 	addi	r2,r2,-1
 40267f8:	308c703a 	and	r6,r6,r2
 40267fc:	00ffffc4 	movi	r3,-1
 4026800:	003fd406 	br	4026754 <__pack_f+0x30>
 4026804:	1109c83a 	sub	r4,r2,r4
 4026808:	00800644 	movi	r2,25
 402680c:	11001216 	blt	r2,r4,4026858 <__pack_f+0x134>
 4026810:	3904983a 	sll	r2,r7,r4
 4026814:	3106d83a 	srl	r3,r6,r4
 4026818:	10bfffc4 	addi	r2,r2,-1
 402681c:	3084703a 	and	r2,r6,r2
 4026820:	1004c03a 	cmpne	r2,r2,zero
 4026824:	1886b03a 	or	r3,r3,r2
 4026828:	19001fcc 	andi	r4,r3,127
 402682c:	00801004 	movi	r2,64
 4026830:	20800c26 	beq	r4,r2,4026864 <__pack_f+0x140>
 4026834:	18c00fc4 	addi	r3,r3,63
 4026838:	00900034 	movhi	r2,16384
 402683c:	10bfffc4 	addi	r2,r2,-1
 4026840:	180cd1fa 	srli	r6,r3,7
 4026844:	10c7803a 	cmpltu	r3,r2,r3
 4026848:	00802034 	movhi	r2,128
 402684c:	10bfffc4 	addi	r2,r2,-1
 4026850:	308c703a 	and	r6,r6,r2
 4026854:	003fbf06 	br	4026754 <__pack_f+0x30>
 4026858:	0007883a 	mov	r3,zero
 402685c:	000d883a 	mov	r6,zero
 4026860:	003ff906 	br	4026848 <__pack_f+0x124>
 4026864:	1880200c 	andi	r2,r3,128
 4026868:	10000126 	beq	r2,zero,4026870 <__pack_f+0x14c>
 402686c:	1907883a 	add	r3,r3,r4
 4026870:	180cd1fa 	srli	r6,r3,7
 4026874:	00900034 	movhi	r2,16384
 4026878:	10bfffc4 	addi	r2,r2,-1
 402687c:	10c7803a 	cmpltu	r3,r2,r3
 4026880:	003ff106 	br	4026848 <__pack_f+0x124>

04026884 <__unpack_f>:
 4026884:	21800017 	ldw	r6,0(r4)
 4026888:	00c02034 	movhi	r3,128
 402688c:	18ffffc4 	addi	r3,r3,-1
 4026890:	3004d5fa 	srli	r2,r6,23
 4026894:	3008d7fa 	srli	r4,r6,31
 4026898:	30ce703a 	and	r7,r6,r3
 402689c:	10c03fcc 	andi	r3,r2,255
 40268a0:	29000115 	stw	r4,4(r5)
 40268a4:	1800131e 	bne	r3,zero,40268f4 <__unpack_f+0x70>
 40268a8:	38000f26 	beq	r7,zero,40268e8 <__unpack_f+0x64>
 40268ac:	380691fa 	slli	r3,r7,7
 40268b0:	01bfe084 	movi	r6,-126
 40268b4:	008000c4 	movi	r2,3
 40268b8:	01100034 	movhi	r4,16384
 40268bc:	213fffc4 	addi	r4,r4,-1
 40268c0:	28800015 	stw	r2,0(r5)
 40268c4:	29800215 	stw	r6,8(r5)
 40268c8:	20c00536 	bltu	r4,r3,40268e0 <__unpack_f+0x5c>
 40268cc:	3005883a 	mov	r2,r6
 40268d0:	18c7883a 	add	r3,r3,r3
 40268d4:	10bfffc4 	addi	r2,r2,-1
 40268d8:	20fffd2e 	bgeu	r4,r3,40268d0 <__unpack_f+0x4c>
 40268dc:	28800215 	stw	r2,8(r5)
 40268e0:	28c00315 	stw	r3,12(r5)
 40268e4:	f800283a 	ret
 40268e8:	00800084 	movi	r2,2
 40268ec:	28800015 	stw	r2,0(r5)
 40268f0:	f800283a 	ret
 40268f4:	00803fc4 	movi	r2,255
 40268f8:	18800826 	beq	r3,r2,402691c <__unpack_f+0x98>
 40268fc:	380491fa 	slli	r2,r7,7
 4026900:	18ffe044 	addi	r3,r3,-127
 4026904:	28c00215 	stw	r3,8(r5)
 4026908:	10900034 	orhi	r2,r2,16384
 402690c:	28800315 	stw	r2,12(r5)
 4026910:	008000c4 	movi	r2,3
 4026914:	28800015 	stw	r2,0(r5)
 4026918:	f800283a 	ret
 402691c:	3800031e 	bne	r7,zero,402692c <__unpack_f+0xa8>
 4026920:	00800104 	movi	r2,4
 4026924:	28800015 	stw	r2,0(r5)
 4026928:	f800283a 	ret
 402692c:	3080042c 	andhi	r2,r6,16
 4026930:	10000426 	beq	r2,zero,4026944 <__unpack_f+0xc0>
 4026934:	00800044 	movi	r2,1
 4026938:	28800015 	stw	r2,0(r5)
 402693c:	29c00315 	stw	r7,12(r5)
 4026940:	f800283a 	ret
 4026944:	28000015 	stw	zero,0(r5)
 4026948:	003ffc06 	br	402693c <__unpack_f+0xb8>

0402694c <__pack_d>:
 402694c:	20c00017 	ldw	r3,0(r4)
 4026950:	defffd04 	addi	sp,sp,-12
 4026954:	dc000015 	stw	r16,0(sp)
 4026958:	dc800215 	stw	r18,8(sp)
 402695c:	dc400115 	stw	r17,4(sp)
 4026960:	00800044 	movi	r2,1
 4026964:	22000317 	ldw	r8,12(r4)
 4026968:	001f883a 	mov	r15,zero
 402696c:	22400417 	ldw	r9,16(r4)
 4026970:	24000117 	ldw	r16,4(r4)
 4026974:	10c0552e 	bgeu	r2,r3,4026acc <__pack_d+0x180>
 4026978:	00800104 	movi	r2,4
 402697c:	18804f26 	beq	r3,r2,4026abc <__pack_d+0x170>
 4026980:	00800084 	movi	r2,2
 4026984:	18800226 	beq	r3,r2,4026990 <__pack_d+0x44>
 4026988:	4244b03a 	or	r2,r8,r9
 402698c:	10001a1e 	bne	r2,zero,40269f8 <__pack_d+0xac>
 4026990:	000d883a 	mov	r6,zero
 4026994:	000f883a 	mov	r7,zero
 4026998:	0011883a 	mov	r8,zero
 402699c:	00800434 	movhi	r2,16
 40269a0:	10bfffc4 	addi	r2,r2,-1
 40269a4:	301d883a 	mov	r14,r6
 40269a8:	3884703a 	and	r2,r7,r2
 40269ac:	400a953a 	slli	r5,r8,20
 40269b0:	79bffc2c 	andhi	r6,r15,65520
 40269b4:	308cb03a 	or	r6,r6,r2
 40269b8:	00e00434 	movhi	r3,32784
 40269bc:	18ffffc4 	addi	r3,r3,-1
 40269c0:	800497fa 	slli	r2,r16,31
 40269c4:	30c6703a 	and	r3,r6,r3
 40269c8:	1946b03a 	or	r3,r3,r5
 40269cc:	01600034 	movhi	r5,32768
 40269d0:	297fffc4 	addi	r5,r5,-1
 40269d4:	194a703a 	and	r5,r3,r5
 40269d8:	288ab03a 	or	r5,r5,r2
 40269dc:	2807883a 	mov	r3,r5
 40269e0:	7005883a 	mov	r2,r14
 40269e4:	dc800217 	ldw	r18,8(sp)
 40269e8:	dc400117 	ldw	r17,4(sp)
 40269ec:	dc000017 	ldw	r16,0(sp)
 40269f0:	dec00304 	addi	sp,sp,12
 40269f4:	f800283a 	ret
 40269f8:	21000217 	ldw	r4,8(r4)
 40269fc:	00bf0084 	movi	r2,-1022
 4026a00:	20803f16 	blt	r4,r2,4026b00 <__pack_d+0x1b4>
 4026a04:	0080ffc4 	movi	r2,1023
 4026a08:	11002c16 	blt	r2,r4,4026abc <__pack_d+0x170>
 4026a0c:	00803fc4 	movi	r2,255
 4026a10:	408c703a 	and	r6,r8,r2
 4026a14:	00802004 	movi	r2,128
 4026a18:	0007883a 	mov	r3,zero
 4026a1c:	000f883a 	mov	r7,zero
 4026a20:	2280ffc4 	addi	r10,r4,1023
 4026a24:	30801e26 	beq	r6,r2,4026aa0 <__pack_d+0x154>
 4026a28:	00801fc4 	movi	r2,127
 4026a2c:	4089883a 	add	r4,r8,r2
 4026a30:	220d803a 	cmpltu	r6,r4,r8
 4026a34:	324d883a 	add	r6,r6,r9
 4026a38:	2011883a 	mov	r8,r4
 4026a3c:	3013883a 	mov	r9,r6
 4026a40:	00880034 	movhi	r2,8192
 4026a44:	10bfffc4 	addi	r2,r2,-1
 4026a48:	12400d36 	bltu	r2,r9,4026a80 <__pack_d+0x134>
 4026a4c:	4804963a 	slli	r2,r9,24
 4026a50:	400cd23a 	srli	r6,r8,8
 4026a54:	480ed23a 	srli	r7,r9,8
 4026a58:	013fffc4 	movi	r4,-1
 4026a5c:	118cb03a 	or	r6,r2,r6
 4026a60:	01400434 	movhi	r5,16
 4026a64:	297fffc4 	addi	r5,r5,-1
 4026a68:	3104703a 	and	r2,r6,r4
 4026a6c:	3946703a 	and	r3,r7,r5
 4026a70:	5201ffcc 	andi	r8,r10,2047
 4026a74:	100d883a 	mov	r6,r2
 4026a78:	180f883a 	mov	r7,r3
 4026a7c:	003fc706 	br	402699c <__pack_d+0x50>
 4026a80:	480897fa 	slli	r4,r9,31
 4026a84:	4004d07a 	srli	r2,r8,1
 4026a88:	4806d07a 	srli	r3,r9,1
 4026a8c:	52800044 	addi	r10,r10,1
 4026a90:	2084b03a 	or	r2,r4,r2
 4026a94:	1011883a 	mov	r8,r2
 4026a98:	1813883a 	mov	r9,r3
 4026a9c:	003feb06 	br	4026a4c <__pack_d+0x100>
 4026aa0:	383fe11e 	bne	r7,zero,4026a28 <__pack_d+0xdc>
 4026aa4:	01004004 	movi	r4,256
 4026aa8:	4104703a 	and	r2,r8,r4
 4026aac:	10c4b03a 	or	r2,r2,r3
 4026ab0:	103fe326 	beq	r2,zero,4026a40 <__pack_d+0xf4>
 4026ab4:	3005883a 	mov	r2,r6
 4026ab8:	003fdc06 	br	4026a2c <__pack_d+0xe0>
 4026abc:	000d883a 	mov	r6,zero
 4026ac0:	000f883a 	mov	r7,zero
 4026ac4:	0201ffc4 	movi	r8,2047
 4026ac8:	003fb406 	br	402699c <__pack_d+0x50>
 4026acc:	0005883a 	mov	r2,zero
 4026ad0:	00c00234 	movhi	r3,8
 4026ad4:	408cb03a 	or	r6,r8,r2
 4026ad8:	48ceb03a 	or	r7,r9,r3
 4026adc:	013fffc4 	movi	r4,-1
 4026ae0:	01400434 	movhi	r5,16
 4026ae4:	297fffc4 	addi	r5,r5,-1
 4026ae8:	3104703a 	and	r2,r6,r4
 4026aec:	3946703a 	and	r3,r7,r5
 4026af0:	100d883a 	mov	r6,r2
 4026af4:	180f883a 	mov	r7,r3
 4026af8:	0201ffc4 	movi	r8,2047
 4026afc:	003fa706 	br	402699c <__pack_d+0x50>
 4026b00:	1109c83a 	sub	r4,r2,r4
 4026b04:	00800e04 	movi	r2,56
 4026b08:	11004316 	blt	r2,r4,4026c18 <__pack_d+0x2cc>
 4026b0c:	21fff804 	addi	r7,r4,-32
 4026b10:	38004516 	blt	r7,zero,4026c28 <__pack_d+0x2dc>
 4026b14:	49d8d83a 	srl	r12,r9,r7
 4026b18:	001b883a 	mov	r13,zero
 4026b1c:	0023883a 	mov	r17,zero
 4026b20:	01400044 	movi	r5,1
 4026b24:	0025883a 	mov	r18,zero
 4026b28:	38004716 	blt	r7,zero,4026c48 <__pack_d+0x2fc>
 4026b2c:	29d6983a 	sll	r11,r5,r7
 4026b30:	0015883a 	mov	r10,zero
 4026b34:	00bfffc4 	movi	r2,-1
 4026b38:	5089883a 	add	r4,r10,r2
 4026b3c:	588b883a 	add	r5,r11,r2
 4026b40:	228d803a 	cmpltu	r6,r4,r10
 4026b44:	314b883a 	add	r5,r6,r5
 4026b48:	4104703a 	and	r2,r8,r4
 4026b4c:	4946703a 	and	r3,r9,r5
 4026b50:	10c4b03a 	or	r2,r2,r3
 4026b54:	10000226 	beq	r2,zero,4026b60 <__pack_d+0x214>
 4026b58:	04400044 	movi	r17,1
 4026b5c:	0025883a 	mov	r18,zero
 4026b60:	00803fc4 	movi	r2,255
 4026b64:	644eb03a 	or	r7,r12,r17
 4026b68:	3892703a 	and	r9,r7,r2
 4026b6c:	00802004 	movi	r2,128
 4026b70:	6c90b03a 	or	r8,r13,r18
 4026b74:	0015883a 	mov	r10,zero
 4026b78:	48801626 	beq	r9,r2,4026bd4 <__pack_d+0x288>
 4026b7c:	01001fc4 	movi	r4,127
 4026b80:	3905883a 	add	r2,r7,r4
 4026b84:	11cd803a 	cmpltu	r6,r2,r7
 4026b88:	320d883a 	add	r6,r6,r8
 4026b8c:	100f883a 	mov	r7,r2
 4026b90:	00840034 	movhi	r2,4096
 4026b94:	10bfffc4 	addi	r2,r2,-1
 4026b98:	3011883a 	mov	r8,r6
 4026b9c:	0007883a 	mov	r3,zero
 4026ba0:	11801b36 	bltu	r2,r6,4026c10 <__pack_d+0x2c4>
 4026ba4:	4004963a 	slli	r2,r8,24
 4026ba8:	3808d23a 	srli	r4,r7,8
 4026bac:	400ad23a 	srli	r5,r8,8
 4026bb0:	1813883a 	mov	r9,r3
 4026bb4:	1108b03a 	or	r4,r2,r4
 4026bb8:	00bfffc4 	movi	r2,-1
 4026bbc:	00c00434 	movhi	r3,16
 4026bc0:	18ffffc4 	addi	r3,r3,-1
 4026bc4:	208c703a 	and	r6,r4,r2
 4026bc8:	28ce703a 	and	r7,r5,r3
 4026bcc:	4a01ffcc 	andi	r8,r9,2047
 4026bd0:	003f7206 	br	402699c <__pack_d+0x50>
 4026bd4:	503fe91e 	bne	r10,zero,4026b7c <__pack_d+0x230>
 4026bd8:	01004004 	movi	r4,256
 4026bdc:	3904703a 	and	r2,r7,r4
 4026be0:	0007883a 	mov	r3,zero
 4026be4:	10c4b03a 	or	r2,r2,r3
 4026be8:	10000626 	beq	r2,zero,4026c04 <__pack_d+0x2b8>
 4026bec:	3a45883a 	add	r2,r7,r9
 4026bf0:	11cd803a 	cmpltu	r6,r2,r7
 4026bf4:	320d883a 	add	r6,r6,r8
 4026bf8:	100f883a 	mov	r7,r2
 4026bfc:	3011883a 	mov	r8,r6
 4026c00:	0007883a 	mov	r3,zero
 4026c04:	00840034 	movhi	r2,4096
 4026c08:	10bfffc4 	addi	r2,r2,-1
 4026c0c:	123fe52e 	bgeu	r2,r8,4026ba4 <__pack_d+0x258>
 4026c10:	00c00044 	movi	r3,1
 4026c14:	003fe306 	br	4026ba4 <__pack_d+0x258>
 4026c18:	0009883a 	mov	r4,zero
 4026c1c:	0013883a 	mov	r9,zero
 4026c20:	000b883a 	mov	r5,zero
 4026c24:	003fe406 	br	4026bb8 <__pack_d+0x26c>
 4026c28:	4a47883a 	add	r3,r9,r9
 4026c2c:	008007c4 	movi	r2,31
 4026c30:	1105c83a 	sub	r2,r2,r4
 4026c34:	1886983a 	sll	r3,r3,r2
 4026c38:	4118d83a 	srl	r12,r8,r4
 4026c3c:	491ad83a 	srl	r13,r9,r4
 4026c40:	1b18b03a 	or	r12,r3,r12
 4026c44:	003fb506 	br	4026b1c <__pack_d+0x1d0>
 4026c48:	2806d07a 	srli	r3,r5,1
 4026c4c:	008007c4 	movi	r2,31
 4026c50:	1105c83a 	sub	r2,r2,r4
 4026c54:	1896d83a 	srl	r11,r3,r2
 4026c58:	2914983a 	sll	r10,r5,r4
 4026c5c:	003fb506 	br	4026b34 <__pack_d+0x1e8>

04026c60 <free>:
 4026c60:	008100f4 	movhi	r2,1027
 4026c64:	10bd6704 	addi	r2,r2,-2660
 4026c68:	200b883a 	mov	r5,r4
 4026c6c:	11000017 	ldw	r4,0(r2)
 4026c70:	4027da81 	jmpi	4027da8 <_free_r>

04026c74 <malloc>:
 4026c74:	008100f4 	movhi	r2,1027
 4026c78:	10bd6704 	addi	r2,r2,-2660
 4026c7c:	200b883a 	mov	r5,r4
 4026c80:	11000017 	ldw	r4,0(r2)
 4026c84:	4026c881 	jmpi	4026c88 <_malloc_r>

04026c88 <_malloc_r>:
 4026c88:	defff604 	addi	sp,sp,-40
 4026c8c:	28c002c4 	addi	r3,r5,11
 4026c90:	00800584 	movi	r2,22
 4026c94:	dc800215 	stw	r18,8(sp)
 4026c98:	dfc00915 	stw	ra,36(sp)
 4026c9c:	df000815 	stw	fp,32(sp)
 4026ca0:	ddc00715 	stw	r23,28(sp)
 4026ca4:	dd800615 	stw	r22,24(sp)
 4026ca8:	dd400515 	stw	r21,20(sp)
 4026cac:	dd000415 	stw	r20,16(sp)
 4026cb0:	dcc00315 	stw	r19,12(sp)
 4026cb4:	dc400115 	stw	r17,4(sp)
 4026cb8:	dc000015 	stw	r16,0(sp)
 4026cbc:	2025883a 	mov	r18,r4
 4026cc0:	10c01236 	bltu	r2,r3,4026d0c <_malloc_r+0x84>
 4026cc4:	04400404 	movi	r17,16
 4026cc8:	8940142e 	bgeu	r17,r5,4026d1c <_malloc_r+0x94>
 4026ccc:	00800304 	movi	r2,12
 4026cd0:	0007883a 	mov	r3,zero
 4026cd4:	90800015 	stw	r2,0(r18)
 4026cd8:	1805883a 	mov	r2,r3
 4026cdc:	dfc00917 	ldw	ra,36(sp)
 4026ce0:	df000817 	ldw	fp,32(sp)
 4026ce4:	ddc00717 	ldw	r23,28(sp)
 4026ce8:	dd800617 	ldw	r22,24(sp)
 4026cec:	dd400517 	ldw	r21,20(sp)
 4026cf0:	dd000417 	ldw	r20,16(sp)
 4026cf4:	dcc00317 	ldw	r19,12(sp)
 4026cf8:	dc800217 	ldw	r18,8(sp)
 4026cfc:	dc400117 	ldw	r17,4(sp)
 4026d00:	dc000017 	ldw	r16,0(sp)
 4026d04:	dec00a04 	addi	sp,sp,40
 4026d08:	f800283a 	ret
 4026d0c:	00bffe04 	movi	r2,-8
 4026d10:	18a2703a 	and	r17,r3,r2
 4026d14:	883fed16 	blt	r17,zero,4026ccc <_malloc_r+0x44>
 4026d18:	897fec36 	bltu	r17,r5,4026ccc <_malloc_r+0x44>
 4026d1c:	9009883a 	mov	r4,r18
 4026d20:	40284ec0 	call	40284ec <__malloc_lock>
 4026d24:	00807dc4 	movi	r2,503
 4026d28:	14402b2e 	bgeu	r2,r17,4026dd8 <_malloc_r+0x150>
 4026d2c:	8806d27a 	srli	r3,r17,9
 4026d30:	18003f1e 	bne	r3,zero,4026e30 <_malloc_r+0x1a8>
 4026d34:	880cd0fa 	srli	r6,r17,3
 4026d38:	300490fa 	slli	r2,r6,3
 4026d3c:	02c100f4 	movhi	r11,1027
 4026d40:	5af76704 	addi	r11,r11,-8804
 4026d44:	12cb883a 	add	r5,r2,r11
 4026d48:	2c000317 	ldw	r16,12(r5)
 4026d4c:	580f883a 	mov	r7,r11
 4026d50:	2c00041e 	bne	r5,r16,4026d64 <_malloc_r+0xdc>
 4026d54:	00000a06 	br	4026d80 <_malloc_r+0xf8>
 4026d58:	1800860e 	bge	r3,zero,4026f74 <_malloc_r+0x2ec>
 4026d5c:	84000317 	ldw	r16,12(r16)
 4026d60:	2c000726 	beq	r5,r16,4026d80 <_malloc_r+0xf8>
 4026d64:	80800117 	ldw	r2,4(r16)
 4026d68:	00ffff04 	movi	r3,-4
 4026d6c:	10c8703a 	and	r4,r2,r3
 4026d70:	2447c83a 	sub	r3,r4,r17
 4026d74:	008003c4 	movi	r2,15
 4026d78:	10fff70e 	bge	r2,r3,4026d58 <_malloc_r+0xd0>
 4026d7c:	31bfffc4 	addi	r6,r6,-1
 4026d80:	32400044 	addi	r9,r6,1
 4026d84:	028100f4 	movhi	r10,1027
 4026d88:	52b76904 	addi	r10,r10,-8796
 4026d8c:	54000217 	ldw	r16,8(r10)
 4026d90:	8280a026 	beq	r16,r10,4027014 <_malloc_r+0x38c>
 4026d94:	80800117 	ldw	r2,4(r16)
 4026d98:	00ffff04 	movi	r3,-4
 4026d9c:	10ca703a 	and	r5,r2,r3
 4026da0:	2c4dc83a 	sub	r6,r5,r17
 4026da4:	008003c4 	movi	r2,15
 4026da8:	11808316 	blt	r2,r6,4026fb8 <_malloc_r+0x330>
 4026dac:	52800315 	stw	r10,12(r10)
 4026db0:	52800215 	stw	r10,8(r10)
 4026db4:	30002916 	blt	r6,zero,4026e5c <_malloc_r+0x1d4>
 4026db8:	8147883a 	add	r3,r16,r5
 4026dbc:	18800117 	ldw	r2,4(r3)
 4026dc0:	9009883a 	mov	r4,r18
 4026dc4:	10800054 	ori	r2,r2,1
 4026dc8:	18800115 	stw	r2,4(r3)
 4026dcc:	402850c0 	call	402850c <__malloc_unlock>
 4026dd0:	80c00204 	addi	r3,r16,8
 4026dd4:	003fc006 	br	4026cd8 <_malloc_r+0x50>
 4026dd8:	02c100f4 	movhi	r11,1027
 4026ddc:	5af76704 	addi	r11,r11,-8804
 4026de0:	8ac5883a 	add	r2,r17,r11
 4026de4:	14000317 	ldw	r16,12(r2)
 4026de8:	580f883a 	mov	r7,r11
 4026dec:	8806d0fa 	srli	r3,r17,3
 4026df0:	14006c26 	beq	r2,r16,4026fa4 <_malloc_r+0x31c>
 4026df4:	80c00117 	ldw	r3,4(r16)
 4026df8:	00bfff04 	movi	r2,-4
 4026dfc:	81800317 	ldw	r6,12(r16)
 4026e00:	1886703a 	and	r3,r3,r2
 4026e04:	80c7883a 	add	r3,r16,r3
 4026e08:	18800117 	ldw	r2,4(r3)
 4026e0c:	81400217 	ldw	r5,8(r16)
 4026e10:	9009883a 	mov	r4,r18
 4026e14:	10800054 	ori	r2,r2,1
 4026e18:	18800115 	stw	r2,4(r3)
 4026e1c:	31400215 	stw	r5,8(r6)
 4026e20:	29800315 	stw	r6,12(r5)
 4026e24:	402850c0 	call	402850c <__malloc_unlock>
 4026e28:	80c00204 	addi	r3,r16,8
 4026e2c:	003faa06 	br	4026cd8 <_malloc_r+0x50>
 4026e30:	00800104 	movi	r2,4
 4026e34:	10c0052e 	bgeu	r2,r3,4026e4c <_malloc_r+0x1c4>
 4026e38:	00800504 	movi	r2,20
 4026e3c:	10c07836 	bltu	r2,r3,4027020 <_malloc_r+0x398>
 4026e40:	198016c4 	addi	r6,r3,91
 4026e44:	300490fa 	slli	r2,r6,3
 4026e48:	003fbc06 	br	4026d3c <_malloc_r+0xb4>
 4026e4c:	8804d1ba 	srli	r2,r17,6
 4026e50:	11800e04 	addi	r6,r2,56
 4026e54:	300490fa 	slli	r2,r6,3
 4026e58:	003fb806 	br	4026d3c <_malloc_r+0xb4>
 4026e5c:	00807fc4 	movi	r2,511
 4026e60:	1140bb36 	bltu	r2,r5,4027150 <_malloc_r+0x4c8>
 4026e64:	2806d0fa 	srli	r3,r5,3
 4026e68:	573ffe04 	addi	fp,r10,-8
 4026e6c:	00800044 	movi	r2,1
 4026e70:	180890fa 	slli	r4,r3,3
 4026e74:	1807d0ba 	srai	r3,r3,2
 4026e78:	e1c00117 	ldw	r7,4(fp)
 4026e7c:	5909883a 	add	r4,r11,r4
 4026e80:	21400217 	ldw	r5,8(r4)
 4026e84:	10c4983a 	sll	r2,r2,r3
 4026e88:	81000315 	stw	r4,12(r16)
 4026e8c:	81400215 	stw	r5,8(r16)
 4026e90:	388eb03a 	or	r7,r7,r2
 4026e94:	2c000315 	stw	r16,12(r5)
 4026e98:	24000215 	stw	r16,8(r4)
 4026e9c:	e1c00115 	stw	r7,4(fp)
 4026ea0:	4807883a 	mov	r3,r9
 4026ea4:	4800cd16 	blt	r9,zero,40271dc <_malloc_r+0x554>
 4026ea8:	1807d0ba 	srai	r3,r3,2
 4026eac:	00800044 	movi	r2,1
 4026eb0:	10c8983a 	sll	r4,r2,r3
 4026eb4:	39004436 	bltu	r7,r4,4026fc8 <_malloc_r+0x340>
 4026eb8:	21c4703a 	and	r2,r4,r7
 4026ebc:	10000a1e 	bne	r2,zero,4026ee8 <_malloc_r+0x260>
 4026ec0:	2109883a 	add	r4,r4,r4
 4026ec4:	00bfff04 	movi	r2,-4
 4026ec8:	4884703a 	and	r2,r9,r2
 4026ecc:	3906703a 	and	r3,r7,r4
 4026ed0:	12400104 	addi	r9,r2,4
 4026ed4:	1800041e 	bne	r3,zero,4026ee8 <_malloc_r+0x260>
 4026ed8:	2109883a 	add	r4,r4,r4
 4026edc:	3904703a 	and	r2,r7,r4
 4026ee0:	4a400104 	addi	r9,r9,4
 4026ee4:	103ffc26 	beq	r2,zero,4026ed8 <_malloc_r+0x250>
 4026ee8:	480490fa 	slli	r2,r9,3
 4026eec:	4819883a 	mov	r12,r9
 4026ef0:	023fff04 	movi	r8,-4
 4026ef4:	589b883a 	add	r13,r11,r2
 4026ef8:	6807883a 	mov	r3,r13
 4026efc:	014003c4 	movi	r5,15
 4026f00:	1c000317 	ldw	r16,12(r3)
 4026f04:	1c00041e 	bne	r3,r16,4026f18 <_malloc_r+0x290>
 4026f08:	0000a706 	br	40271a8 <_malloc_r+0x520>
 4026f0c:	3000ab0e 	bge	r6,zero,40271bc <_malloc_r+0x534>
 4026f10:	84000317 	ldw	r16,12(r16)
 4026f14:	1c00a426 	beq	r3,r16,40271a8 <_malloc_r+0x520>
 4026f18:	80800117 	ldw	r2,4(r16)
 4026f1c:	1204703a 	and	r2,r2,r8
 4026f20:	144dc83a 	sub	r6,r2,r17
 4026f24:	29bff90e 	bge	r5,r6,4026f0c <_malloc_r+0x284>
 4026f28:	81000317 	ldw	r4,12(r16)
 4026f2c:	80c00217 	ldw	r3,8(r16)
 4026f30:	89400054 	ori	r5,r17,1
 4026f34:	8445883a 	add	r2,r16,r17
 4026f38:	20c00215 	stw	r3,8(r4)
 4026f3c:	19000315 	stw	r4,12(r3)
 4026f40:	81400115 	stw	r5,4(r16)
 4026f44:	1187883a 	add	r3,r2,r6
 4026f48:	31000054 	ori	r4,r6,1
 4026f4c:	50800315 	stw	r2,12(r10)
 4026f50:	50800215 	stw	r2,8(r10)
 4026f54:	19800015 	stw	r6,0(r3)
 4026f58:	11000115 	stw	r4,4(r2)
 4026f5c:	12800215 	stw	r10,8(r2)
 4026f60:	12800315 	stw	r10,12(r2)
 4026f64:	9009883a 	mov	r4,r18
 4026f68:	402850c0 	call	402850c <__malloc_unlock>
 4026f6c:	80c00204 	addi	r3,r16,8
 4026f70:	003f5906 	br	4026cd8 <_malloc_r+0x50>
 4026f74:	8109883a 	add	r4,r16,r4
 4026f78:	20800117 	ldw	r2,4(r4)
 4026f7c:	80c00217 	ldw	r3,8(r16)
 4026f80:	81400317 	ldw	r5,12(r16)
 4026f84:	10800054 	ori	r2,r2,1
 4026f88:	20800115 	stw	r2,4(r4)
 4026f8c:	28c00215 	stw	r3,8(r5)
 4026f90:	19400315 	stw	r5,12(r3)
 4026f94:	9009883a 	mov	r4,r18
 4026f98:	402850c0 	call	402850c <__malloc_unlock>
 4026f9c:	80c00204 	addi	r3,r16,8
 4026fa0:	003f4d06 	br	4026cd8 <_malloc_r+0x50>
 4026fa4:	80800204 	addi	r2,r16,8
 4026fa8:	14000317 	ldw	r16,12(r2)
 4026fac:	143f911e 	bne	r2,r16,4026df4 <_malloc_r+0x16c>
 4026fb0:	1a400084 	addi	r9,r3,2
 4026fb4:	003f7306 	br	4026d84 <_malloc_r+0xfc>
 4026fb8:	88c00054 	ori	r3,r17,1
 4026fbc:	8445883a 	add	r2,r16,r17
 4026fc0:	80c00115 	stw	r3,4(r16)
 4026fc4:	003fdf06 	br	4026f44 <_malloc_r+0x2bc>
 4026fc8:	e4000217 	ldw	r16,8(fp)
 4026fcc:	00bfff04 	movi	r2,-4
 4026fd0:	80c00117 	ldw	r3,4(r16)
 4026fd4:	802d883a 	mov	r22,r16
 4026fd8:	18aa703a 	and	r21,r3,r2
 4026fdc:	ac401636 	bltu	r21,r17,4027038 <_malloc_r+0x3b0>
 4026fe0:	ac49c83a 	sub	r4,r21,r17
 4026fe4:	008003c4 	movi	r2,15
 4026fe8:	1100130e 	bge	r2,r4,4027038 <_malloc_r+0x3b0>
 4026fec:	88800054 	ori	r2,r17,1
 4026ff0:	8447883a 	add	r3,r16,r17
 4026ff4:	80800115 	stw	r2,4(r16)
 4026ff8:	20800054 	ori	r2,r4,1
 4026ffc:	18800115 	stw	r2,4(r3)
 4027000:	e0c00215 	stw	r3,8(fp)
 4027004:	9009883a 	mov	r4,r18
 4027008:	402850c0 	call	402850c <__malloc_unlock>
 402700c:	80c00204 	addi	r3,r16,8
 4027010:	003f3106 	br	4026cd8 <_malloc_r+0x50>
 4027014:	39c00117 	ldw	r7,4(r7)
 4027018:	573ffe04 	addi	fp,r10,-8
 402701c:	003fa006 	br	4026ea0 <_malloc_r+0x218>
 4027020:	00801504 	movi	r2,84
 4027024:	10c06736 	bltu	r2,r3,40271c4 <_malloc_r+0x53c>
 4027028:	8804d33a 	srli	r2,r17,12
 402702c:	11801b84 	addi	r6,r2,110
 4027030:	300490fa 	slli	r2,r6,3
 4027034:	003f4106 	br	4026d3c <_malloc_r+0xb4>
 4027038:	d0a6c617 	ldw	r2,-25832(gp)
 402703c:	d0e00d17 	ldw	r3,-32716(gp)
 4027040:	053fffc4 	movi	r20,-1
 4027044:	10800404 	addi	r2,r2,16
 4027048:	88a7883a 	add	r19,r17,r2
 402704c:	1d000326 	beq	r3,r20,402705c <_malloc_r+0x3d4>
 4027050:	98c01fc4 	addi	r3,r19,127
 4027054:	00bfe004 	movi	r2,-128
 4027058:	18a6703a 	and	r19,r3,r2
 402705c:	9009883a 	mov	r4,r18
 4027060:	980b883a 	mov	r5,r19
 4027064:	40275740 	call	4027574 <_sbrk_r>
 4027068:	1009883a 	mov	r4,r2
 402706c:	15000426 	beq	r2,r20,4027080 <_malloc_r+0x3f8>
 4027070:	854b883a 	add	r5,r16,r21
 4027074:	1029883a 	mov	r20,r2
 4027078:	11405a2e 	bgeu	r2,r5,40271e4 <_malloc_r+0x55c>
 402707c:	87000c26 	beq	r16,fp,40270b0 <_malloc_r+0x428>
 4027080:	e4000217 	ldw	r16,8(fp)
 4027084:	80c00117 	ldw	r3,4(r16)
 4027088:	00bfff04 	movi	r2,-4
 402708c:	1884703a 	and	r2,r3,r2
 4027090:	14400336 	bltu	r2,r17,40270a0 <_malloc_r+0x418>
 4027094:	1449c83a 	sub	r4,r2,r17
 4027098:	008003c4 	movi	r2,15
 402709c:	113fd316 	blt	r2,r4,4026fec <_malloc_r+0x364>
 40270a0:	9009883a 	mov	r4,r18
 40270a4:	402850c0 	call	402850c <__malloc_unlock>
 40270a8:	0007883a 	mov	r3,zero
 40270ac:	003f0a06 	br	4026cd8 <_malloc_r+0x50>
 40270b0:	05c100f4 	movhi	r23,1027
 40270b4:	bdc42f04 	addi	r23,r23,4284
 40270b8:	b8800017 	ldw	r2,0(r23)
 40270bc:	988d883a 	add	r6,r19,r2
 40270c0:	b9800015 	stw	r6,0(r23)
 40270c4:	d0e00d17 	ldw	r3,-32716(gp)
 40270c8:	00bfffc4 	movi	r2,-1
 40270cc:	18808e26 	beq	r3,r2,4027308 <_malloc_r+0x680>
 40270d0:	2145c83a 	sub	r2,r4,r5
 40270d4:	3085883a 	add	r2,r6,r2
 40270d8:	b8800015 	stw	r2,0(r23)
 40270dc:	20c001cc 	andi	r3,r4,7
 40270e0:	18005f1e 	bne	r3,zero,4027260 <_malloc_r+0x5d8>
 40270e4:	000b883a 	mov	r5,zero
 40270e8:	a4c5883a 	add	r2,r20,r19
 40270ec:	10801fcc 	andi	r2,r2,127
 40270f0:	00c02004 	movi	r3,128
 40270f4:	1887c83a 	sub	r3,r3,r2
 40270f8:	28e7883a 	add	r19,r5,r3
 40270fc:	9009883a 	mov	r4,r18
 4027100:	980b883a 	mov	r5,r19
 4027104:	40275740 	call	4027574 <_sbrk_r>
 4027108:	1007883a 	mov	r3,r2
 402710c:	00bfffc4 	movi	r2,-1
 4027110:	18807a26 	beq	r3,r2,40272fc <_malloc_r+0x674>
 4027114:	1d05c83a 	sub	r2,r3,r20
 4027118:	9885883a 	add	r2,r19,r2
 402711c:	10c00054 	ori	r3,r2,1
 4027120:	b8800017 	ldw	r2,0(r23)
 4027124:	a021883a 	mov	r16,r20
 4027128:	a0c00115 	stw	r3,4(r20)
 402712c:	9885883a 	add	r2,r19,r2
 4027130:	b8800015 	stw	r2,0(r23)
 4027134:	e5000215 	stw	r20,8(fp)
 4027138:	b7003626 	beq	r22,fp,4027214 <_malloc_r+0x58c>
 402713c:	018003c4 	movi	r6,15
 4027140:	35404b36 	bltu	r6,r21,4027270 <_malloc_r+0x5e8>
 4027144:	00800044 	movi	r2,1
 4027148:	a0800115 	stw	r2,4(r20)
 402714c:	003fcd06 	br	4027084 <_malloc_r+0x3fc>
 4027150:	2808d27a 	srli	r4,r5,9
 4027154:	2000371e 	bne	r4,zero,4027234 <_malloc_r+0x5ac>
 4027158:	2808d0fa 	srli	r4,r5,3
 402715c:	200690fa 	slli	r3,r4,3
 4027160:	58d1883a 	add	r8,r11,r3
 4027164:	41800217 	ldw	r6,8(r8)
 4027168:	41805b26 	beq	r8,r6,40272d8 <_malloc_r+0x650>
 402716c:	30800117 	ldw	r2,4(r6)
 4027170:	00ffff04 	movi	r3,-4
 4027174:	10c4703a 	and	r2,r2,r3
 4027178:	2880022e 	bgeu	r5,r2,4027184 <_malloc_r+0x4fc>
 402717c:	31800217 	ldw	r6,8(r6)
 4027180:	41bffa1e 	bne	r8,r6,402716c <_malloc_r+0x4e4>
 4027184:	32000317 	ldw	r8,12(r6)
 4027188:	39c00117 	ldw	r7,4(r7)
 402718c:	82000315 	stw	r8,12(r16)
 4027190:	81800215 	stw	r6,8(r16)
 4027194:	070100f4 	movhi	fp,1027
 4027198:	e7376704 	addi	fp,fp,-8804
 402719c:	34000315 	stw	r16,12(r6)
 40271a0:	44000215 	stw	r16,8(r8)
 40271a4:	003f3e06 	br	4026ea0 <_malloc_r+0x218>
 40271a8:	63000044 	addi	r12,r12,1
 40271ac:	608000cc 	andi	r2,r12,3
 40271b0:	10005d26 	beq	r2,zero,4027328 <_malloc_r+0x6a0>
 40271b4:	18c00204 	addi	r3,r3,8
 40271b8:	003f5106 	br	4026f00 <_malloc_r+0x278>
 40271bc:	8089883a 	add	r4,r16,r2
 40271c0:	003f6d06 	br	4026f78 <_malloc_r+0x2f0>
 40271c4:	00805504 	movi	r2,340
 40271c8:	10c02036 	bltu	r2,r3,402724c <_malloc_r+0x5c4>
 40271cc:	8804d3fa 	srli	r2,r17,15
 40271d0:	11801dc4 	addi	r6,r2,119
 40271d4:	300490fa 	slli	r2,r6,3
 40271d8:	003ed806 	br	4026d3c <_malloc_r+0xb4>
 40271dc:	48c000c4 	addi	r3,r9,3
 40271e0:	003f3106 	br	4026ea8 <_malloc_r+0x220>
 40271e4:	05c100f4 	movhi	r23,1027
 40271e8:	bdc42f04 	addi	r23,r23,4284
 40271ec:	b8800017 	ldw	r2,0(r23)
 40271f0:	988d883a 	add	r6,r19,r2
 40271f4:	b9800015 	stw	r6,0(r23)
 40271f8:	293fb21e 	bne	r5,r4,40270c4 <_malloc_r+0x43c>
 40271fc:	20801fcc 	andi	r2,r4,127
 4027200:	103fb01e 	bne	r2,zero,40270c4 <_malloc_r+0x43c>
 4027204:	e4000217 	ldw	r16,8(fp)
 4027208:	9d45883a 	add	r2,r19,r21
 402720c:	10800054 	ori	r2,r2,1
 4027210:	80800115 	stw	r2,4(r16)
 4027214:	b8c00017 	ldw	r3,0(r23)
 4027218:	d0a6c717 	ldw	r2,-25828(gp)
 402721c:	10c0012e 	bgeu	r2,r3,4027224 <_malloc_r+0x59c>
 4027220:	d0e6c715 	stw	r3,-25828(gp)
 4027224:	d0a6c817 	ldw	r2,-25824(gp)
 4027228:	10ff962e 	bgeu	r2,r3,4027084 <_malloc_r+0x3fc>
 402722c:	d0e6c815 	stw	r3,-25824(gp)
 4027230:	003f9406 	br	4027084 <_malloc_r+0x3fc>
 4027234:	00800104 	movi	r2,4
 4027238:	11001e36 	bltu	r2,r4,40272b4 <_malloc_r+0x62c>
 402723c:	2804d1ba 	srli	r2,r5,6
 4027240:	11000e04 	addi	r4,r2,56
 4027244:	200690fa 	slli	r3,r4,3
 4027248:	003fc506 	br	4027160 <_malloc_r+0x4d8>
 402724c:	00815504 	movi	r2,1364
 4027250:	10c01d2e 	bgeu	r2,r3,40272c8 <_malloc_r+0x640>
 4027254:	01801f84 	movi	r6,126
 4027258:	0080fc04 	movi	r2,1008
 402725c:	003eb706 	br	4026d3c <_malloc_r+0xb4>
 4027260:	00800204 	movi	r2,8
 4027264:	10cbc83a 	sub	r5,r2,r3
 4027268:	2169883a 	add	r20,r4,r5
 402726c:	003f9e06 	br	40270e8 <_malloc_r+0x460>
 4027270:	00bffe04 	movi	r2,-8
 4027274:	a93ffd04 	addi	r4,r21,-12
 4027278:	2088703a 	and	r4,r4,r2
 402727c:	b10b883a 	add	r5,r22,r4
 4027280:	00c00144 	movi	r3,5
 4027284:	28c00215 	stw	r3,8(r5)
 4027288:	28c00115 	stw	r3,4(r5)
 402728c:	b0800117 	ldw	r2,4(r22)
 4027290:	1080004c 	andi	r2,r2,1
 4027294:	2084b03a 	or	r2,r4,r2
 4027298:	b0800115 	stw	r2,4(r22)
 402729c:	313fdd2e 	bgeu	r6,r4,4027214 <_malloc_r+0x58c>
 40272a0:	b1400204 	addi	r5,r22,8
 40272a4:	9009883a 	mov	r4,r18
 40272a8:	4027da80 	call	4027da8 <_free_r>
 40272ac:	e4000217 	ldw	r16,8(fp)
 40272b0:	003fd806 	br	4027214 <_malloc_r+0x58c>
 40272b4:	00800504 	movi	r2,20
 40272b8:	11001536 	bltu	r2,r4,4027310 <_malloc_r+0x688>
 40272bc:	210016c4 	addi	r4,r4,91
 40272c0:	200690fa 	slli	r3,r4,3
 40272c4:	003fa606 	br	4027160 <_malloc_r+0x4d8>
 40272c8:	8804d4ba 	srli	r2,r17,18
 40272cc:	11801f04 	addi	r6,r2,124
 40272d0:	300490fa 	slli	r2,r6,3
 40272d4:	003e9906 	br	4026d3c <_malloc_r+0xb4>
 40272d8:	2009d0ba 	srai	r4,r4,2
 40272dc:	014100f4 	movhi	r5,1027
 40272e0:	29776704 	addi	r5,r5,-8804
 40272e4:	00c00044 	movi	r3,1
 40272e8:	28800117 	ldw	r2,4(r5)
 40272ec:	1906983a 	sll	r3,r3,r4
 40272f0:	10c4b03a 	or	r2,r2,r3
 40272f4:	28800115 	stw	r2,4(r5)
 40272f8:	003fa306 	br	4027188 <_malloc_r+0x500>
 40272fc:	0027883a 	mov	r19,zero
 4027300:	00c00044 	movi	r3,1
 4027304:	003f8606 	br	4027120 <_malloc_r+0x498>
 4027308:	d1200d15 	stw	r4,-32716(gp)
 402730c:	003f7306 	br	40270dc <_malloc_r+0x454>
 4027310:	00801504 	movi	r2,84
 4027314:	11001936 	bltu	r2,r4,402737c <_malloc_r+0x6f4>
 4027318:	2804d33a 	srli	r2,r5,12
 402731c:	11001b84 	addi	r4,r2,110
 4027320:	200690fa 	slli	r3,r4,3
 4027324:	003f8e06 	br	4027160 <_malloc_r+0x4d8>
 4027328:	480b883a 	mov	r5,r9
 402732c:	6807883a 	mov	r3,r13
 4027330:	288000cc 	andi	r2,r5,3
 4027334:	18fffe04 	addi	r3,r3,-8
 4027338:	297fffc4 	addi	r5,r5,-1
 402733c:	10001526 	beq	r2,zero,4027394 <_malloc_r+0x70c>
 4027340:	18800217 	ldw	r2,8(r3)
 4027344:	10fffa26 	beq	r2,r3,4027330 <_malloc_r+0x6a8>
 4027348:	2109883a 	add	r4,r4,r4
 402734c:	393f1e36 	bltu	r7,r4,4026fc8 <_malloc_r+0x340>
 4027350:	203f1d26 	beq	r4,zero,4026fc8 <_malloc_r+0x340>
 4027354:	21c4703a 	and	r2,r4,r7
 4027358:	10000226 	beq	r2,zero,4027364 <_malloc_r+0x6dc>
 402735c:	6013883a 	mov	r9,r12
 4027360:	003ee106 	br	4026ee8 <_malloc_r+0x260>
 4027364:	2109883a 	add	r4,r4,r4
 4027368:	3904703a 	and	r2,r7,r4
 402736c:	63000104 	addi	r12,r12,4
 4027370:	103ffc26 	beq	r2,zero,4027364 <_malloc_r+0x6dc>
 4027374:	6013883a 	mov	r9,r12
 4027378:	003edb06 	br	4026ee8 <_malloc_r+0x260>
 402737c:	00805504 	movi	r2,340
 4027380:	11000836 	bltu	r2,r4,40273a4 <_malloc_r+0x71c>
 4027384:	2804d3fa 	srli	r2,r5,15
 4027388:	11001dc4 	addi	r4,r2,119
 402738c:	200690fa 	slli	r3,r4,3
 4027390:	003f7306 	br	4027160 <_malloc_r+0x4d8>
 4027394:	0104303a 	nor	r2,zero,r4
 4027398:	388e703a 	and	r7,r7,r2
 402739c:	e1c00115 	stw	r7,4(fp)
 40273a0:	003fe906 	br	4027348 <_malloc_r+0x6c0>
 40273a4:	00815504 	movi	r2,1364
 40273a8:	1100032e 	bgeu	r2,r4,40273b8 <_malloc_r+0x730>
 40273ac:	01001f84 	movi	r4,126
 40273b0:	00c0fc04 	movi	r3,1008
 40273b4:	003f6a06 	br	4027160 <_malloc_r+0x4d8>
 40273b8:	2804d4ba 	srli	r2,r5,18
 40273bc:	11001f04 	addi	r4,r2,124
 40273c0:	200690fa 	slli	r3,r4,3
 40273c4:	003f6606 	br	4027160 <_malloc_r+0x4d8>

040273c8 <memcpy>:
 40273c8:	2011883a 	mov	r8,r4
 40273cc:	30000726 	beq	r6,zero,40273ec <memcpy+0x24>
 40273d0:	000f883a 	mov	r7,zero
 40273d4:	29c5883a 	add	r2,r5,r7
 40273d8:	11000003 	ldbu	r4,0(r2)
 40273dc:	41c7883a 	add	r3,r8,r7
 40273e0:	39c00044 	addi	r7,r7,1
 40273e4:	19000005 	stb	r4,0(r3)
 40273e8:	39bffa1e 	bne	r7,r6,40273d4 <memcpy+0xc>
 40273ec:	4005883a 	mov	r2,r8
 40273f0:	f800283a 	ret

040273f4 <memset>:
 40273f4:	30000526 	beq	r6,zero,402740c <memset+0x18>
 40273f8:	310d883a 	add	r6,r6,r4
 40273fc:	2005883a 	mov	r2,r4
 4027400:	11400005 	stb	r5,0(r2)
 4027404:	10800044 	addi	r2,r2,1
 4027408:	11bffd1e 	bne	r2,r6,4027400 <memset+0xc>
 402740c:	2005883a 	mov	r2,r4
 4027410:	f800283a 	ret

04027414 <printf>:
 4027414:	defffb04 	addi	sp,sp,-20
 4027418:	dfc00115 	stw	ra,4(sp)
 402741c:	d9400215 	stw	r5,8(sp)
 4027420:	d9800315 	stw	r6,12(sp)
 4027424:	d9c00415 	stw	r7,16(sp)
 4027428:	008100f4 	movhi	r2,1027
 402742c:	10bd6704 	addi	r2,r2,-2660
 4027430:	11400017 	ldw	r5,0(r2)
 4027434:	d8800204 	addi	r2,sp,8
 4027438:	d8800015 	stw	r2,0(sp)
 402743c:	29c00217 	ldw	r7,8(r5)
 4027440:	100d883a 	mov	r6,r2
 4027444:	008100f4 	movhi	r2,1027
 4027448:	10a02f04 	addi	r2,r2,-32580
 402744c:	200b883a 	mov	r5,r4
 4027450:	38800115 	stw	r2,4(r7)
 4027454:	3809883a 	mov	r4,r7
 4027458:	4027c580 	call	4027c58 <__vfprintf_internal>
 402745c:	dfc00117 	ldw	ra,4(sp)
 4027460:	dec00504 	addi	sp,sp,20
 4027464:	f800283a 	ret

04027468 <_printf_r>:
 4027468:	defffc04 	addi	sp,sp,-16
 402746c:	dfc00115 	stw	ra,4(sp)
 4027470:	d9800215 	stw	r6,8(sp)
 4027474:	d9c00315 	stw	r7,12(sp)
 4027478:	22000217 	ldw	r8,8(r4)
 402747c:	d8800204 	addi	r2,sp,8
 4027480:	d8800015 	stw	r2,0(sp)
 4027484:	100f883a 	mov	r7,r2
 4027488:	008100f4 	movhi	r2,1027
 402748c:	10a02f04 	addi	r2,r2,-32580
 4027490:	280d883a 	mov	r6,r5
 4027494:	40800115 	stw	r2,4(r8)
 4027498:	400b883a 	mov	r5,r8
 402749c:	40276840 	call	4027684 <___vfprintf_internal_r>
 40274a0:	dfc00117 	ldw	ra,4(sp)
 40274a4:	dec00404 	addi	sp,sp,16
 40274a8:	f800283a 	ret

040274ac <putchar>:
 40274ac:	008100f4 	movhi	r2,1027
 40274b0:	10bd6704 	addi	r2,r2,-2660
 40274b4:	11800017 	ldw	r6,0(r2)
 40274b8:	200b883a 	mov	r5,r4
 40274bc:	3009883a 	mov	r4,r6
 40274c0:	31800217 	ldw	r6,8(r6)
 40274c4:	40281e81 	jmpi	40281e8 <_putc_r>

040274c8 <_putchar_r>:
 40274c8:	21800217 	ldw	r6,8(r4)
 40274cc:	40281e81 	jmpi	40281e8 <_putc_r>

040274d0 <_puts_r>:
 40274d0:	defffd04 	addi	sp,sp,-12
 40274d4:	dc000015 	stw	r16,0(sp)
 40274d8:	2021883a 	mov	r16,r4
 40274dc:	2809883a 	mov	r4,r5
 40274e0:	dfc00215 	stw	ra,8(sp)
 40274e4:	dc400115 	stw	r17,4(sp)
 40274e8:	2823883a 	mov	r17,r5
 40274ec:	40275e40 	call	40275e4 <strlen>
 40274f0:	80c00217 	ldw	r3,8(r16)
 40274f4:	020100f4 	movhi	r8,1027
 40274f8:	42202f04 	addi	r8,r8,-32580
 40274fc:	880d883a 	mov	r6,r17
 4027500:	100f883a 	mov	r7,r2
 4027504:	8009883a 	mov	r4,r16
 4027508:	180b883a 	mov	r5,r3
 402750c:	1a000115 	stw	r8,4(r3)
 4027510:	403ee83a 	callr	r8
 4027514:	047fffc4 	movi	r17,-1
 4027518:	8009883a 	mov	r4,r16
 402751c:	018100f4 	movhi	r6,1027
 4027520:	31b5df04 	addi	r6,r6,-10372
 4027524:	01c00044 	movi	r7,1
 4027528:	1440071e 	bne	r2,r17,4027548 <_puts_r+0x78>
 402752c:	00ffffc4 	movi	r3,-1
 4027530:	1805883a 	mov	r2,r3
 4027534:	dfc00217 	ldw	ra,8(sp)
 4027538:	dc400117 	ldw	r17,4(sp)
 402753c:	dc000017 	ldw	r16,0(sp)
 4027540:	dec00304 	addi	sp,sp,12
 4027544:	f800283a 	ret
 4027548:	81400217 	ldw	r5,8(r16)
 402754c:	28c00117 	ldw	r3,4(r5)
 4027550:	183ee83a 	callr	r3
 4027554:	0007883a 	mov	r3,zero
 4027558:	147ff51e 	bne	r2,r17,4027530 <_puts_r+0x60>
 402755c:	003ff306 	br	402752c <_puts_r+0x5c>

04027560 <puts>:
 4027560:	008100f4 	movhi	r2,1027
 4027564:	10bd6704 	addi	r2,r2,-2660
 4027568:	200b883a 	mov	r5,r4
 402756c:	11000017 	ldw	r4,0(r2)
 4027570:	40274d01 	jmpi	40274d0 <_puts_r>

04027574 <_sbrk_r>:
 4027574:	defffd04 	addi	sp,sp,-12
 4027578:	dc000015 	stw	r16,0(sp)
 402757c:	040100f4 	movhi	r16,1027
 4027580:	84042204 	addi	r16,r16,4232
 4027584:	dc400115 	stw	r17,4(sp)
 4027588:	80000015 	stw	zero,0(r16)
 402758c:	2023883a 	mov	r17,r4
 4027590:	2809883a 	mov	r4,r5
 4027594:	dfc00215 	stw	ra,8(sp)
 4027598:	402852c0 	call	402852c <sbrk>
 402759c:	1007883a 	mov	r3,r2
 40275a0:	00bfffc4 	movi	r2,-1
 40275a4:	18800626 	beq	r3,r2,40275c0 <_sbrk_r+0x4c>
 40275a8:	1805883a 	mov	r2,r3
 40275ac:	dfc00217 	ldw	ra,8(sp)
 40275b0:	dc400117 	ldw	r17,4(sp)
 40275b4:	dc000017 	ldw	r16,0(sp)
 40275b8:	dec00304 	addi	sp,sp,12
 40275bc:	f800283a 	ret
 40275c0:	80800017 	ldw	r2,0(r16)
 40275c4:	103ff826 	beq	r2,zero,40275a8 <_sbrk_r+0x34>
 40275c8:	88800015 	stw	r2,0(r17)
 40275cc:	1805883a 	mov	r2,r3
 40275d0:	dfc00217 	ldw	ra,8(sp)
 40275d4:	dc400117 	ldw	r17,4(sp)
 40275d8:	dc000017 	ldw	r16,0(sp)
 40275dc:	dec00304 	addi	sp,sp,12
 40275e0:	f800283a 	ret

040275e4 <strlen>:
 40275e4:	20800007 	ldb	r2,0(r4)
 40275e8:	10000526 	beq	r2,zero,4027600 <strlen+0x1c>
 40275ec:	2007883a 	mov	r3,r4
 40275f0:	18c00044 	addi	r3,r3,1
 40275f4:	18800007 	ldb	r2,0(r3)
 40275f8:	103ffd1e 	bne	r2,zero,40275f0 <strlen+0xc>
 40275fc:	1905c83a 	sub	r2,r3,r4
 4027600:	f800283a 	ret

04027604 <print_repeat>:
 4027604:	defffb04 	addi	sp,sp,-20
 4027608:	dc800315 	stw	r18,12(sp)
 402760c:	dc400215 	stw	r17,8(sp)
 4027610:	dc000115 	stw	r16,4(sp)
 4027614:	dfc00415 	stw	ra,16(sp)
 4027618:	2025883a 	mov	r18,r4
 402761c:	2823883a 	mov	r17,r5
 4027620:	3821883a 	mov	r16,r7
 4027624:	d9800005 	stb	r6,0(sp)
 4027628:	9009883a 	mov	r4,r18
 402762c:	880b883a 	mov	r5,r17
 4027630:	d80d883a 	mov	r6,sp
 4027634:	01c00044 	movi	r7,1
 4027638:	04000b0e 	bge	zero,r16,4027668 <print_repeat+0x64>
 402763c:	88c00117 	ldw	r3,4(r17)
 4027640:	843fffc4 	addi	r16,r16,-1
 4027644:	183ee83a 	callr	r3
 4027648:	103ff726 	beq	r2,zero,4027628 <print_repeat+0x24>
 402764c:	00bfffc4 	movi	r2,-1
 4027650:	dfc00417 	ldw	ra,16(sp)
 4027654:	dc800317 	ldw	r18,12(sp)
 4027658:	dc400217 	ldw	r17,8(sp)
 402765c:	dc000117 	ldw	r16,4(sp)
 4027660:	dec00504 	addi	sp,sp,20
 4027664:	f800283a 	ret
 4027668:	0005883a 	mov	r2,zero
 402766c:	dfc00417 	ldw	ra,16(sp)
 4027670:	dc800317 	ldw	r18,12(sp)
 4027674:	dc400217 	ldw	r17,8(sp)
 4027678:	dc000117 	ldw	r16,4(sp)
 402767c:	dec00504 	addi	sp,sp,20
 4027680:	f800283a 	ret

04027684 <___vfprintf_internal_r>:
 4027684:	deffec04 	addi	sp,sp,-80
 4027688:	ddc01115 	stw	r23,68(sp)
 402768c:	dd801015 	stw	r22,64(sp)
 4027690:	dcc00d15 	stw	r19,52(sp)
 4027694:	dc800c15 	stw	r18,48(sp)
 4027698:	dc000a15 	stw	r16,40(sp)
 402769c:	dfc01315 	stw	ra,76(sp)
 40276a0:	df001215 	stw	fp,72(sp)
 40276a4:	dd400f15 	stw	r21,60(sp)
 40276a8:	dd000e15 	stw	r20,56(sp)
 40276ac:	dc400b15 	stw	r17,44(sp)
 40276b0:	d9000915 	stw	r4,36(sp)
 40276b4:	282d883a 	mov	r22,r5
 40276b8:	3825883a 	mov	r18,r7
 40276bc:	3027883a 	mov	r19,r6
 40276c0:	0021883a 	mov	r16,zero
 40276c4:	d8000815 	stw	zero,32(sp)
 40276c8:	d8000715 	stw	zero,28(sp)
 40276cc:	002f883a 	mov	r23,zero
 40276d0:	d8000615 	stw	zero,24(sp)
 40276d4:	d8000515 	stw	zero,20(sp)
 40276d8:	d8000415 	stw	zero,16(sp)
 40276dc:	d8000315 	stw	zero,12(sp)
 40276e0:	d8000215 	stw	zero,8(sp)
 40276e4:	99400003 	ldbu	r5,0(r19)
 40276e8:	01c00044 	movi	r7,1
 40276ec:	9cc00044 	addi	r19,r19,1
 40276f0:	29003fcc 	andi	r4,r5,255
 40276f4:	2100201c 	xori	r4,r4,128
 40276f8:	213fe004 	addi	r4,r4,-128
 40276fc:	20001626 	beq	r4,zero,4027758 <___vfprintf_internal_r+0xd4>
 4027700:	81c02226 	beq	r16,r7,402778c <___vfprintf_internal_r+0x108>
 4027704:	00800084 	movi	r2,2
 4027708:	80802526 	beq	r16,r2,40277a0 <___vfprintf_internal_r+0x11c>
 402770c:	803ff51e 	bne	r16,zero,40276e4 <___vfprintf_internal_r+0x60>
 4027710:	00800944 	movi	r2,37
 4027714:	20811e1e 	bne	r4,r2,4027b90 <___vfprintf_internal_r+0x50c>
 4027718:	05ffffc4 	movi	r23,-1
 402771c:	00800284 	movi	r2,10
 4027720:	d9c00415 	stw	r7,16(sp)
 4027724:	d8000815 	stw	zero,32(sp)
 4027728:	d8000715 	stw	zero,28(sp)
 402772c:	ddc00615 	stw	r23,24(sp)
 4027730:	d8800515 	stw	r2,20(sp)
 4027734:	d8000315 	stw	zero,12(sp)
 4027738:	99400003 	ldbu	r5,0(r19)
 402773c:	3821883a 	mov	r16,r7
 4027740:	9cc00044 	addi	r19,r19,1
 4027744:	29003fcc 	andi	r4,r5,255
 4027748:	2100201c 	xori	r4,r4,128
 402774c:	213fe004 	addi	r4,r4,-128
 4027750:	01c00044 	movi	r7,1
 4027754:	203fea1e 	bne	r4,zero,4027700 <___vfprintf_internal_r+0x7c>
 4027758:	d8800217 	ldw	r2,8(sp)
 402775c:	dfc01317 	ldw	ra,76(sp)
 4027760:	df001217 	ldw	fp,72(sp)
 4027764:	ddc01117 	ldw	r23,68(sp)
 4027768:	dd801017 	ldw	r22,64(sp)
 402776c:	dd400f17 	ldw	r21,60(sp)
 4027770:	dd000e17 	ldw	r20,56(sp)
 4027774:	dcc00d17 	ldw	r19,52(sp)
 4027778:	dc800c17 	ldw	r18,48(sp)
 402777c:	dc400b17 	ldw	r17,44(sp)
 4027780:	dc000a17 	ldw	r16,40(sp)
 4027784:	dec01404 	addi	sp,sp,80
 4027788:	f800283a 	ret
 402778c:	00800c04 	movi	r2,48
 4027790:	20805d26 	beq	r4,r2,4027908 <___vfprintf_internal_r+0x284>
 4027794:	00800944 	movi	r2,37
 4027798:	20810a26 	beq	r4,r2,4027bc4 <___vfprintf_internal_r+0x540>
 402779c:	04000084 	movi	r16,2
 40277a0:	00800b84 	movi	r2,46
 40277a4:	20805626 	beq	r4,r2,4027900 <___vfprintf_internal_r+0x27c>
 40277a8:	29bff404 	addi	r6,r5,-48
 40277ac:	30c03fcc 	andi	r3,r6,255
 40277b0:	00800244 	movi	r2,9
 40277b4:	10c00b36 	bltu	r2,r3,40277e4 <___vfprintf_internal_r+0x160>
 40277b8:	d8c00617 	ldw	r3,24(sp)
 40277bc:	3005883a 	mov	r2,r6
 40277c0:	18005716 	blt	r3,zero,4027920 <___vfprintf_internal_r+0x29c>
 40277c4:	d8800617 	ldw	r2,24(sp)
 40277c8:	10c002a4 	muli	r3,r2,10
 40277cc:	30803fcc 	andi	r2,r6,255
 40277d0:	1080201c 	xori	r2,r2,128
 40277d4:	10bfe004 	addi	r2,r2,-128
 40277d8:	1887883a 	add	r3,r3,r2
 40277dc:	d8c00615 	stw	r3,24(sp)
 40277e0:	003fc006 	br	40276e4 <___vfprintf_internal_r+0x60>
 40277e4:	00801b04 	movi	r2,108
 40277e8:	20804a26 	beq	r4,r2,4027914 <___vfprintf_internal_r+0x290>
 40277ec:	28bfea04 	addi	r2,r5,-88
 40277f0:	10803fcc 	andi	r2,r2,255
 40277f4:	00c00804 	movi	r3,32
 40277f8:	18803f36 	bltu	r3,r2,40278f8 <___vfprintf_internal_r+0x274>
 40277fc:	1085883a 	add	r2,r2,r2
 4027800:	1085883a 	add	r2,r2,r2
 4027804:	00c100b4 	movhi	r3,1026
 4027808:	18de0604 	addi	r3,r3,30744
 402780c:	10c5883a 	add	r2,r2,r3
 4027810:	11000017 	ldw	r4,0(r2)
 4027814:	2000683a 	jmp	r4
 4027818:	0402793c 	xorhi	r16,zero,2532
 402781c:	040278f8 	rdprs	r16,zero,2531
 4027820:	040278f8 	rdprs	r16,zero,2531
 4027824:	040278f8 	rdprs	r16,zero,2531
 4027828:	040278f8 	rdprs	r16,zero,2531
 402782c:	040278f8 	rdprs	r16,zero,2531
 4027830:	040278f8 	rdprs	r16,zero,2531
 4027834:	040278f8 	rdprs	r16,zero,2531
 4027838:	040278f8 	rdprs	r16,zero,2531
 402783c:	040278f8 	rdprs	r16,zero,2531
 4027840:	040278f8 	rdprs	r16,zero,2531
 4027844:	04027a94 	movui	r16,2538
 4027848:	04027ae8 	cmpgeui	r16,zero,2539
 402784c:	040278f8 	rdprs	r16,zero,2531
 4027850:	040278f8 	rdprs	r16,zero,2531
 4027854:	040278f8 	rdprs	r16,zero,2531
 4027858:	040278f8 	rdprs	r16,zero,2531
 402785c:	04027ae8 	cmpgeui	r16,zero,2539
 4027860:	040278f8 	rdprs	r16,zero,2531
 4027864:	040278f8 	rdprs	r16,zero,2531
 4027868:	040278f8 	rdprs	r16,zero,2531
 402786c:	040278f8 	rdprs	r16,zero,2531
 4027870:	040278f8 	rdprs	r16,zero,2531
 4027874:	04027b34 	movhi	r16,2540
 4027878:	040278f8 	rdprs	r16,zero,2531
 402787c:	040278f8 	rdprs	r16,zero,2531
 4027880:	040278f8 	rdprs	r16,zero,2531
 4027884:	0402789c 	xori	r16,zero,2530
 4027888:	040278f8 	rdprs	r16,zero,2531
 402788c:	04027b48 	cmpgei	r16,zero,2541
 4027890:	040278f8 	rdprs	r16,zero,2531
 4027894:	040278f8 	rdprs	r16,zero,2531
 4027898:	04027b54 	movui	r16,2541
 402789c:	94400017 	ldw	r17,0(r18)
 40278a0:	8809883a 	mov	r4,r17
 40278a4:	40275e40 	call	40275e4 <strlen>
 40278a8:	d9000917 	ldw	r4,36(sp)
 40278ac:	b8a9c83a 	sub	r20,r23,r2
 40278b0:	b00b883a 	mov	r5,r22
 40278b4:	01800804 	movi	r6,32
 40278b8:	a00f883a 	mov	r7,r20
 40278bc:	1021883a 	mov	r16,r2
 40278c0:	40276040 	call	4027604 <print_repeat>
 40278c4:	1000af1e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 40278c8:	b0c00117 	ldw	r3,4(r22)
 40278cc:	d9000917 	ldw	r4,36(sp)
 40278d0:	880d883a 	mov	r6,r17
 40278d4:	b00b883a 	mov	r5,r22
 40278d8:	800f883a 	mov	r7,r16
 40278dc:	183ee83a 	callr	r3
 40278e0:	1000a81e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 40278e4:	d8c00217 	ldw	r3,8(sp)
 40278e8:	94800104 	addi	r18,r18,4
 40278ec:	1c05883a 	add	r2,r3,r16
 40278f0:	a0a9883a 	add	r20,r20,r2
 40278f4:	dd000215 	stw	r20,8(sp)
 40278f8:	0021883a 	mov	r16,zero
 40278fc:	003f7906 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027900:	d8000615 	stw	zero,24(sp)
 4027904:	003f7706 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027908:	04000084 	movi	r16,2
 402790c:	d9c00815 	stw	r7,32(sp)
 4027910:	003f7406 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027914:	00c00044 	movi	r3,1
 4027918:	d8c00715 	stw	r3,28(sp)
 402791c:	003f7106 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027920:	b800a616 	blt	r23,zero,4027bbc <___vfprintf_internal_r+0x538>
 4027924:	b9c002a4 	muli	r7,r23,10
 4027928:	10803fcc 	andi	r2,r2,255
 402792c:	1080201c 	xori	r2,r2,128
 4027930:	10bfe004 	addi	r2,r2,-128
 4027934:	38af883a 	add	r23,r7,r2
 4027938:	003f6a06 	br	40276e4 <___vfprintf_internal_r+0x60>
 402793c:	00800404 	movi	r2,16
 4027940:	00c00044 	movi	r3,1
 4027944:	d8800515 	stw	r2,20(sp)
 4027948:	d8000415 	stw	zero,16(sp)
 402794c:	d8c00315 	stw	r3,12(sp)
 4027950:	102b883a 	mov	r21,r2
 4027954:	d8c00717 	ldw	r3,28(sp)
 4027958:	1805003a 	cmpeq	r2,r3,zero
 402795c:	1000661e 	bne	r2,zero,4027af8 <___vfprintf_internal_r+0x474>
 4027960:	d8800417 	ldw	r2,16(sp)
 4027964:	1000661e 	bne	r2,zero,4027b00 <___vfprintf_internal_r+0x47c>
 4027968:	94400017 	ldw	r17,0(r18)
 402796c:	94800104 	addi	r18,r18,4
 4027970:	dc800115 	stw	r18,4(sp)
 4027974:	8809883a 	mov	r4,r17
 4027978:	a80b883a 	mov	r5,r21
 402797c:	0021883a 	mov	r16,zero
 4027980:	40266940 	call	4026694 <__udivsi3>
 4027984:	10006826 	beq	r2,zero,4027b28 <___vfprintf_internal_r+0x4a4>
 4027988:	07000044 	movi	fp,1
 402798c:	e029883a 	mov	r20,fp
 4027990:	1009883a 	mov	r4,r2
 4027994:	a80b883a 	mov	r5,r21
 4027998:	40266940 	call	4026694 <__udivsi3>
 402799c:	e7000044 	addi	fp,fp,1
 40279a0:	a569383a 	mul	r20,r20,r21
 40279a4:	103ffa1e 	bne	r2,zero,4027990 <___vfprintf_internal_r+0x30c>
 40279a8:	d8800817 	ldw	r2,32(sp)
 40279ac:	bf2fc83a 	sub	r23,r23,fp
 40279b0:	10009126 	beq	r2,zero,4027bf8 <___vfprintf_internal_r+0x574>
 40279b4:	8005003a 	cmpeq	r2,r16,zero
 40279b8:	10000d1e 	bne	r2,zero,40279f0 <___vfprintf_internal_r+0x36c>
 40279bc:	b0c00117 	ldw	r3,4(r22)
 40279c0:	d9000917 	ldw	r4,36(sp)
 40279c4:	00800b44 	movi	r2,45
 40279c8:	d8800005 	stb	r2,0(sp)
 40279cc:	b00b883a 	mov	r5,r22
 40279d0:	d80d883a 	mov	r6,sp
 40279d4:	01c00044 	movi	r7,1
 40279d8:	183ee83a 	callr	r3
 40279dc:	1000691e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 40279e0:	d8c00217 	ldw	r3,8(sp)
 40279e4:	bdffffc4 	addi	r23,r23,-1
 40279e8:	18c00044 	addi	r3,r3,1
 40279ec:	d8c00215 	stw	r3,8(sp)
 40279f0:	d9000917 	ldw	r4,36(sp)
 40279f4:	b00b883a 	mov	r5,r22
 40279f8:	01800c04 	movi	r6,48
 40279fc:	b80f883a 	mov	r7,r23
 4027a00:	40276040 	call	4027604 <print_repeat>
 4027a04:	10005f1e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027a08:	d8800217 	ldw	r2,8(sp)
 4027a0c:	b8a5883a 	add	r18,r23,r2
 4027a10:	a0005726 	beq	r20,zero,4027b70 <___vfprintf_internal_r+0x4ec>
 4027a14:	8809883a 	mov	r4,r17
 4027a18:	a00b883a 	mov	r5,r20
 4027a1c:	40266940 	call	4026694 <__udivsi3>
 4027a20:	11000c04 	addi	r4,r2,48
 4027a24:	20c03fcc 	andi	r3,r4,255
 4027a28:	00800e44 	movi	r2,57
 4027a2c:	10c0052e 	bgeu	r2,r3,4027a44 <___vfprintf_internal_r+0x3c0>
 4027a30:	d8c00317 	ldw	r3,12(sp)
 4027a34:	1805003a 	cmpeq	r2,r3,zero
 4027a38:	10004b1e 	bne	r2,zero,4027b68 <___vfprintf_internal_r+0x4e4>
 4027a3c:	008001c4 	movi	r2,7
 4027a40:	2089883a 	add	r4,r4,r2
 4027a44:	b0c00117 	ldw	r3,4(r22)
 4027a48:	d9000005 	stb	r4,0(sp)
 4027a4c:	d9000917 	ldw	r4,36(sp)
 4027a50:	b00b883a 	mov	r5,r22
 4027a54:	d80d883a 	mov	r6,sp
 4027a58:	01c00044 	movi	r7,1
 4027a5c:	183ee83a 	callr	r3
 4027a60:	1000481e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027a64:	a009883a 	mov	r4,r20
 4027a68:	a80b883a 	mov	r5,r21
 4027a6c:	40266940 	call	4026694 <__udivsi3>
 4027a70:	1021883a 	mov	r16,r2
 4027a74:	94800044 	addi	r18,r18,1
 4027a78:	10003d26 	beq	r2,zero,4027b70 <___vfprintf_internal_r+0x4ec>
 4027a7c:	a00b883a 	mov	r5,r20
 4027a80:	8809883a 	mov	r4,r17
 4027a84:	402669c0 	call	402669c <__umodsi3>
 4027a88:	1023883a 	mov	r17,r2
 4027a8c:	8029883a 	mov	r20,r16
 4027a90:	003fe006 	br	4027a14 <___vfprintf_internal_r+0x390>
 4027a94:	d9000917 	ldw	r4,36(sp)
 4027a98:	b00b883a 	mov	r5,r22
 4027a9c:	01800804 	movi	r6,32
 4027aa0:	b9ffffc4 	addi	r7,r23,-1
 4027aa4:	40276040 	call	4027604 <print_repeat>
 4027aa8:	1000361e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027aac:	90800017 	ldw	r2,0(r18)
 4027ab0:	b0c00117 	ldw	r3,4(r22)
 4027ab4:	d9000917 	ldw	r4,36(sp)
 4027ab8:	d8800005 	stb	r2,0(sp)
 4027abc:	b00b883a 	mov	r5,r22
 4027ac0:	d80d883a 	mov	r6,sp
 4027ac4:	01c00044 	movi	r7,1
 4027ac8:	183ee83a 	callr	r3
 4027acc:	10002d1e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027ad0:	d8800217 	ldw	r2,8(sp)
 4027ad4:	94800104 	addi	r18,r18,4
 4027ad8:	0021883a 	mov	r16,zero
 4027adc:	15c5883a 	add	r2,r2,r23
 4027ae0:	d8800215 	stw	r2,8(sp)
 4027ae4:	003eff06 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027ae8:	d8c00717 	ldw	r3,28(sp)
 4027aec:	dd400517 	ldw	r21,20(sp)
 4027af0:	1805003a 	cmpeq	r2,r3,zero
 4027af4:	103f9a26 	beq	r2,zero,4027960 <___vfprintf_internal_r+0x2dc>
 4027af8:	d8c00417 	ldw	r3,16(sp)
 4027afc:	183f9a26 	beq	r3,zero,4027968 <___vfprintf_internal_r+0x2e4>
 4027b00:	94400017 	ldw	r17,0(r18)
 4027b04:	94800104 	addi	r18,r18,4
 4027b08:	dc800115 	stw	r18,4(sp)
 4027b0c:	883f990e 	bge	r17,zero,4027974 <___vfprintf_internal_r+0x2f0>
 4027b10:	0463c83a 	sub	r17,zero,r17
 4027b14:	8809883a 	mov	r4,r17
 4027b18:	a80b883a 	mov	r5,r21
 4027b1c:	04000044 	movi	r16,1
 4027b20:	40266940 	call	4026694 <__udivsi3>
 4027b24:	103f981e 	bne	r2,zero,4027988 <___vfprintf_internal_r+0x304>
 4027b28:	07000044 	movi	fp,1
 4027b2c:	e029883a 	mov	r20,fp
 4027b30:	003f9d06 	br	40279a8 <___vfprintf_internal_r+0x324>
 4027b34:	00800204 	movi	r2,8
 4027b38:	102b883a 	mov	r21,r2
 4027b3c:	d8800515 	stw	r2,20(sp)
 4027b40:	d8000415 	stw	zero,16(sp)
 4027b44:	003f8306 	br	4027954 <___vfprintf_internal_r+0x2d0>
 4027b48:	dd400517 	ldw	r21,20(sp)
 4027b4c:	d8000415 	stw	zero,16(sp)
 4027b50:	003f8006 	br	4027954 <___vfprintf_internal_r+0x2d0>
 4027b54:	00c00404 	movi	r3,16
 4027b58:	182b883a 	mov	r21,r3
 4027b5c:	d8c00515 	stw	r3,20(sp)
 4027b60:	d8000415 	stw	zero,16(sp)
 4027b64:	003f7b06 	br	4027954 <___vfprintf_internal_r+0x2d0>
 4027b68:	008009c4 	movi	r2,39
 4027b6c:	003fb406 	br	4027a40 <___vfprintf_internal_r+0x3bc>
 4027b70:	9725883a 	add	r18,r18,fp
 4027b74:	dc800215 	stw	r18,8(sp)
 4027b78:	dc800117 	ldw	r18,4(sp)
 4027b7c:	0021883a 	mov	r16,zero
 4027b80:	003ed806 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027b84:	00bfffc4 	movi	r2,-1
 4027b88:	d8800215 	stw	r2,8(sp)
 4027b8c:	003ef206 	br	4027758 <___vfprintf_internal_r+0xd4>
 4027b90:	b0c00117 	ldw	r3,4(r22)
 4027b94:	d9000917 	ldw	r4,36(sp)
 4027b98:	d9400005 	stb	r5,0(sp)
 4027b9c:	d80d883a 	mov	r6,sp
 4027ba0:	b00b883a 	mov	r5,r22
 4027ba4:	183ee83a 	callr	r3
 4027ba8:	103ff61e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027bac:	d8c00217 	ldw	r3,8(sp)
 4027bb0:	18c00044 	addi	r3,r3,1
 4027bb4:	d8c00215 	stw	r3,8(sp)
 4027bb8:	003eca06 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027bbc:	000f883a 	mov	r7,zero
 4027bc0:	003f5906 	br	4027928 <___vfprintf_internal_r+0x2a4>
 4027bc4:	b0c00117 	ldw	r3,4(r22)
 4027bc8:	d9000005 	stb	r4,0(sp)
 4027bcc:	d9000917 	ldw	r4,36(sp)
 4027bd0:	b00b883a 	mov	r5,r22
 4027bd4:	d80d883a 	mov	r6,sp
 4027bd8:	800f883a 	mov	r7,r16
 4027bdc:	183ee83a 	callr	r3
 4027be0:	103fe81e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027be4:	d8800217 	ldw	r2,8(sp)
 4027be8:	1405883a 	add	r2,r2,r16
 4027bec:	0021883a 	mov	r16,zero
 4027bf0:	d8800215 	stw	r2,8(sp)
 4027bf4:	003ebb06 	br	40276e4 <___vfprintf_internal_r+0x60>
 4027bf8:	8021003a 	cmpeq	r16,r16,zero
 4027bfc:	80001426 	beq	r16,zero,4027c50 <___vfprintf_internal_r+0x5cc>
 4027c00:	d9000917 	ldw	r4,36(sp)
 4027c04:	b00b883a 	mov	r5,r22
 4027c08:	01800804 	movi	r6,32
 4027c0c:	b80f883a 	mov	r7,r23
 4027c10:	40276040 	call	4027604 <print_repeat>
 4027c14:	103fdb1e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027c18:	d8c00217 	ldw	r3,8(sp)
 4027c1c:	b8e5883a 	add	r18,r23,r3
 4027c20:	803f7b1e 	bne	r16,zero,4027a10 <___vfprintf_internal_r+0x38c>
 4027c24:	b0c00117 	ldw	r3,4(r22)
 4027c28:	d9000917 	ldw	r4,36(sp)
 4027c2c:	00800b44 	movi	r2,45
 4027c30:	d8800005 	stb	r2,0(sp)
 4027c34:	b00b883a 	mov	r5,r22
 4027c38:	d80d883a 	mov	r6,sp
 4027c3c:	01c00044 	movi	r7,1
 4027c40:	183ee83a 	callr	r3
 4027c44:	103fcf1e 	bne	r2,zero,4027b84 <___vfprintf_internal_r+0x500>
 4027c48:	94800044 	addi	r18,r18,1
 4027c4c:	003f7006 	br	4027a10 <___vfprintf_internal_r+0x38c>
 4027c50:	bdffffc4 	addi	r23,r23,-1
 4027c54:	003fea06 	br	4027c00 <___vfprintf_internal_r+0x57c>

04027c58 <__vfprintf_internal>:
 4027c58:	008100f4 	movhi	r2,1027
 4027c5c:	10bd6704 	addi	r2,r2,-2660
 4027c60:	2013883a 	mov	r9,r4
 4027c64:	11000017 	ldw	r4,0(r2)
 4027c68:	2805883a 	mov	r2,r5
 4027c6c:	300f883a 	mov	r7,r6
 4027c70:	480b883a 	mov	r5,r9
 4027c74:	100d883a 	mov	r6,r2
 4027c78:	40276841 	jmpi	4027684 <___vfprintf_internal_r>

04027c7c <_malloc_trim_r>:
 4027c7c:	defffb04 	addi	sp,sp,-20
 4027c80:	dcc00315 	stw	r19,12(sp)
 4027c84:	04c100f4 	movhi	r19,1027
 4027c88:	9cf76704 	addi	r19,r19,-8804
 4027c8c:	dc800215 	stw	r18,8(sp)
 4027c90:	dc400115 	stw	r17,4(sp)
 4027c94:	dc000015 	stw	r16,0(sp)
 4027c98:	2823883a 	mov	r17,r5
 4027c9c:	2025883a 	mov	r18,r4
 4027ca0:	dfc00415 	stw	ra,16(sp)
 4027ca4:	40284ec0 	call	40284ec <__malloc_lock>
 4027ca8:	98800217 	ldw	r2,8(r19)
 4027cac:	9009883a 	mov	r4,r18
 4027cb0:	000b883a 	mov	r5,zero
 4027cb4:	10c00117 	ldw	r3,4(r2)
 4027cb8:	00bfff04 	movi	r2,-4
 4027cbc:	18a0703a 	and	r16,r3,r2
 4027cc0:	8463c83a 	sub	r17,r16,r17
 4027cc4:	8c401bc4 	addi	r17,r17,111
 4027cc8:	8822d1fa 	srli	r17,r17,7
 4027ccc:	00801fc4 	movi	r2,127
 4027cd0:	8c7fffc4 	addi	r17,r17,-1
 4027cd4:	882291fa 	slli	r17,r17,7
 4027cd8:	1440060e 	bge	r2,r17,4027cf4 <_malloc_trim_r+0x78>
 4027cdc:	40275740 	call	4027574 <_sbrk_r>
 4027ce0:	98c00217 	ldw	r3,8(r19)
 4027ce4:	9009883a 	mov	r4,r18
 4027ce8:	044bc83a 	sub	r5,zero,r17
 4027cec:	80c7883a 	add	r3,r16,r3
 4027cf0:	10c00926 	beq	r2,r3,4027d18 <_malloc_trim_r+0x9c>
 4027cf4:	402850c0 	call	402850c <__malloc_unlock>
 4027cf8:	0005883a 	mov	r2,zero
 4027cfc:	dfc00417 	ldw	ra,16(sp)
 4027d00:	dcc00317 	ldw	r19,12(sp)
 4027d04:	dc800217 	ldw	r18,8(sp)
 4027d08:	dc400117 	ldw	r17,4(sp)
 4027d0c:	dc000017 	ldw	r16,0(sp)
 4027d10:	dec00504 	addi	sp,sp,20
 4027d14:	f800283a 	ret
 4027d18:	9009883a 	mov	r4,r18
 4027d1c:	40275740 	call	4027574 <_sbrk_r>
 4027d20:	844dc83a 	sub	r6,r16,r17
 4027d24:	00ffffc4 	movi	r3,-1
 4027d28:	9009883a 	mov	r4,r18
 4027d2c:	000b883a 	mov	r5,zero
 4027d30:	01c100f4 	movhi	r7,1027
 4027d34:	39c42f04 	addi	r7,r7,4284
 4027d38:	31800054 	ori	r6,r6,1
 4027d3c:	10c00926 	beq	r2,r3,4027d64 <_malloc_trim_r+0xe8>
 4027d40:	38800017 	ldw	r2,0(r7)
 4027d44:	98c00217 	ldw	r3,8(r19)
 4027d48:	9009883a 	mov	r4,r18
 4027d4c:	1445c83a 	sub	r2,r2,r17
 4027d50:	38800015 	stw	r2,0(r7)
 4027d54:	19800115 	stw	r6,4(r3)
 4027d58:	402850c0 	call	402850c <__malloc_unlock>
 4027d5c:	00800044 	movi	r2,1
 4027d60:	003fe606 	br	4027cfc <_malloc_trim_r+0x80>
 4027d64:	40275740 	call	4027574 <_sbrk_r>
 4027d68:	99800217 	ldw	r6,8(r19)
 4027d6c:	100f883a 	mov	r7,r2
 4027d70:	9009883a 	mov	r4,r18
 4027d74:	1187c83a 	sub	r3,r2,r6
 4027d78:	008003c4 	movi	r2,15
 4027d7c:	19400054 	ori	r5,r3,1
 4027d80:	10ffdc0e 	bge	r2,r3,4027cf4 <_malloc_trim_r+0x78>
 4027d84:	008100f4 	movhi	r2,1027
 4027d88:	10bd6604 	addi	r2,r2,-2664
 4027d8c:	10c00017 	ldw	r3,0(r2)
 4027d90:	008100f4 	movhi	r2,1027
 4027d94:	10842f04 	addi	r2,r2,4284
 4027d98:	31400115 	stw	r5,4(r6)
 4027d9c:	38c7c83a 	sub	r3,r7,r3
 4027da0:	10c00015 	stw	r3,0(r2)
 4027da4:	003fd306 	br	4027cf4 <_malloc_trim_r+0x78>

04027da8 <_free_r>:
 4027da8:	defffd04 	addi	sp,sp,-12
 4027dac:	dc400115 	stw	r17,4(sp)
 4027db0:	dc000015 	stw	r16,0(sp)
 4027db4:	dfc00215 	stw	ra,8(sp)
 4027db8:	2821883a 	mov	r16,r5
 4027dbc:	2023883a 	mov	r17,r4
 4027dc0:	28005a26 	beq	r5,zero,4027f2c <_free_r+0x184>
 4027dc4:	40284ec0 	call	40284ec <__malloc_lock>
 4027dc8:	823ffe04 	addi	r8,r16,-8
 4027dcc:	41400117 	ldw	r5,4(r8)
 4027dd0:	00bfff84 	movi	r2,-2
 4027dd4:	028100f4 	movhi	r10,1027
 4027dd8:	52b76704 	addi	r10,r10,-8804
 4027ddc:	288e703a 	and	r7,r5,r2
 4027de0:	41cd883a 	add	r6,r8,r7
 4027de4:	30c00117 	ldw	r3,4(r6)
 4027de8:	51000217 	ldw	r4,8(r10)
 4027dec:	00bfff04 	movi	r2,-4
 4027df0:	1892703a 	and	r9,r3,r2
 4027df4:	5017883a 	mov	r11,r10
 4027df8:	31006726 	beq	r6,r4,4027f98 <_free_r+0x1f0>
 4027dfc:	2880004c 	andi	r2,r5,1
 4027e00:	1005003a 	cmpeq	r2,r2,zero
 4027e04:	32400115 	stw	r9,4(r6)
 4027e08:	10001a1e 	bne	r2,zero,4027e74 <_free_r+0xcc>
 4027e0c:	000b883a 	mov	r5,zero
 4027e10:	3247883a 	add	r3,r6,r9
 4027e14:	18800117 	ldw	r2,4(r3)
 4027e18:	1080004c 	andi	r2,r2,1
 4027e1c:	1000231e 	bne	r2,zero,4027eac <_free_r+0x104>
 4027e20:	280ac03a 	cmpne	r5,r5,zero
 4027e24:	3a4f883a 	add	r7,r7,r9
 4027e28:	2800451e 	bne	r5,zero,4027f40 <_free_r+0x198>
 4027e2c:	31000217 	ldw	r4,8(r6)
 4027e30:	008100f4 	movhi	r2,1027
 4027e34:	10b76904 	addi	r2,r2,-8796
 4027e38:	20807b26 	beq	r4,r2,4028028 <_free_r+0x280>
 4027e3c:	30800317 	ldw	r2,12(r6)
 4027e40:	3a07883a 	add	r3,r7,r8
 4027e44:	19c00015 	stw	r7,0(r3)
 4027e48:	11000215 	stw	r4,8(r2)
 4027e4c:	20800315 	stw	r2,12(r4)
 4027e50:	38800054 	ori	r2,r7,1
 4027e54:	40800115 	stw	r2,4(r8)
 4027e58:	28001a26 	beq	r5,zero,4027ec4 <_free_r+0x11c>
 4027e5c:	8809883a 	mov	r4,r17
 4027e60:	dfc00217 	ldw	ra,8(sp)
 4027e64:	dc400117 	ldw	r17,4(sp)
 4027e68:	dc000017 	ldw	r16,0(sp)
 4027e6c:	dec00304 	addi	sp,sp,12
 4027e70:	402850c1 	jmpi	402850c <__malloc_unlock>
 4027e74:	80bffe17 	ldw	r2,-8(r16)
 4027e78:	50c00204 	addi	r3,r10,8
 4027e7c:	4091c83a 	sub	r8,r8,r2
 4027e80:	41000217 	ldw	r4,8(r8)
 4027e84:	388f883a 	add	r7,r7,r2
 4027e88:	20c06126 	beq	r4,r3,4028010 <_free_r+0x268>
 4027e8c:	40800317 	ldw	r2,12(r8)
 4027e90:	3247883a 	add	r3,r6,r9
 4027e94:	000b883a 	mov	r5,zero
 4027e98:	11000215 	stw	r4,8(r2)
 4027e9c:	20800315 	stw	r2,12(r4)
 4027ea0:	18800117 	ldw	r2,4(r3)
 4027ea4:	1080004c 	andi	r2,r2,1
 4027ea8:	103fdd26 	beq	r2,zero,4027e20 <_free_r+0x78>
 4027eac:	38800054 	ori	r2,r7,1
 4027eb0:	3a07883a 	add	r3,r7,r8
 4027eb4:	280ac03a 	cmpne	r5,r5,zero
 4027eb8:	40800115 	stw	r2,4(r8)
 4027ebc:	19c00015 	stw	r7,0(r3)
 4027ec0:	283fe61e 	bne	r5,zero,4027e5c <_free_r+0xb4>
 4027ec4:	00807fc4 	movi	r2,511
 4027ec8:	11c01f2e 	bgeu	r2,r7,4027f48 <_free_r+0x1a0>
 4027ecc:	3806d27a 	srli	r3,r7,9
 4027ed0:	1800481e 	bne	r3,zero,4027ff4 <_free_r+0x24c>
 4027ed4:	3804d0fa 	srli	r2,r7,3
 4027ed8:	100690fa 	slli	r3,r2,3
 4027edc:	1acd883a 	add	r6,r3,r11
 4027ee0:	31400217 	ldw	r5,8(r6)
 4027ee4:	31405926 	beq	r6,r5,402804c <_free_r+0x2a4>
 4027ee8:	28800117 	ldw	r2,4(r5)
 4027eec:	00ffff04 	movi	r3,-4
 4027ef0:	10c4703a 	and	r2,r2,r3
 4027ef4:	3880022e 	bgeu	r7,r2,4027f00 <_free_r+0x158>
 4027ef8:	29400217 	ldw	r5,8(r5)
 4027efc:	317ffa1e 	bne	r6,r5,4027ee8 <_free_r+0x140>
 4027f00:	29800317 	ldw	r6,12(r5)
 4027f04:	41800315 	stw	r6,12(r8)
 4027f08:	41400215 	stw	r5,8(r8)
 4027f0c:	8809883a 	mov	r4,r17
 4027f10:	2a000315 	stw	r8,12(r5)
 4027f14:	32000215 	stw	r8,8(r6)
 4027f18:	dfc00217 	ldw	ra,8(sp)
 4027f1c:	dc400117 	ldw	r17,4(sp)
 4027f20:	dc000017 	ldw	r16,0(sp)
 4027f24:	dec00304 	addi	sp,sp,12
 4027f28:	402850c1 	jmpi	402850c <__malloc_unlock>
 4027f2c:	dfc00217 	ldw	ra,8(sp)
 4027f30:	dc400117 	ldw	r17,4(sp)
 4027f34:	dc000017 	ldw	r16,0(sp)
 4027f38:	dec00304 	addi	sp,sp,12
 4027f3c:	f800283a 	ret
 4027f40:	31000217 	ldw	r4,8(r6)
 4027f44:	003fbd06 	br	4027e3c <_free_r+0x94>
 4027f48:	3806d0fa 	srli	r3,r7,3
 4027f4c:	00800044 	movi	r2,1
 4027f50:	51400117 	ldw	r5,4(r10)
 4027f54:	180890fa 	slli	r4,r3,3
 4027f58:	1807d0ba 	srai	r3,r3,2
 4027f5c:	22c9883a 	add	r4,r4,r11
 4027f60:	21800217 	ldw	r6,8(r4)
 4027f64:	10c4983a 	sll	r2,r2,r3
 4027f68:	41000315 	stw	r4,12(r8)
 4027f6c:	41800215 	stw	r6,8(r8)
 4027f70:	288ab03a 	or	r5,r5,r2
 4027f74:	22000215 	stw	r8,8(r4)
 4027f78:	8809883a 	mov	r4,r17
 4027f7c:	51400115 	stw	r5,4(r10)
 4027f80:	32000315 	stw	r8,12(r6)
 4027f84:	dfc00217 	ldw	ra,8(sp)
 4027f88:	dc400117 	ldw	r17,4(sp)
 4027f8c:	dc000017 	ldw	r16,0(sp)
 4027f90:	dec00304 	addi	sp,sp,12
 4027f94:	402850c1 	jmpi	402850c <__malloc_unlock>
 4027f98:	2880004c 	andi	r2,r5,1
 4027f9c:	3a4d883a 	add	r6,r7,r9
 4027fa0:	1000071e 	bne	r2,zero,4027fc0 <_free_r+0x218>
 4027fa4:	80bffe17 	ldw	r2,-8(r16)
 4027fa8:	4091c83a 	sub	r8,r8,r2
 4027fac:	41000317 	ldw	r4,12(r8)
 4027fb0:	40c00217 	ldw	r3,8(r8)
 4027fb4:	308d883a 	add	r6,r6,r2
 4027fb8:	20c00215 	stw	r3,8(r4)
 4027fbc:	19000315 	stw	r4,12(r3)
 4027fc0:	008100f4 	movhi	r2,1027
 4027fc4:	10bd6504 	addi	r2,r2,-2668
 4027fc8:	11000017 	ldw	r4,0(r2)
 4027fcc:	30c00054 	ori	r3,r6,1
 4027fd0:	52000215 	stw	r8,8(r10)
 4027fd4:	40c00115 	stw	r3,4(r8)
 4027fd8:	313fa036 	bltu	r6,r4,4027e5c <_free_r+0xb4>
 4027fdc:	008100f4 	movhi	r2,1027
 4027fe0:	10841f04 	addi	r2,r2,4220
 4027fe4:	11400017 	ldw	r5,0(r2)
 4027fe8:	8809883a 	mov	r4,r17
 4027fec:	4027c7c0 	call	4027c7c <_malloc_trim_r>
 4027ff0:	003f9a06 	br	4027e5c <_free_r+0xb4>
 4027ff4:	00800104 	movi	r2,4
 4027ff8:	10c0072e 	bgeu	r2,r3,4028018 <_free_r+0x270>
 4027ffc:	00800504 	movi	r2,20
 4028000:	10c01936 	bltu	r2,r3,4028068 <_free_r+0x2c0>
 4028004:	188016c4 	addi	r2,r3,91
 4028008:	100690fa 	slli	r3,r2,3
 402800c:	003fb306 	br	4027edc <_free_r+0x134>
 4028010:	01400044 	movi	r5,1
 4028014:	003f7e06 	br	4027e10 <_free_r+0x68>
 4028018:	3804d1ba 	srli	r2,r7,6
 402801c:	10800e04 	addi	r2,r2,56
 4028020:	100690fa 	slli	r3,r2,3
 4028024:	003fad06 	br	4027edc <_free_r+0x134>
 4028028:	22000315 	stw	r8,12(r4)
 402802c:	22000215 	stw	r8,8(r4)
 4028030:	3a05883a 	add	r2,r7,r8
 4028034:	38c00054 	ori	r3,r7,1
 4028038:	11c00015 	stw	r7,0(r2)
 402803c:	41000215 	stw	r4,8(r8)
 4028040:	40c00115 	stw	r3,4(r8)
 4028044:	41000315 	stw	r4,12(r8)
 4028048:	003f8406 	br	4027e5c <_free_r+0xb4>
 402804c:	1005d0ba 	srai	r2,r2,2
 4028050:	00c00044 	movi	r3,1
 4028054:	51000117 	ldw	r4,4(r10)
 4028058:	1886983a 	sll	r3,r3,r2
 402805c:	20c8b03a 	or	r4,r4,r3
 4028060:	51000115 	stw	r4,4(r10)
 4028064:	003fa706 	br	4027f04 <_free_r+0x15c>
 4028068:	00801504 	movi	r2,84
 402806c:	10c00436 	bltu	r2,r3,4028080 <_free_r+0x2d8>
 4028070:	3804d33a 	srli	r2,r7,12
 4028074:	10801b84 	addi	r2,r2,110
 4028078:	100690fa 	slli	r3,r2,3
 402807c:	003f9706 	br	4027edc <_free_r+0x134>
 4028080:	00805504 	movi	r2,340
 4028084:	10c00436 	bltu	r2,r3,4028098 <_free_r+0x2f0>
 4028088:	3804d3fa 	srli	r2,r7,15
 402808c:	10801dc4 	addi	r2,r2,119
 4028090:	100690fa 	slli	r3,r2,3
 4028094:	003f9106 	br	4027edc <_free_r+0x134>
 4028098:	00815504 	movi	r2,1364
 402809c:	10c0032e 	bgeu	r2,r3,40280ac <_free_r+0x304>
 40280a0:	00801f84 	movi	r2,126
 40280a4:	00c0fc04 	movi	r3,1008
 40280a8:	003f8c06 	br	4027edc <_free_r+0x134>
 40280ac:	3804d4ba 	srli	r2,r7,18
 40280b0:	10801f04 	addi	r2,r2,124
 40280b4:	100690fa 	slli	r3,r2,3
 40280b8:	003f8806 	br	4027edc <_free_r+0x134>

040280bc <__sfvwrite_small_dev>:
 40280bc:	2880000b 	ldhu	r2,0(r5)
 40280c0:	defffa04 	addi	sp,sp,-24
 40280c4:	dcc00315 	stw	r19,12(sp)
 40280c8:	1080020c 	andi	r2,r2,8
 40280cc:	dc800215 	stw	r18,8(sp)
 40280d0:	dc400115 	stw	r17,4(sp)
 40280d4:	dfc00515 	stw	ra,20(sp)
 40280d8:	dd000415 	stw	r20,16(sp)
 40280dc:	dc000015 	stw	r16,0(sp)
 40280e0:	2825883a 	mov	r18,r5
 40280e4:	2027883a 	mov	r19,r4
 40280e8:	3023883a 	mov	r17,r6
 40280ec:	10002026 	beq	r2,zero,4028170 <__sfvwrite_small_dev+0xb4>
 40280f0:	2940008f 	ldh	r5,2(r5)
 40280f4:	28000f16 	blt	r5,zero,4028134 <__sfvwrite_small_dev+0x78>
 40280f8:	01c01b0e 	bge	zero,r7,4028168 <__sfvwrite_small_dev+0xac>
 40280fc:	3821883a 	mov	r16,r7
 4028100:	05010004 	movi	r20,1024
 4028104:	00000206 	br	4028110 <__sfvwrite_small_dev+0x54>
 4028108:	0400170e 	bge	zero,r16,4028168 <__sfvwrite_small_dev+0xac>
 402810c:	9140008f 	ldh	r5,2(r18)
 4028110:	880d883a 	mov	r6,r17
 4028114:	9809883a 	mov	r4,r19
 4028118:	800f883a 	mov	r7,r16
 402811c:	a400010e 	bge	r20,r16,4028124 <__sfvwrite_small_dev+0x68>
 4028120:	01c10004 	movi	r7,1024
 4028124:	402825c0 	call	402825c <_write_r>
 4028128:	88a3883a 	add	r17,r17,r2
 402812c:	80a1c83a 	sub	r16,r16,r2
 4028130:	00bff516 	blt	zero,r2,4028108 <__sfvwrite_small_dev+0x4c>
 4028134:	9080000b 	ldhu	r2,0(r18)
 4028138:	00ffffc4 	movi	r3,-1
 402813c:	10801014 	ori	r2,r2,64
 4028140:	9080000d 	sth	r2,0(r18)
 4028144:	1805883a 	mov	r2,r3
 4028148:	dfc00517 	ldw	ra,20(sp)
 402814c:	dd000417 	ldw	r20,16(sp)
 4028150:	dcc00317 	ldw	r19,12(sp)
 4028154:	dc800217 	ldw	r18,8(sp)
 4028158:	dc400117 	ldw	r17,4(sp)
 402815c:	dc000017 	ldw	r16,0(sp)
 4028160:	dec00604 	addi	sp,sp,24
 4028164:	f800283a 	ret
 4028168:	0007883a 	mov	r3,zero
 402816c:	003ff506 	br	4028144 <__sfvwrite_small_dev+0x88>
 4028170:	00ffffc4 	movi	r3,-1
 4028174:	003ff306 	br	4028144 <__sfvwrite_small_dev+0x88>

04028178 <putc>:
 4028178:	defffd04 	addi	sp,sp,-12
 402817c:	008100f4 	movhi	r2,1027
 4028180:	10bd6704 	addi	r2,r2,-2660
 4028184:	dc000115 	stw	r16,4(sp)
 4028188:	2021883a 	mov	r16,r4
 402818c:	11000017 	ldw	r4,0(r2)
 4028190:	dc000005 	stb	r16,0(sp)
 4028194:	008100f4 	movhi	r2,1027
 4028198:	10a02f04 	addi	r2,r2,-32580
 402819c:	dfc00215 	stw	ra,8(sp)
 40281a0:	28800115 	stw	r2,4(r5)
 40281a4:	d80d883a 	mov	r6,sp
 40281a8:	01c00044 	movi	r7,1
 40281ac:	103ee83a 	callr	r2
 40281b0:	1007883a 	mov	r3,r2
 40281b4:	00bfffc4 	movi	r2,-1
 40281b8:	18800526 	beq	r3,r2,40281d0 <putc+0x58>
 40281bc:	8005883a 	mov	r2,r16
 40281c0:	dfc00217 	ldw	ra,8(sp)
 40281c4:	dc000117 	ldw	r16,4(sp)
 40281c8:	dec00304 	addi	sp,sp,12
 40281cc:	f800283a 	ret
 40281d0:	1821883a 	mov	r16,r3
 40281d4:	8005883a 	mov	r2,r16
 40281d8:	dfc00217 	ldw	ra,8(sp)
 40281dc:	dc000117 	ldw	r16,4(sp)
 40281e0:	dec00304 	addi	sp,sp,12
 40281e4:	f800283a 	ret

040281e8 <_putc_r>:
 40281e8:	008100f4 	movhi	r2,1027
 40281ec:	10bd6704 	addi	r2,r2,-2660
 40281f0:	defffd04 	addi	sp,sp,-12
 40281f4:	11000017 	ldw	r4,0(r2)
 40281f8:	008100f4 	movhi	r2,1027
 40281fc:	10a02f04 	addi	r2,r2,-32580
 4028200:	30800115 	stw	r2,4(r6)
 4028204:	dc000115 	stw	r16,4(sp)
 4028208:	2821883a 	mov	r16,r5
 402820c:	dfc00215 	stw	ra,8(sp)
 4028210:	300b883a 	mov	r5,r6
 4028214:	01c00044 	movi	r7,1
 4028218:	d80d883a 	mov	r6,sp
 402821c:	dc000005 	stb	r16,0(sp)
 4028220:	103ee83a 	callr	r2
 4028224:	1007883a 	mov	r3,r2
 4028228:	00bfffc4 	movi	r2,-1
 402822c:	18800526 	beq	r3,r2,4028244 <_putc_r+0x5c>
 4028230:	8005883a 	mov	r2,r16
 4028234:	dfc00217 	ldw	ra,8(sp)
 4028238:	dc000117 	ldw	r16,4(sp)
 402823c:	dec00304 	addi	sp,sp,12
 4028240:	f800283a 	ret
 4028244:	1821883a 	mov	r16,r3
 4028248:	8005883a 	mov	r2,r16
 402824c:	dfc00217 	ldw	ra,8(sp)
 4028250:	dc000117 	ldw	r16,4(sp)
 4028254:	dec00304 	addi	sp,sp,12
 4028258:	f800283a 	ret

0402825c <_write_r>:
 402825c:	defffd04 	addi	sp,sp,-12
 4028260:	dc000015 	stw	r16,0(sp)
 4028264:	040100f4 	movhi	r16,1027
 4028268:	84042204 	addi	r16,r16,4232
 402826c:	dc400115 	stw	r17,4(sp)
 4028270:	80000015 	stw	zero,0(r16)
 4028274:	2023883a 	mov	r17,r4
 4028278:	2809883a 	mov	r4,r5
 402827c:	300b883a 	mov	r5,r6
 4028280:	380d883a 	mov	r6,r7
 4028284:	dfc00215 	stw	ra,8(sp)
 4028288:	40286180 	call	4028618 <write>
 402828c:	1007883a 	mov	r3,r2
 4028290:	00bfffc4 	movi	r2,-1
 4028294:	18800626 	beq	r3,r2,40282b0 <_write_r+0x54>
 4028298:	1805883a 	mov	r2,r3
 402829c:	dfc00217 	ldw	ra,8(sp)
 40282a0:	dc400117 	ldw	r17,4(sp)
 40282a4:	dc000017 	ldw	r16,0(sp)
 40282a8:	dec00304 	addi	sp,sp,12
 40282ac:	f800283a 	ret
 40282b0:	80800017 	ldw	r2,0(r16)
 40282b4:	103ff826 	beq	r2,zero,4028298 <_write_r+0x3c>
 40282b8:	88800015 	stw	r2,0(r17)
 40282bc:	1805883a 	mov	r2,r3
 40282c0:	dfc00217 	ldw	ra,8(sp)
 40282c4:	dc400117 	ldw	r17,4(sp)
 40282c8:	dc000017 	ldw	r16,0(sp)
 40282cc:	dec00304 	addi	sp,sp,12
 40282d0:	f800283a 	ret

040282d4 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 40282d4:	defffb04 	addi	sp,sp,-20
 40282d8:	dfc00415 	stw	ra,16(sp)
 40282dc:	df000315 	stw	fp,12(sp)
 40282e0:	df000304 	addi	fp,sp,12
 40282e4:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 40282e8:	e13ffe17 	ldw	r4,-8(fp)
 40282ec:	d1601004 	addi	r5,gp,-32704
 40282f0:	402bae80 	call	402bae8 <alt_find_dev>
 40282f4:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 40282f8:	e0bffd17 	ldw	r2,-12(fp)
 40282fc:	1005003a 	cmpeq	r2,r2,zero
 4028300:	10000b1e 	bne	r2,zero,4028330 <alt_flash_open_dev+0x5c>
 4028304:	e0bffd17 	ldw	r2,-12(fp)
 4028308:	10800317 	ldw	r2,12(r2)
 402830c:	1005003a 	cmpeq	r2,r2,zero
 4028310:	1000071e 	bne	r2,zero,4028330 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 4028314:	e0bffd17 	ldw	r2,-12(fp)
 4028318:	10800317 	ldw	r2,12(r2)
 402831c:	e13ffd17 	ldw	r4,-12(fp)
 4028320:	e17ffe17 	ldw	r5,-8(fp)
 4028324:	103ee83a 	callr	r2
 4028328:	e0bfff15 	stw	r2,-4(fp)
 402832c:	00000206 	br	4028338 <alt_flash_open_dev+0x64>
  }

  return dev;
 4028330:	e0bffd17 	ldw	r2,-12(fp)
 4028334:	e0bfff15 	stw	r2,-4(fp)
 4028338:	e0bfff17 	ldw	r2,-4(fp)
}
 402833c:	e037883a 	mov	sp,fp
 4028340:	dfc00117 	ldw	ra,4(sp)
 4028344:	df000017 	ldw	fp,0(sp)
 4028348:	dec00204 	addi	sp,sp,8
 402834c:	f800283a 	ret

04028350 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 4028350:	defffd04 	addi	sp,sp,-12
 4028354:	dfc00215 	stw	ra,8(sp)
 4028358:	df000115 	stw	fp,4(sp)
 402835c:	df000104 	addi	fp,sp,4
 4028360:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 4028364:	e0bfff17 	ldw	r2,-4(fp)
 4028368:	1005003a 	cmpeq	r2,r2,zero
 402836c:	1000081e 	bne	r2,zero,4028390 <alt_flash_close_dev+0x40>
 4028370:	e0bfff17 	ldw	r2,-4(fp)
 4028374:	10800417 	ldw	r2,16(r2)
 4028378:	1005003a 	cmpeq	r2,r2,zero
 402837c:	1000041e 	bne	r2,zero,4028390 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 4028380:	e0bfff17 	ldw	r2,-4(fp)
 4028384:	10800417 	ldw	r2,16(r2)
 4028388:	e13fff17 	ldw	r4,-4(fp)
 402838c:	103ee83a 	callr	r2
  }
  return;
}
 4028390:	e037883a 	mov	sp,fp
 4028394:	dfc00117 	ldw	ra,4(sp)
 4028398:	df000017 	ldw	fp,0(sp)
 402839c:	dec00204 	addi	sp,sp,8
 40283a0:	f800283a 	ret

040283a4 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 40283a4:	defffe04 	addi	sp,sp,-8
 40283a8:	dfc00115 	stw	ra,4(sp)
 40283ac:	df000015 	stw	fp,0(sp)
 40283b0:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 40283b4:	010100f4 	movhi	r4,1027
 40283b8:	213d7504 	addi	r4,r4,-2604
 40283bc:	014100f4 	movhi	r5,1027
 40283c0:	2976ff04 	addi	r5,r5,-9220
 40283c4:	018100f4 	movhi	r6,1027
 40283c8:	31bd7504 	addi	r6,r6,-2604
 40283cc:	40284240 	call	4028424 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 40283d0:	010100b4 	movhi	r4,1026
 40283d4:	21000804 	addi	r4,r4,32
 40283d8:	014100b4 	movhi	r5,1026
 40283dc:	29400804 	addi	r5,r5,32
 40283e0:	018100b4 	movhi	r6,1026
 40283e4:	31806d04 	addi	r6,r6,436
 40283e8:	40284240 	call	4028424 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 40283ec:	010100f4 	movhi	r4,1027
 40283f0:	21349104 	addi	r4,r4,-11708
 40283f4:	014100f4 	movhi	r5,1027
 40283f8:	29749104 	addi	r5,r5,-11708
 40283fc:	018100f4 	movhi	r6,1027
 4028400:	31b6ff04 	addi	r6,r6,-9220
 4028404:	40284240 	call	4028424 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 4028408:	402b9640 	call	402b964 <alt_dcache_flush_all>
  alt_icache_flush_all();
 402840c:	402bb7c0 	call	402bb7c <alt_icache_flush_all>
}
 4028410:	e037883a 	mov	sp,fp
 4028414:	dfc00117 	ldw	ra,4(sp)
 4028418:	df000017 	ldw	fp,0(sp)
 402841c:	dec00204 	addi	sp,sp,8
 4028420:	f800283a 	ret

04028424 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 4028424:	defffc04 	addi	sp,sp,-16
 4028428:	df000315 	stw	fp,12(sp)
 402842c:	df000304 	addi	fp,sp,12
 4028430:	e13ffd15 	stw	r4,-12(fp)
 4028434:	e17ffe15 	stw	r5,-8(fp)
 4028438:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 402843c:	e0fffe17 	ldw	r3,-8(fp)
 4028440:	e0bffd17 	ldw	r2,-12(fp)
 4028444:	18800e26 	beq	r3,r2,4028480 <alt_load_section+0x5c>
  {
    while( to != end )
 4028448:	00000a06 	br	4028474 <alt_load_section+0x50>
    {
      *to++ = *from++;
 402844c:	e0bffd17 	ldw	r2,-12(fp)
 4028450:	10c00017 	ldw	r3,0(r2)
 4028454:	e0bffe17 	ldw	r2,-8(fp)
 4028458:	10c00015 	stw	r3,0(r2)
 402845c:	e0bffe17 	ldw	r2,-8(fp)
 4028460:	10800104 	addi	r2,r2,4
 4028464:	e0bffe15 	stw	r2,-8(fp)
 4028468:	e0bffd17 	ldw	r2,-12(fp)
 402846c:	10800104 	addi	r2,r2,4
 4028470:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 4028474:	e0fffe17 	ldw	r3,-8(fp)
 4028478:	e0bfff17 	ldw	r2,-4(fp)
 402847c:	18bff31e 	bne	r3,r2,402844c <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 4028480:	e037883a 	mov	sp,fp
 4028484:	df000017 	ldw	fp,0(sp)
 4028488:	dec00104 	addi	sp,sp,4
 402848c:	f800283a 	ret

04028490 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4028490:	defffd04 	addi	sp,sp,-12
 4028494:	dfc00215 	stw	ra,8(sp)
 4028498:	df000115 	stw	fp,4(sp)
 402849c:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 40284a0:	0009883a 	mov	r4,zero
 40284a4:	40287980 	call	4028798 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 40284a8:	40287cc0 	call	40287cc <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 40284ac:	010100f4 	movhi	r4,1027
 40284b0:	2136ed04 	addi	r4,r4,-9292
 40284b4:	014100f4 	movhi	r5,1027
 40284b8:	2976ed04 	addi	r5,r5,-9292
 40284bc:	018100f4 	movhi	r6,1027
 40284c0:	31b6ed04 	addi	r6,r6,-9292
 40284c4:	402bf3c0 	call	402bf3c <alt_io_redirect>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 40284c8:	d126ca17 	ldw	r4,-25816(gp)
 40284cc:	d166cb17 	ldw	r5,-25812(gp)
 40284d0:	d1a6cc17 	ldw	r6,-25808(gp)
 40284d4:	40252480 	call	4025248 <main>
 40284d8:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 40284dc:	01000044 	movi	r4,1
 40284e0:	402b7900 	call	402b790 <close>
  exit (result);
 40284e4:	e13fff17 	ldw	r4,-4(fp)
 40284e8:	402cfc40 	call	402cfc4 <exit>

040284ec <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 40284ec:	defffe04 	addi	sp,sp,-8
 40284f0:	df000115 	stw	fp,4(sp)
 40284f4:	df000104 	addi	fp,sp,4
 40284f8:	e13fff15 	stw	r4,-4(fp)
}
 40284fc:	e037883a 	mov	sp,fp
 4028500:	df000017 	ldw	fp,0(sp)
 4028504:	dec00104 	addi	sp,sp,4
 4028508:	f800283a 	ret

0402850c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 402850c:	defffe04 	addi	sp,sp,-8
 4028510:	df000115 	stw	fp,4(sp)
 4028514:	df000104 	addi	fp,sp,4
 4028518:	e13fff15 	stw	r4,-4(fp)
}
 402851c:	e037883a 	mov	sp,fp
 4028520:	df000017 	ldw	fp,0(sp)
 4028524:	dec00104 	addi	sp,sp,4
 4028528:	f800283a 	ret

0402852c <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 402852c:	defff804 	addi	sp,sp,-32
 4028530:	df000715 	stw	fp,28(sp)
 4028534:	df000704 	addi	fp,sp,28
 4028538:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402853c:	0005303a 	rdctl	r2,status
 4028540:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4028544:	e0fffb17 	ldw	r3,-20(fp)
 4028548:	00bfff84 	movi	r2,-2
 402854c:	1884703a 	and	r2,r3,r2
 4028550:	1001703a 	wrctl	status,r2
  
  return context;
 4028554:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 4028558:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 402855c:	d0a01217 	ldw	r2,-32696(gp)
 4028560:	10c000c4 	addi	r3,r2,3
 4028564:	00bfff04 	movi	r2,-4
 4028568:	1884703a 	and	r2,r3,r2
 402856c:	d0a01215 	stw	r2,-32696(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 4028570:	d0e01217 	ldw	r3,-32696(gp)
 4028574:	e0bffe17 	ldw	r2,-8(fp)
 4028578:	1887883a 	add	r3,r3,r2
 402857c:	00810134 	movhi	r2,1028
 4028580:	10a00004 	addi	r2,r2,-32768
 4028584:	10c0072e 	bgeu	r2,r3,40285a4 <sbrk+0x78>
 4028588:	e0bffd17 	ldw	r2,-12(fp)
 402858c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4028590:	e0bffa17 	ldw	r2,-24(fp)
 4028594:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 4028598:	00bfffc4 	movi	r2,-1
 402859c:	e0bfff15 	stw	r2,-4(fp)
 40285a0:	00000c06 	br	40285d4 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 40285a4:	d0a01217 	ldw	r2,-32696(gp)
 40285a8:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 40285ac:	d0e01217 	ldw	r3,-32696(gp)
 40285b0:	e0bffe17 	ldw	r2,-8(fp)
 40285b4:	1885883a 	add	r2,r3,r2
 40285b8:	d0a01215 	stw	r2,-32696(gp)
 40285bc:	e0bffd17 	ldw	r2,-12(fp)
 40285c0:	e0bff915 	stw	r2,-28(fp)
 40285c4:	e0bff917 	ldw	r2,-28(fp)
 40285c8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 40285cc:	e0bffc17 	ldw	r2,-16(fp)
 40285d0:	e0bfff15 	stw	r2,-4(fp)
 40285d4:	e0bfff17 	ldw	r2,-4(fp)
} 
 40285d8:	e037883a 	mov	sp,fp
 40285dc:	df000017 	ldw	fp,0(sp)
 40285e0:	dec00104 	addi	sp,sp,4
 40285e4:	f800283a 	ret

040285e8 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 40285e8:	defffd04 	addi	sp,sp,-12
 40285ec:	dfc00215 	stw	ra,8(sp)
 40285f0:	df000115 	stw	fp,4(sp)
 40285f4:	df000104 	addi	fp,sp,4
 40285f8:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 40285fc:	e13fff17 	ldw	r4,-4(fp)
 4028600:	402b6440 	call	402b644 <alt_busy_sleep>
}
 4028604:	e037883a 	mov	sp,fp
 4028608:	dfc00117 	ldw	ra,4(sp)
 402860c:	df000017 	ldw	fp,0(sp)
 4028610:	dec00204 	addi	sp,sp,8
 4028614:	f800283a 	ret

04028618 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 4028618:	defff704 	addi	sp,sp,-36
 402861c:	dfc00815 	stw	ra,32(sp)
 4028620:	df000715 	stw	fp,28(sp)
 4028624:	df000704 	addi	fp,sp,28
 4028628:	e13ffb15 	stw	r4,-20(fp)
 402862c:	e17ffc15 	stw	r5,-16(fp)
 4028630:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 4028634:	e0bffb17 	ldw	r2,-20(fp)
 4028638:	1004803a 	cmplt	r2,r2,zero
 402863c:	1000081e 	bne	r2,zero,4028660 <write+0x48>
 4028640:	e0bffb17 	ldw	r2,-20(fp)
 4028644:	10800324 	muli	r2,r2,12
 4028648:	1007883a 	mov	r3,r2
 402864c:	008100f4 	movhi	r2,1027
 4028650:	10bcf904 	addi	r2,r2,-3100
 4028654:	1887883a 	add	r3,r3,r2
 4028658:	e0ffff15 	stw	r3,-4(fp)
 402865c:	00000106 	br	4028664 <write+0x4c>
 4028660:	e03fff15 	stw	zero,-4(fp)
 4028664:	e0bfff17 	ldw	r2,-4(fp)
 4028668:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 402866c:	e0bffa17 	ldw	r2,-24(fp)
 4028670:	1005003a 	cmpeq	r2,r2,zero
 4028674:	1000241e 	bne	r2,zero,4028708 <write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 4028678:	e0bffa17 	ldw	r2,-24(fp)
 402867c:	10800217 	ldw	r2,8(r2)
 4028680:	108000cc 	andi	r2,r2,3
 4028684:	1005003a 	cmpeq	r2,r2,zero
 4028688:	10001a1e 	bne	r2,zero,40286f4 <write+0xdc>
 402868c:	e0bffa17 	ldw	r2,-24(fp)
 4028690:	10800017 	ldw	r2,0(r2)
 4028694:	10800617 	ldw	r2,24(r2)
 4028698:	1005003a 	cmpeq	r2,r2,zero
 402869c:	1000151e 	bne	r2,zero,40286f4 <write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 40286a0:	e0bffa17 	ldw	r2,-24(fp)
 40286a4:	10800017 	ldw	r2,0(r2)
 40286a8:	10800617 	ldw	r2,24(r2)
 40286ac:	e17ffc17 	ldw	r5,-16(fp)
 40286b0:	e1bffd17 	ldw	r6,-12(fp)
 40286b4:	e13ffa17 	ldw	r4,-24(fp)
 40286b8:	103ee83a 	callr	r2
 40286bc:	e0bff915 	stw	r2,-28(fp)
 40286c0:	e0bff917 	ldw	r2,-28(fp)
 40286c4:	1004403a 	cmpge	r2,r2,zero
 40286c8:	1000071e 	bne	r2,zero,40286e8 <write+0xd0>
      {
        ALT_ERRNO = -rval;
 40286cc:	40287380 	call	4028738 <alt_get_errno>
 40286d0:	e0fff917 	ldw	r3,-28(fp)
 40286d4:	00c7c83a 	sub	r3,zero,r3
 40286d8:	10c00015 	stw	r3,0(r2)
        return -1;
 40286dc:	00bfffc4 	movi	r2,-1
 40286e0:	e0bffe15 	stw	r2,-8(fp)
 40286e4:	00000e06 	br	4028720 <write+0x108>
      }
      return rval;
 40286e8:	e0bff917 	ldw	r2,-28(fp)
 40286ec:	e0bffe15 	stw	r2,-8(fp)
 40286f0:	00000b06 	br	4028720 <write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 40286f4:	40287380 	call	4028738 <alt_get_errno>
 40286f8:	1007883a 	mov	r3,r2
 40286fc:	00800344 	movi	r2,13
 4028700:	18800015 	stw	r2,0(r3)
 4028704:	00000406 	br	4028718 <write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 4028708:	40287380 	call	4028738 <alt_get_errno>
 402870c:	1007883a 	mov	r3,r2
 4028710:	00801444 	movi	r2,81
 4028714:	18800015 	stw	r2,0(r3)
  }
  return -1;
 4028718:	00bfffc4 	movi	r2,-1
 402871c:	e0bffe15 	stw	r2,-8(fp)
 4028720:	e0bffe17 	ldw	r2,-8(fp)
}
 4028724:	e037883a 	mov	sp,fp
 4028728:	dfc00117 	ldw	ra,4(sp)
 402872c:	df000017 	ldw	fp,0(sp)
 4028730:	dec00204 	addi	sp,sp,8
 4028734:	f800283a 	ret

04028738 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4028738:	defffd04 	addi	sp,sp,-12
 402873c:	dfc00215 	stw	ra,8(sp)
 4028740:	df000115 	stw	fp,4(sp)
 4028744:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4028748:	008100f4 	movhi	r2,1027
 402874c:	10bd7104 	addi	r2,r2,-2620
 4028750:	10800017 	ldw	r2,0(r2)
 4028754:	1005003a 	cmpeq	r2,r2,zero
 4028758:	1000061e 	bne	r2,zero,4028774 <alt_get_errno+0x3c>
 402875c:	008100f4 	movhi	r2,1027
 4028760:	10bd7104 	addi	r2,r2,-2620
 4028764:	10800017 	ldw	r2,0(r2)
 4028768:	103ee83a 	callr	r2
 402876c:	e0bfff15 	stw	r2,-4(fp)
 4028770:	00000306 	br	4028780 <alt_get_errno+0x48>
 4028774:	008100f4 	movhi	r2,1027
 4028778:	10842204 	addi	r2,r2,4232
 402877c:	e0bfff15 	stw	r2,-4(fp)
 4028780:	e0bfff17 	ldw	r2,-4(fp)
}
 4028784:	e037883a 	mov	sp,fp
 4028788:	dfc00117 	ldw	ra,4(sp)
 402878c:	df000017 	ldw	fp,0(sp)
 4028790:	dec00204 	addi	sp,sp,8
 4028794:	f800283a 	ret

04028798 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 4028798:	defffd04 	addi	sp,sp,-12
 402879c:	dfc00215 	stw	ra,8(sp)
 40287a0:	df000115 	stw	fp,4(sp)
 40287a4:	df000104 	addi	fp,sp,4
 40287a8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
 40287ac:	402c47c0 	call	402c47c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 40287b0:	00800044 	movi	r2,1
 40287b4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 40287b8:	e037883a 	mov	sp,fp
 40287bc:	dfc00117 	ldw	ra,4(sp)
 40287c0:	df000017 	ldw	fp,0(sp)
 40287c4:	dec00204 	addi	sp,sp,8
 40287c8:	f800283a 	ret

040287cc <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 40287cc:	defffe04 	addi	sp,sp,-8
 40287d0:	dfc00115 	stw	ra,4(sp)
 40287d4:	df000015 	stw	fp,0(sp)
 40287d8:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 40287dc:	01010134 	movhi	r4,1028
 40287e0:	21040004 	addi	r4,r4,4096
 40287e4:	000b883a 	mov	r5,zero
 40287e8:	000d883a 	mov	r6,zero
 40287ec:	01c0fa04 	movi	r7,1000
 40287f0:	402b2f80 	call	402b2f8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMESTAMP_TIMER_1, timestamp_timer_1);
 40287f4:	00c100f4 	movhi	r3,1027
 40287f8:	18c42604 	addi	r3,r3,4248
 40287fc:	00810134 	movhi	r2,1028
 4028800:	10841004 	addi	r2,r2,4160
 4028804:	18800015 	stw	r2,0(r3)
 4028808:	00c100f4 	movhi	r3,1027
 402880c:	18c42704 	addi	r3,r3,4252
 4028810:	0080bef4 	movhi	r2,763
 4028814:	10bc2004 	addi	r2,r2,-3968
 4028818:	18800015 	stw	r2,0(r3)
    ALTERA_AVALON_CFI_FLASH_INIT ( CFI_FLASH_0, cfi_flash_0);
 402881c:	010100f4 	movhi	r4,1027
 4028820:	2138a104 	addi	r4,r4,-7548
 4028824:	40288940 	call	4028894 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 4028828:	010100f4 	movhi	r4,1027
 402882c:	2138e104 	addi	r4,r4,-7292
 4028830:	000b883a 	mov	r5,zero
 4028834:	01800204 	movi	r6,8
 4028838:	402a6ec0 	call	402a6ec <altera_avalon_jtag_uart_init>
 402883c:	010100f4 	movhi	r4,1027
 4028840:	2138d704 	addi	r4,r4,-7332
 4028844:	402885c0 	call	402885c <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
}
 4028848:	e037883a 	mov	sp,fp
 402884c:	dfc00117 	ldw	ra,4(sp)
 4028850:	df000017 	ldw	fp,0(sp)
 4028854:	dec00204 	addi	sp,sp,8
 4028858:	f800283a 	ret

0402885c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 402885c:	defffd04 	addi	sp,sp,-12
 4028860:	dfc00215 	stw	ra,8(sp)
 4028864:	df000115 	stw	fp,4(sp)
 4028868:	df000104 	addi	fp,sp,4
 402886c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 4028870:	e13fff17 	ldw	r4,-4(fp)
 4028874:	014100f4 	movhi	r5,1027
 4028878:	297d6e04 	addi	r5,r5,-2632
 402887c:	402b9d40 	call	402b9d4 <alt_dev_llist_insert>
}
 4028880:	e037883a 	mov	sp,fp
 4028884:	dfc00117 	ldw	ra,4(sp)
 4028888:	df000017 	ldw	fp,0(sp)
 402888c:	dec00204 	addi	sp,sp,8
 4028890:	f800283a 	ret

04028894 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 4028894:	defffc04 	addi	sp,sp,-16
 4028898:	dfc00315 	stw	ra,12(sp)
 402889c:	df000215 	stw	fp,8(sp)
 40288a0:	df000204 	addi	fp,sp,8
 40288a4:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 40288a8:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 40288ac:	e13fff17 	ldw	r4,-4(fp)
 40288b0:	4029d1c0 	call	4029d1c <alt_read_cfi_width>
 40288b4:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 40288b8:	e0bffe17 	ldw	r2,-8(fp)
 40288bc:	1004c03a 	cmpne	r2,r2,zero
 40288c0:	1000031e 	bne	r2,zero,40288d0 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 40288c4:	e13fff17 	ldw	r4,-4(fp)
 40288c8:	40294940 	call	4029494 <alt_set_flash_width_func>
 40288cc:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 40288d0:	e0bffe17 	ldw	r2,-8(fp)
 40288d4:	1004c03a 	cmpne	r2,r2,zero
 40288d8:	1000031e 	bne	r2,zero,40288e8 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 40288dc:	e13fff17 	ldw	r4,-4(fp)
 40288e0:	402979c0 	call	402979c <alt_read_cfi_table>
 40288e4:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 40288e8:	e0bffe17 	ldw	r2,-8(fp)
 40288ec:	1004c03a 	cmpne	r2,r2,zero
 40288f0:	1000031e 	bne	r2,zero,4028900 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 40288f4:	e13fff17 	ldw	r4,-4(fp)
 40288f8:	40296740 	call	4029674 <alt_set_flash_algorithm_func>
 40288fc:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 4028900:	e0bffe17 	ldw	r2,-8(fp)
 4028904:	1004c03a 	cmpne	r2,r2,zero
 4028908:	1000031e 	bne	r2,zero,4028918 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 402890c:	e13fff17 	ldw	r4,-4(fp)
 4028910:	40289300 	call	4028930 <alt_flash_device_register>
 4028914:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 4028918:	e0bffe17 	ldw	r2,-8(fp)
}
 402891c:	e037883a 	mov	sp,fp
 4028920:	dfc00117 	ldw	ra,4(sp)
 4028924:	df000017 	ldw	fp,0(sp)
 4028928:	dec00204 	addi	sp,sp,8
 402892c:	f800283a 	ret

04028930 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 4028930:	defffd04 	addi	sp,sp,-12
 4028934:	dfc00215 	stw	ra,8(sp)
 4028938:	df000115 	stw	fp,4(sp)
 402893c:	df000104 	addi	fp,sp,4
 4028940:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 4028944:	e13fff17 	ldw	r4,-4(fp)
 4028948:	014100f4 	movhi	r5,1027
 402894c:	297d6904 	addi	r5,r5,-2652
 4028950:	402b9d40 	call	402b9d4 <alt_dev_llist_insert>
}
 4028954:	e037883a 	mov	sp,fp
 4028958:	dfc00117 	ldw	ra,4(sp)
 402895c:	df000017 	ldw	fp,0(sp)
 4028960:	dec00204 	addi	sp,sp,8
 4028964:	f800283a 	ret

04028968 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 4028968:	deffef04 	addi	sp,sp,-68
 402896c:	dfc01015 	stw	ra,64(sp)
 4028970:	df000f15 	stw	fp,60(sp)
 4028974:	df000f04 	addi	fp,sp,60
 4028978:	e13ffa15 	stw	r4,-24(fp)
 402897c:	e17ffb15 	stw	r5,-20(fp)
 4028980:	e1bffc15 	stw	r6,-16(fp)
 4028984:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 4028988:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 402898c:	e0bffd17 	ldw	r2,-12(fp)
 4028990:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 4028994:	e0bffb17 	ldw	r2,-20(fp)
 4028998:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 402899c:	e0bffa17 	ldw	r2,-24(fp)
 40289a0:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 40289a4:	e03ff815 	stw	zero,-32(fp)
 40289a8:	00008e06 	br	4028be4 <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 40289ac:	e0bff817 	ldw	r2,-32(fp)
 40289b0:	e0fff217 	ldw	r3,-56(fp)
 40289b4:	1004913a 	slli	r2,r2,4
 40289b8:	10c5883a 	add	r2,r2,r3
 40289bc:	10800d04 	addi	r2,r2,52
 40289c0:	10c00017 	ldw	r3,0(r2)
 40289c4:	e0bffb17 	ldw	r2,-20(fp)
 40289c8:	10c08316 	blt	r2,r3,4028bd8 <alt_flash_cfi_write+0x270>
 40289cc:	e0bff817 	ldw	r2,-32(fp)
 40289d0:	e0fff217 	ldw	r3,-56(fp)
 40289d4:	1004913a 	slli	r2,r2,4
 40289d8:	10c5883a 	add	r2,r2,r3
 40289dc:	10800d04 	addi	r2,r2,52
 40289e0:	11000017 	ldw	r4,0(r2)
 40289e4:	e0bff817 	ldw	r2,-32(fp)
 40289e8:	e0fff217 	ldw	r3,-56(fp)
 40289ec:	1004913a 	slli	r2,r2,4
 40289f0:	10c5883a 	add	r2,r2,r3
 40289f4:	10800e04 	addi	r2,r2,56
 40289f8:	10800017 	ldw	r2,0(r2)
 40289fc:	2087883a 	add	r3,r4,r2
 4028a00:	e0bffb17 	ldw	r2,-20(fp)
 4028a04:	10c0740e 	bge	r2,r3,4028bd8 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 4028a08:	e0bff817 	ldw	r2,-32(fp)
 4028a0c:	e0fff217 	ldw	r3,-56(fp)
 4028a10:	1004913a 	slli	r2,r2,4
 4028a14:	10c5883a 	add	r2,r2,r3
 4028a18:	10800d04 	addi	r2,r2,52
 4028a1c:	10800017 	ldw	r2,0(r2)
 4028a20:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 4028a24:	e03ff715 	stw	zero,-36(fp)
 4028a28:	00006306 	br	4028bb8 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 4028a2c:	e0fffb17 	ldw	r3,-20(fp)
 4028a30:	e0bff417 	ldw	r2,-48(fp)
 4028a34:	18805416 	blt	r3,r2,4028b88 <alt_flash_cfi_write+0x220>
 4028a38:	e0bff817 	ldw	r2,-32(fp)
 4028a3c:	e0fff217 	ldw	r3,-56(fp)
 4028a40:	1004913a 	slli	r2,r2,4
 4028a44:	10c5883a 	add	r2,r2,r3
 4028a48:	10801004 	addi	r2,r2,64
 4028a4c:	10c00017 	ldw	r3,0(r2)
 4028a50:	e0bff417 	ldw	r2,-48(fp)
 4028a54:	1887883a 	add	r3,r3,r2
 4028a58:	e0bffb17 	ldw	r2,-20(fp)
 4028a5c:	10c04a0e 	bge	r2,r3,4028b88 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 4028a60:	e0bff817 	ldw	r2,-32(fp)
 4028a64:	e0fff217 	ldw	r3,-56(fp)
 4028a68:	1004913a 	slli	r2,r2,4
 4028a6c:	10c5883a 	add	r2,r2,r3
 4028a70:	10801004 	addi	r2,r2,64
 4028a74:	10c00017 	ldw	r3,0(r2)
 4028a78:	e0bff417 	ldw	r2,-48(fp)
 4028a7c:	1887883a 	add	r3,r3,r2
 4028a80:	e0bffb17 	ldw	r2,-20(fp)
 4028a84:	1885c83a 	sub	r2,r3,r2
 4028a88:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 4028a8c:	e0bff617 	ldw	r2,-40(fp)
 4028a90:	e0bfff15 	stw	r2,-4(fp)
 4028a94:	e0fffd17 	ldw	r3,-12(fp)
 4028a98:	e0fffe15 	stw	r3,-8(fp)
 4028a9c:	e0bfff17 	ldw	r2,-4(fp)
 4028aa0:	e0fffe17 	ldw	r3,-8(fp)
 4028aa4:	10c0020e 	bge	r2,r3,4028ab0 <alt_flash_cfi_write+0x148>
 4028aa8:	e0bfff17 	ldw	r2,-4(fp)
 4028aac:	e0bffe15 	stw	r2,-8(fp)
 4028ab0:	e0fffe17 	ldw	r3,-8(fp)
 4028ab4:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 4028ab8:	e0bff217 	ldw	r2,-56(fp)
 4028abc:	10800a17 	ldw	r2,40(r2)
 4028ac0:	1007883a 	mov	r3,r2
 4028ac4:	e0bffb17 	ldw	r2,-20(fp)
 4028ac8:	188b883a 	add	r5,r3,r2
 4028acc:	e1bff617 	ldw	r6,-40(fp)
 4028ad0:	e13ffc17 	ldw	r4,-16(fp)
 4028ad4:	402cfe40 	call	402cfe4 <memcmp>
 4028ad8:	1005003a 	cmpeq	r2,r2,zero
 4028adc:	1000131e 	bne	r2,zero,4028b2c <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 4028ae0:	e0bff217 	ldw	r2,-56(fp)
 4028ae4:	10800817 	ldw	r2,32(r2)
 4028ae8:	e13ff217 	ldw	r4,-56(fp)
 4028aec:	e17ff417 	ldw	r5,-48(fp)
 4028af0:	103ee83a 	callr	r2
 4028af4:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 4028af8:	e0bff917 	ldw	r2,-28(fp)
 4028afc:	1004c03a 	cmpne	r2,r2,zero
 4028b00:	10000a1e 	bne	r2,zero,4028b2c <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 4028b04:	e0bff217 	ldw	r2,-56(fp)
 4028b08:	10c00917 	ldw	r3,36(r2)
 4028b0c:	e13ff217 	ldw	r4,-56(fp)
 4028b10:	e0bff617 	ldw	r2,-40(fp)
 4028b14:	d8800015 	stw	r2,0(sp)
 4028b18:	e17ff417 	ldw	r5,-48(fp)
 4028b1c:	e1bffb17 	ldw	r6,-20(fp)
 4028b20:	e1fffc17 	ldw	r7,-16(fp)
 4028b24:	183ee83a 	callr	r3
 4028b28:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 4028b2c:	e0fffd17 	ldw	r3,-12(fp)
 4028b30:	e0bff617 	ldw	r2,-40(fp)
 4028b34:	18802f26 	beq	r3,r2,4028bf4 <alt_flash_cfi_write+0x28c>
 4028b38:	e0bff917 	ldw	r2,-28(fp)
 4028b3c:	1004c03a 	cmpne	r2,r2,zero
 4028b40:	10002c1e 	bne	r2,zero,4028bf4 <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 4028b44:	e0fffd17 	ldw	r3,-12(fp)
 4028b48:	e0bff617 	ldw	r2,-40(fp)
 4028b4c:	1885c83a 	sub	r2,r3,r2
 4028b50:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 4028b54:	e0bff817 	ldw	r2,-32(fp)
 4028b58:	e0fff217 	ldw	r3,-56(fp)
 4028b5c:	1004913a 	slli	r2,r2,4
 4028b60:	10c5883a 	add	r2,r2,r3
 4028b64:	10801004 	addi	r2,r2,64
 4028b68:	10c00017 	ldw	r3,0(r2)
 4028b6c:	e0bff417 	ldw	r2,-48(fp)
 4028b70:	1885883a 	add	r2,r3,r2
 4028b74:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 4028b78:	e0fffc17 	ldw	r3,-16(fp)
 4028b7c:	e0bff617 	ldw	r2,-40(fp)
 4028b80:	1885883a 	add	r2,r3,r2
 4028b84:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 4028b88:	e0bff817 	ldw	r2,-32(fp)
 4028b8c:	e0fff217 	ldw	r3,-56(fp)
 4028b90:	1004913a 	slli	r2,r2,4
 4028b94:	10c5883a 	add	r2,r2,r3
 4028b98:	10801004 	addi	r2,r2,64
 4028b9c:	10c00017 	ldw	r3,0(r2)
 4028ba0:	e0bff417 	ldw	r2,-48(fp)
 4028ba4:	10c5883a 	add	r2,r2,r3
 4028ba8:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 4028bac:	e0bff717 	ldw	r2,-36(fp)
 4028bb0:	10800044 	addi	r2,r2,1
 4028bb4:	e0bff715 	stw	r2,-36(fp)
 4028bb8:	e0bff817 	ldw	r2,-32(fp)
 4028bbc:	e0fff217 	ldw	r3,-56(fp)
 4028bc0:	1004913a 	slli	r2,r2,4
 4028bc4:	10c5883a 	add	r2,r2,r3
 4028bc8:	10800f04 	addi	r2,r2,60
 4028bcc:	10c00017 	ldw	r3,0(r2)
 4028bd0:	e0bff717 	ldw	r2,-36(fp)
 4028bd4:	10ff9516 	blt	r2,r3,4028a2c <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 4028bd8:	e0bff817 	ldw	r2,-32(fp)
 4028bdc:	10800044 	addi	r2,r2,1
 4028be0:	e0bff815 	stw	r2,-32(fp)
 4028be4:	e0bff217 	ldw	r2,-56(fp)
 4028be8:	10c00c17 	ldw	r3,48(r2)
 4028bec:	e0bff817 	ldw	r2,-32(fp)
 4028bf0:	10ff6e16 	blt	r2,r3,40289ac <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 4028bf4:	e0bff217 	ldw	r2,-56(fp)
 4028bf8:	10800a17 	ldw	r2,40(r2)
 4028bfc:	1007883a 	mov	r3,r2
 4028c00:	e0bff317 	ldw	r2,-52(fp)
 4028c04:	1889883a 	add	r4,r3,r2
 4028c08:	e17ff517 	ldw	r5,-44(fp)
 4028c0c:	402b8ec0 	call	402b8ec <alt_dcache_flush>
  return ret_code;
 4028c10:	e0bff917 	ldw	r2,-28(fp)
}
 4028c14:	e037883a 	mov	sp,fp
 4028c18:	dfc00117 	ldw	ra,4(sp)
 4028c1c:	df000017 	ldw	fp,0(sp)
 4028c20:	dec00204 	addi	sp,sp,8
 4028c24:	f800283a 	ret

04028c28 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 4028c28:	defffa04 	addi	sp,sp,-24
 4028c2c:	df000515 	stw	fp,20(sp)
 4028c30:	df000504 	addi	fp,sp,20
 4028c34:	e13ffd15 	stw	r4,-12(fp)
 4028c38:	e17ffe15 	stw	r5,-8(fp)
 4028c3c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 4028c40:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 4028c44:	e0bffd17 	ldw	r2,-12(fp)
 4028c48:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 4028c4c:	e0bffb17 	ldw	r2,-20(fp)
 4028c50:	10c00c17 	ldw	r3,48(r2)
 4028c54:	e0bfff17 	ldw	r2,-4(fp)
 4028c58:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 4028c5c:	e0bffb17 	ldw	r2,-20(fp)
 4028c60:	10800c17 	ldw	r2,48(r2)
 4028c64:	1004c03a 	cmpne	r2,r2,zero
 4028c68:	1000031e 	bne	r2,zero,4028c78 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 4028c6c:	00bffec4 	movi	r2,-5
 4028c70:	e0bffc15 	stw	r2,-16(fp)
 4028c74:	00000b06 	br	4028ca4 <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 4028c78:	e0bffb17 	ldw	r2,-20(fp)
 4028c7c:	10800c17 	ldw	r2,48(r2)
 4028c80:	10800250 	cmplti	r2,r2,9
 4028c84:	1000031e 	bne	r2,zero,4028c94 <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 4028c88:	00bffd04 	movi	r2,-12
 4028c8c:	e0bffc15 	stw	r2,-16(fp)
 4028c90:	00000406 	br	4028ca4 <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 4028c94:	e0bffb17 	ldw	r2,-20(fp)
 4028c98:	10c00d04 	addi	r3,r2,52
 4028c9c:	e0bffe17 	ldw	r2,-8(fp)
 4028ca0:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 4028ca4:	e0bffc17 	ldw	r2,-16(fp)
}
 4028ca8:	e037883a 	mov	sp,fp
 4028cac:	df000017 	ldw	fp,0(sp)
 4028cb0:	dec00104 	addi	sp,sp,4
 4028cb4:	f800283a 	ret

04028cb8 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 4028cb8:	defff904 	addi	sp,sp,-28
 4028cbc:	dfc00615 	stw	ra,24(sp)
 4028cc0:	df000515 	stw	fp,20(sp)
 4028cc4:	df000504 	addi	fp,sp,20
 4028cc8:	e13ffc15 	stw	r4,-16(fp)
 4028ccc:	e17ffd15 	stw	r5,-12(fp)
 4028cd0:	e1bffe15 	stw	r6,-8(fp)
 4028cd4:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 4028cd8:	e0bffc17 	ldw	r2,-16(fp)
 4028cdc:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 4028ce0:	e0bffb17 	ldw	r2,-20(fp)
 4028ce4:	10800a17 	ldw	r2,40(r2)
 4028ce8:	1007883a 	mov	r3,r2
 4028cec:	e0bffd17 	ldw	r2,-12(fp)
 4028cf0:	1887883a 	add	r3,r3,r2
 4028cf4:	e1bfff17 	ldw	r6,-4(fp)
 4028cf8:	e0bffe17 	ldw	r2,-8(fp)
 4028cfc:	1009883a 	mov	r4,r2
 4028d00:	180b883a 	mov	r5,r3
 4028d04:	40273c80 	call	40273c8 <memcpy>
  return 0;
 4028d08:	0005883a 	mov	r2,zero
}
 4028d0c:	e037883a 	mov	sp,fp
 4028d10:	dfc00117 	ldw	ra,4(sp)
 4028d14:	df000017 	ldw	fp,0(sp)
 4028d18:	dec00204 	addi	sp,sp,8
 4028d1c:	f800283a 	ret

04028d20 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 4028d20:	defffa04 	addi	sp,sp,-24
 4028d24:	df000515 	stw	fp,20(sp)
 4028d28:	df000504 	addi	fp,sp,20
 4028d2c:	e13ffd15 	stw	r4,-12(fp)
 4028d30:	e17ffe15 	stw	r5,-8(fp)
 4028d34:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 4028d38:	e0bffd17 	ldw	r2,-12(fp)
 4028d3c:	10802e17 	ldw	r2,184(r2)
 4028d40:	10800058 	cmpnei	r2,r2,1
 4028d44:	10000b1e 	bne	r2,zero,4028d74 <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 4028d48:	e0bffd17 	ldw	r2,-12(fp)
 4028d4c:	10800a17 	ldw	r2,40(r2)
 4028d50:	1007883a 	mov	r3,r2
 4028d54:	e0bffe17 	ldw	r2,-8(fp)
 4028d58:	1889883a 	add	r4,r3,r2
 4028d5c:	e0bfff17 	ldw	r2,-4(fp)
 4028d60:	10800003 	ldbu	r2,0(r2)
 4028d64:	10c03fcc 	andi	r3,r2,255
 4028d68:	2005883a 	mov	r2,r4
 4028d6c:	10c00025 	stbio	r3,0(r2)
 4028d70:	00004006 	br	4028e74 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 4028d74:	e0bffd17 	ldw	r2,-12(fp)
 4028d78:	10802e17 	ldw	r2,184(r2)
 4028d7c:	10800098 	cmpnei	r2,r2,2
 4028d80:	1000151e 	bne	r2,zero,4028dd8 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 4028d84:	e0bfff17 	ldw	r2,-4(fp)
 4028d88:	10800003 	ldbu	r2,0(r2)
 4028d8c:	10803fcc 	andi	r2,r2,255
 4028d90:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 4028d94:	e0bfff17 	ldw	r2,-4(fp)
 4028d98:	10800044 	addi	r2,r2,1
 4028d9c:	10800003 	ldbu	r2,0(r2)
 4028da0:	10803fcc 	andi	r2,r2,255
 4028da4:	1004923a 	slli	r2,r2,8
 4028da8:	1007883a 	mov	r3,r2
 4028dac:	e0bffc0b 	ldhu	r2,-16(fp)
 4028db0:	1884b03a 	or	r2,r3,r2
 4028db4:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 4028db8:	e0bffd17 	ldw	r2,-12(fp)
 4028dbc:	10800a17 	ldw	r2,40(r2)
 4028dc0:	1007883a 	mov	r3,r2
 4028dc4:	e0bffe17 	ldw	r2,-8(fp)
 4028dc8:	1885883a 	add	r2,r3,r2
 4028dcc:	e0fffc0b 	ldhu	r3,-16(fp)
 4028dd0:	10c0002d 	sthio	r3,0(r2)
 4028dd4:	00002706 	br	4028e74 <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 4028dd8:	e0bffd17 	ldw	r2,-12(fp)
 4028ddc:	10802e17 	ldw	r2,184(r2)
 4028de0:	10800118 	cmpnei	r2,r2,4
 4028de4:	1000231e 	bne	r2,zero,4028e74 <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 4028de8:	e0bfff17 	ldw	r2,-4(fp)
 4028dec:	10800003 	ldbu	r2,0(r2)
 4028df0:	10803fcc 	andi	r2,r2,255
 4028df4:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 4028df8:	e0bfff17 	ldw	r2,-4(fp)
 4028dfc:	10800044 	addi	r2,r2,1
 4028e00:	10800003 	ldbu	r2,0(r2)
 4028e04:	10803fcc 	andi	r2,r2,255
 4028e08:	1006923a 	slli	r3,r2,8
 4028e0c:	e0bffb17 	ldw	r2,-20(fp)
 4028e10:	10c4b03a 	or	r2,r2,r3
 4028e14:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 4028e18:	e0bfff17 	ldw	r2,-4(fp)
 4028e1c:	10800084 	addi	r2,r2,2
 4028e20:	10800003 	ldbu	r2,0(r2)
 4028e24:	10803fcc 	andi	r2,r2,255
 4028e28:	1006943a 	slli	r3,r2,16
 4028e2c:	e0bffb17 	ldw	r2,-20(fp)
 4028e30:	10c4b03a 	or	r2,r2,r3
 4028e34:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 4028e38:	e0bfff17 	ldw	r2,-4(fp)
 4028e3c:	108000c4 	addi	r2,r2,3
 4028e40:	10800003 	ldbu	r2,0(r2)
 4028e44:	10803fcc 	andi	r2,r2,255
 4028e48:	1006963a 	slli	r3,r2,24
 4028e4c:	e0bffb17 	ldw	r2,-20(fp)
 4028e50:	10c4b03a 	or	r2,r2,r3
 4028e54:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 4028e58:	e0bffd17 	ldw	r2,-12(fp)
 4028e5c:	10800a17 	ldw	r2,40(r2)
 4028e60:	1007883a 	mov	r3,r2
 4028e64:	e0bffe17 	ldw	r2,-8(fp)
 4028e68:	1885883a 	add	r2,r3,r2
 4028e6c:	e0fffb17 	ldw	r3,-20(fp)
 4028e70:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 4028e74:	e037883a 	mov	sp,fp
 4028e78:	df000017 	ldw	fp,0(sp)
 4028e7c:	dec00104 	addi	sp,sp,4
 4028e80:	f800283a 	ret

04028e84 <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 4028e84:	defff304 	addi	sp,sp,-52
 4028e88:	dfc00c15 	stw	ra,48(sp)
 4028e8c:	df000b15 	stw	fp,44(sp)
 4028e90:	df000b04 	addi	fp,sp,44
 4028e94:	e13ffc15 	stw	r4,-16(fp)
 4028e98:	e17ffd15 	stw	r5,-12(fp)
 4028e9c:	e1bffe15 	stw	r6,-8(fp)
 4028ea0:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 4028ea4:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 4028ea8:	e0bffc17 	ldw	r2,-16(fp)
 4028eac:	10800a17 	ldw	r2,40(r2)
 4028eb0:	1007883a 	mov	r3,r2
 4028eb4:	e0bffd17 	ldw	r2,-12(fp)
 4028eb8:	1885883a 	add	r2,r3,r2
 4028ebc:	1009883a 	mov	r4,r2
 4028ec0:	e0bffc17 	ldw	r2,-16(fp)
 4028ec4:	11402e17 	ldw	r5,184(r2)
 4028ec8:	40266340 	call	4026634 <__modsi3>
 4028ecc:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 4028ed0:	e0bff917 	ldw	r2,-28(fp)
 4028ed4:	1005003a 	cmpeq	r2,r2,zero
 4028ed8:	10003a1e 	bne	r2,zero,4028fc4 <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 4028edc:	e0bffc17 	ldw	r2,-16(fp)
 4028ee0:	10c02e17 	ldw	r3,184(r2)
 4028ee4:	e0bff917 	ldw	r2,-28(fp)
 4028ee8:	1885c83a 	sub	r2,r3,r2
 4028eec:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 4028ef0:	e03ff615 	stw	zero,-40(fp)
 4028ef4:	00001206 	br	4028f40 <alt_flash_program_block+0xbc>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 4028ef8:	e17ff617 	ldw	r5,-40(fp)
 4028efc:	e0bffc17 	ldw	r2,-16(fp)
 4028f00:	10800a17 	ldw	r2,40(r2)
 4028f04:	1009883a 	mov	r4,r2
 4028f08:	e0fffd17 	ldw	r3,-12(fp)
 4028f0c:	e0bff917 	ldw	r2,-28(fp)
 4028f10:	1887c83a 	sub	r3,r3,r2
 4028f14:	e0bff617 	ldw	r2,-40(fp)
 4028f18:	1885883a 	add	r2,r3,r2
 4028f1c:	2085883a 	add	r2,r4,r2
 4028f20:	10800023 	ldbuio	r2,0(r2)
 4028f24:	1007883a 	mov	r3,r2
 4028f28:	e0bffb04 	addi	r2,fp,-20
 4028f2c:	1145883a 	add	r2,r2,r5
 4028f30:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 4028f34:	e0bff617 	ldw	r2,-40(fp)
 4028f38:	10800044 	addi	r2,r2,1
 4028f3c:	e0bff615 	stw	r2,-40(fp)
 4028f40:	e0fff617 	ldw	r3,-40(fp)
 4028f44:	e0bff917 	ldw	r2,-28(fp)
 4028f48:	18bfeb16 	blt	r3,r2,4028ef8 <alt_flash_program_block+0x74>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 4028f4c:	e03ff615 	stw	zero,-40(fp)
 4028f50:	00000e06 	br	4028f8c <alt_flash_program_block+0x108>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 4028f54:	e0fff917 	ldw	r3,-28(fp)
 4028f58:	e0bff617 	ldw	r2,-40(fp)
 4028f5c:	1889883a 	add	r4,r3,r2
 4028f60:	e0bff617 	ldw	r2,-40(fp)
 4028f64:	1007883a 	mov	r3,r2
 4028f68:	e0bffe17 	ldw	r2,-8(fp)
 4028f6c:	1885883a 	add	r2,r3,r2
 4028f70:	10c00003 	ldbu	r3,0(r2)
 4028f74:	e0bffb04 	addi	r2,fp,-20
 4028f78:	1105883a 	add	r2,r2,r4
 4028f7c:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 4028f80:	e0bff617 	ldw	r2,-40(fp)
 4028f84:	10800044 	addi	r2,r2,1
 4028f88:	e0bff615 	stw	r2,-40(fp)
 4028f8c:	e0fff617 	ldw	r3,-40(fp)
 4028f90:	e0bff817 	ldw	r2,-32(fp)
 4028f94:	18bfef16 	blt	r3,r2,4028f54 <alt_flash_program_block+0xd0>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 4028f98:	e0fffd17 	ldw	r3,-12(fp)
 4028f9c:	e0bff917 	ldw	r2,-28(fp)
 4028fa0:	188bc83a 	sub	r5,r3,r2
 4028fa4:	e1bffb04 	addi	r6,fp,-20
 4028fa8:	e0800217 	ldw	r2,8(fp)
 4028fac:	e13ffc17 	ldw	r4,-16(fp)
 4028fb0:	103ee83a 	callr	r2
 4028fb4:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 4028fb8:	e0bff817 	ldw	r2,-32(fp)
 4028fbc:	e0bff615 	stw	r2,-40(fp)
 4028fc0:	00000106 	br	4028fc8 <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
 4028fc4:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 4028fc8:	e0fffd17 	ldw	r3,-12(fp)
 4028fcc:	e0bfff17 	ldw	r2,-4(fp)
 4028fd0:	1889883a 	add	r4,r3,r2
 4028fd4:	e0bffc17 	ldw	r2,-16(fp)
 4028fd8:	11402e17 	ldw	r5,184(r2)
 4028fdc:	40266340 	call	4026634 <__modsi3>
 4028fe0:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 4028fe4:	00001006 	br	4029028 <alt_flash_program_block+0x1a4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 4028fe8:	e0fffd17 	ldw	r3,-12(fp)
 4028fec:	e0bff617 	ldw	r2,-40(fp)
 4028ff0:	188b883a 	add	r5,r3,r2
 4028ff4:	e0bff617 	ldw	r2,-40(fp)
 4028ff8:	1007883a 	mov	r3,r2
 4028ffc:	e0bffe17 	ldw	r2,-8(fp)
 4029000:	188d883a 	add	r6,r3,r2
 4029004:	e0800217 	ldw	r2,8(fp)
 4029008:	e13ffc17 	ldw	r4,-16(fp)
 402900c:	103ee83a 	callr	r2
 4029010:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 4029014:	e0bffc17 	ldw	r2,-16(fp)
 4029018:	10c02e17 	ldw	r3,184(r2)
 402901c:	e0bff617 	ldw	r2,-40(fp)
 4029020:	10c5883a 	add	r2,r2,r3
 4029024:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 4029028:	e0bffa17 	ldw	r2,-24(fp)
 402902c:	1004c03a 	cmpne	r2,r2,zero
 4029030:	1000051e 	bne	r2,zero,4029048 <alt_flash_program_block+0x1c4>
 4029034:	e0ffff17 	ldw	r3,-4(fp)
 4029038:	e0bff717 	ldw	r2,-36(fp)
 402903c:	1887c83a 	sub	r3,r3,r2
 4029040:	e0bff617 	ldw	r2,-40(fp)
 4029044:	10ffe816 	blt	r2,r3,4028fe8 <alt_flash_program_block+0x164>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 4029048:	e0bff717 	ldw	r2,-36(fp)
 402904c:	1005003a 	cmpeq	r2,r2,zero
 4029050:	10003c1e 	bne	r2,zero,4029144 <alt_flash_program_block+0x2c0>
 4029054:	e0bffa17 	ldw	r2,-24(fp)
 4029058:	1004c03a 	cmpne	r2,r2,zero
 402905c:	1000391e 	bne	r2,zero,4029144 <alt_flash_program_block+0x2c0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 4029060:	e0bffc17 	ldw	r2,-16(fp)
 4029064:	10c02e17 	ldw	r3,184(r2)
 4029068:	e0bff717 	ldw	r2,-36(fp)
 402906c:	1885c83a 	sub	r2,r3,r2
 4029070:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 4029074:	e03ff515 	stw	zero,-44(fp)
 4029078:	00000e06 	br	40290b4 <alt_flash_program_block+0x230>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 402907c:	e13ff517 	ldw	r4,-44(fp)
 4029080:	e0bff617 	ldw	r2,-40(fp)
 4029084:	1007883a 	mov	r3,r2
 4029088:	e0bffe17 	ldw	r2,-8(fp)
 402908c:	1887883a 	add	r3,r3,r2
 4029090:	e0bff517 	ldw	r2,-44(fp)
 4029094:	1885883a 	add	r2,r3,r2
 4029098:	10c00003 	ldbu	r3,0(r2)
 402909c:	e0bffb04 	addi	r2,fp,-20
 40290a0:	1105883a 	add	r2,r2,r4
 40290a4:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 40290a8:	e0bff517 	ldw	r2,-44(fp)
 40290ac:	10800044 	addi	r2,r2,1
 40290b0:	e0bff515 	stw	r2,-44(fp)
 40290b4:	e0fff517 	ldw	r3,-44(fp)
 40290b8:	e0bff717 	ldw	r2,-36(fp)
 40290bc:	18bfef16 	blt	r3,r2,402907c <alt_flash_program_block+0x1f8>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 40290c0:	e03ff515 	stw	zero,-44(fp)
 40290c4:	00001406 	br	4029118 <alt_flash_program_block+0x294>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 40290c8:	e0fff717 	ldw	r3,-36(fp)
 40290cc:	e0bff517 	ldw	r2,-44(fp)
 40290d0:	188b883a 	add	r5,r3,r2
 40290d4:	e0bffc17 	ldw	r2,-16(fp)
 40290d8:	10800a17 	ldw	r2,40(r2)
 40290dc:	1009883a 	mov	r4,r2
 40290e0:	e0fffd17 	ldw	r3,-12(fp)
 40290e4:	e0bfff17 	ldw	r2,-4(fp)
 40290e8:	1887883a 	add	r3,r3,r2
 40290ec:	e0bff517 	ldw	r2,-44(fp)
 40290f0:	1885883a 	add	r2,r3,r2
 40290f4:	2085883a 	add	r2,r4,r2
 40290f8:	10800023 	ldbuio	r2,0(r2)
 40290fc:	1007883a 	mov	r3,r2
 4029100:	e0bffb04 	addi	r2,fp,-20
 4029104:	1145883a 	add	r2,r2,r5
 4029108:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 402910c:	e0bff517 	ldw	r2,-44(fp)
 4029110:	10800044 	addi	r2,r2,1
 4029114:	e0bff515 	stw	r2,-44(fp)
 4029118:	e0fff517 	ldw	r3,-44(fp)
 402911c:	e0bff917 	ldw	r2,-28(fp)
 4029120:	18bfe916 	blt	r3,r2,40290c8 <alt_flash_program_block+0x244>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 4029124:	e0fffd17 	ldw	r3,-12(fp)
 4029128:	e0bff617 	ldw	r2,-40(fp)
 402912c:	188b883a 	add	r5,r3,r2
 4029130:	e1bffb04 	addi	r6,fp,-20
 4029134:	e0800217 	ldw	r2,8(fp)
 4029138:	e13ffc17 	ldw	r4,-16(fp)
 402913c:	103ee83a 	callr	r2
 4029140:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 4029144:	e0bffa17 	ldw	r2,-24(fp)
}
 4029148:	e037883a 	mov	sp,fp
 402914c:	dfc00117 	ldw	ra,4(sp)
 4029150:	df000017 	ldw	fp,0(sp)
 4029154:	dec00204 	addi	sp,sp,8
 4029158:	f800283a 	ret

0402915c <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 402915c:	defffd04 	addi	sp,sp,-12
 4029160:	df000215 	stw	fp,8(sp)
 4029164:	df000204 	addi	fp,sp,8
 4029168:	e13ffe15 	stw	r4,-8(fp)
 402916c:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 4029170:	e0bffe17 	ldw	r2,-8(fp)
 4029174:	10800a17 	ldw	r2,40(r2)
 4029178:	1007883a 	mov	r3,r2
 402917c:	e0bfff17 	ldw	r2,-4(fp)
 4029180:	1885883a 	add	r2,r3,r2
 4029184:	10800023 	ldbuio	r2,0(r2)
 4029188:	10803fcc 	andi	r2,r2,255
}
 402918c:	e037883a 	mov	sp,fp
 4029190:	df000017 	ldw	fp,0(sp)
 4029194:	dec00104 	addi	sp,sp,4
 4029198:	f800283a 	ret

0402919c <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 402919c:	defffd04 	addi	sp,sp,-12
 40291a0:	df000215 	stw	fp,8(sp)
 40291a4:	df000204 	addi	fp,sp,8
 40291a8:	e13ffe15 	stw	r4,-8(fp)
 40291ac:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 40291b0:	e0bffe17 	ldw	r2,-8(fp)
 40291b4:	10800a17 	ldw	r2,40(r2)
 40291b8:	1007883a 	mov	r3,r2
 40291bc:	e0bfff17 	ldw	r2,-4(fp)
 40291c0:	1085883a 	add	r2,r2,r2
 40291c4:	1885883a 	add	r2,r3,r2
 40291c8:	1080002b 	ldhuio	r2,0(r2)
 40291cc:	10803fcc 	andi	r2,r2,255
}
 40291d0:	e037883a 	mov	sp,fp
 40291d4:	df000017 	ldw	fp,0(sp)
 40291d8:	dec00104 	addi	sp,sp,4
 40291dc:	f800283a 	ret

040291e0 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 40291e0:	defffd04 	addi	sp,sp,-12
 40291e4:	df000215 	stw	fp,8(sp)
 40291e8:	df000204 	addi	fp,sp,8
 40291ec:	e13ffe15 	stw	r4,-8(fp)
 40291f0:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 40291f4:	e0bffe17 	ldw	r2,-8(fp)
 40291f8:	10800a17 	ldw	r2,40(r2)
 40291fc:	1007883a 	mov	r3,r2
 4029200:	e0bfff17 	ldw	r2,-4(fp)
 4029204:	1085883a 	add	r2,r2,r2
 4029208:	1085883a 	add	r2,r2,r2
 402920c:	1885883a 	add	r2,r3,r2
 4029210:	10800037 	ldwio	r2,0(r2)
 4029214:	10803fcc 	andi	r2,r2,255
}
 4029218:	e037883a 	mov	sp,fp
 402921c:	df000017 	ldw	fp,0(sp)
 4029220:	dec00104 	addi	sp,sp,4
 4029224:	f800283a 	ret

04029228 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 4029228:	defffc04 	addi	sp,sp,-16
 402922c:	df000315 	stw	fp,12(sp)
 4029230:	df000304 	addi	fp,sp,12
 4029234:	e13ffd15 	stw	r4,-12(fp)
 4029238:	e17ffe15 	stw	r5,-8(fp)
 402923c:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 4029240:	e0fffd17 	ldw	r3,-12(fp)
 4029244:	e0bffe17 	ldw	r2,-8(fp)
 4029248:	1885883a 	add	r2,r3,r2
 402924c:	e0ffff03 	ldbu	r3,-4(fp)
 4029250:	10c00025 	stbio	r3,0(r2)
  return;
}
 4029254:	e037883a 	mov	sp,fp
 4029258:	df000017 	ldw	fp,0(sp)
 402925c:	dec00104 	addi	sp,sp,4
 4029260:	f800283a 	ret

04029264 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 4029264:	defffc04 	addi	sp,sp,-16
 4029268:	df000315 	stw	fp,12(sp)
 402926c:	df000304 	addi	fp,sp,12
 4029270:	e13ffd15 	stw	r4,-12(fp)
 4029274:	e17ffe15 	stw	r5,-8(fp)
 4029278:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 402927c:	e0bffe17 	ldw	r2,-8(fp)
 4029280:	1080004c 	andi	r2,r2,1
 4029284:	10803fcc 	andi	r2,r2,255
 4029288:	1005003a 	cmpeq	r2,r2,zero
 402928c:	1000081e 	bne	r2,zero,40292b0 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 4029290:	e0bffe17 	ldw	r2,-8(fp)
 4029294:	1085883a 	add	r2,r2,r2
 4029298:	1007883a 	mov	r3,r2
 402929c:	e0bffd17 	ldw	r2,-12(fp)
 40292a0:	1885883a 	add	r2,r3,r2
 40292a4:	e0ffff03 	ldbu	r3,-4(fp)
 40292a8:	10c00025 	stbio	r3,0(r2)
 40292ac:	00000806 	br	40292d0 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 40292b0:	e0bffe17 	ldw	r2,-8(fp)
 40292b4:	1085883a 	add	r2,r2,r2
 40292b8:	1007883a 	mov	r3,r2
 40292bc:	e0bffd17 	ldw	r2,-12(fp)
 40292c0:	1885883a 	add	r2,r3,r2
 40292c4:	10800044 	addi	r2,r2,1
 40292c8:	e0ffff03 	ldbu	r3,-4(fp)
 40292cc:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 40292d0:	e037883a 	mov	sp,fp
 40292d4:	df000017 	ldw	fp,0(sp)
 40292d8:	dec00104 	addi	sp,sp,4
 40292dc:	f800283a 	ret

040292e0 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 40292e0:	defffc04 	addi	sp,sp,-16
 40292e4:	df000315 	stw	fp,12(sp)
 40292e8:	df000304 	addi	fp,sp,12
 40292ec:	e13ffd15 	stw	r4,-12(fp)
 40292f0:	e17ffe15 	stw	r5,-8(fp)
 40292f4:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 40292f8:	e0bffe17 	ldw	r2,-8(fp)
 40292fc:	1085883a 	add	r2,r2,r2
 4029300:	1085883a 	add	r2,r2,r2
 4029304:	1007883a 	mov	r3,r2
 4029308:	e0bffd17 	ldw	r2,-12(fp)
 402930c:	1885883a 	add	r2,r3,r2
 4029310:	e0ffff03 	ldbu	r3,-4(fp)
 4029314:	10c00025 	stbio	r3,0(r2)
  return;
}
 4029318:	e037883a 	mov	sp,fp
 402931c:	df000017 	ldw	fp,0(sp)
 4029320:	dec00104 	addi	sp,sp,4
 4029324:	f800283a 	ret

04029328 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 4029328:	defffc04 	addi	sp,sp,-16
 402932c:	df000315 	stw	fp,12(sp)
 4029330:	df000304 	addi	fp,sp,12
 4029334:	e13ffd15 	stw	r4,-12(fp)
 4029338:	e17ffe15 	stw	r5,-8(fp)
 402933c:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 4029340:	e0bffe17 	ldw	r2,-8(fp)
 4029344:	1085883a 	add	r2,r2,r2
 4029348:	1007883a 	mov	r3,r2
 402934c:	e0bffd17 	ldw	r2,-12(fp)
 4029350:	1885883a 	add	r2,r3,r2
 4029354:	e0ffff03 	ldbu	r3,-4(fp)
 4029358:	10c0002d 	sthio	r3,0(r2)
  return;
}
 402935c:	e037883a 	mov	sp,fp
 4029360:	df000017 	ldw	fp,0(sp)
 4029364:	dec00104 	addi	sp,sp,4
 4029368:	f800283a 	ret

0402936c <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 402936c:	defffc04 	addi	sp,sp,-16
 4029370:	df000315 	stw	fp,12(sp)
 4029374:	df000304 	addi	fp,sp,12
 4029378:	e13ffd15 	stw	r4,-12(fp)
 402937c:	e17ffe15 	stw	r5,-8(fp)
 4029380:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 4029384:	e0bffe17 	ldw	r2,-8(fp)
 4029388:	1085883a 	add	r2,r2,r2
 402938c:	1085883a 	add	r2,r2,r2
 4029390:	1007883a 	mov	r3,r2
 4029394:	e0bffd17 	ldw	r2,-12(fp)
 4029398:	1885883a 	add	r2,r3,r2
 402939c:	e0ffff03 	ldbu	r3,-4(fp)
 40293a0:	10c0002d 	sthio	r3,0(r2)
  return;
}
 40293a4:	e037883a 	mov	sp,fp
 40293a8:	df000017 	ldw	fp,0(sp)
 40293ac:	dec00104 	addi	sp,sp,4
 40293b0:	f800283a 	ret

040293b4 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 40293b4:	defffc04 	addi	sp,sp,-16
 40293b8:	df000315 	stw	fp,12(sp)
 40293bc:	df000304 	addi	fp,sp,12
 40293c0:	e13ffd15 	stw	r4,-12(fp)
 40293c4:	e17ffe15 	stw	r5,-8(fp)
 40293c8:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 40293cc:	e0bffe17 	ldw	r2,-8(fp)
 40293d0:	1085883a 	add	r2,r2,r2
 40293d4:	1085883a 	add	r2,r2,r2
 40293d8:	1007883a 	mov	r3,r2
 40293dc:	e0bffd17 	ldw	r2,-12(fp)
 40293e0:	1885883a 	add	r2,r3,r2
 40293e4:	e0ffff03 	ldbu	r3,-4(fp)
 40293e8:	10c00035 	stwio	r3,0(r2)
  return;
}
 40293ec:	e037883a 	mov	sp,fp
 40293f0:	df000017 	ldw	fp,0(sp)
 40293f4:	dec00104 	addi	sp,sp,4
 40293f8:	f800283a 	ret

040293fc <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 40293fc:	defffd04 	addi	sp,sp,-12
 4029400:	df000215 	stw	fp,8(sp)
 4029404:	df000204 	addi	fp,sp,8
 4029408:	e13ffe15 	stw	r4,-8(fp)
 402940c:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 4029410:	e0bfff17 	ldw	r2,-4(fp)
 4029414:	10c03fcc 	andi	r3,r2,255
 4029418:	e0bffe17 	ldw	r2,-8(fp)
 402941c:	10c00025 	stbio	r3,0(r2)
  return;
}
 4029420:	e037883a 	mov	sp,fp
 4029424:	df000017 	ldw	fp,0(sp)
 4029428:	dec00104 	addi	sp,sp,4
 402942c:	f800283a 	ret

04029430 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 4029430:	defffd04 	addi	sp,sp,-12
 4029434:	df000215 	stw	fp,8(sp)
 4029438:	df000204 	addi	fp,sp,8
 402943c:	e13ffe15 	stw	r4,-8(fp)
 4029440:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 4029444:	e0bfff17 	ldw	r2,-4(fp)
 4029448:	10ffffcc 	andi	r3,r2,65535
 402944c:	e0bffe17 	ldw	r2,-8(fp)
 4029450:	10c0002d 	sthio	r3,0(r2)
  return;
}
 4029454:	e037883a 	mov	sp,fp
 4029458:	df000017 	ldw	fp,0(sp)
 402945c:	dec00104 	addi	sp,sp,4
 4029460:	f800283a 	ret

04029464 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 4029464:	defffd04 	addi	sp,sp,-12
 4029468:	df000215 	stw	fp,8(sp)
 402946c:	df000204 	addi	fp,sp,8
 4029470:	e13ffe15 	stw	r4,-8(fp)
 4029474:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 4029478:	e0ffff17 	ldw	r3,-4(fp)
 402947c:	e0bffe17 	ldw	r2,-8(fp)
 4029480:	10c00035 	stwio	r3,0(r2)
  return;
}
 4029484:	e037883a 	mov	sp,fp
 4029488:	df000017 	ldw	fp,0(sp)
 402948c:	dec00104 	addi	sp,sp,4
 4029490:	f800283a 	ret

04029494 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 4029494:	defffb04 	addi	sp,sp,-20
 4029498:	df000415 	stw	fp,16(sp)
 402949c:	df000404 	addi	fp,sp,16
 40294a0:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 40294a4:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 40294a8:	e0bffd17 	ldw	r2,-12(fp)
 40294ac:	10802e17 	ldw	r2,184(r2)
 40294b0:	e0bfff15 	stw	r2,-4(fp)
 40294b4:	e0ffff17 	ldw	r3,-4(fp)
 40294b8:	188000a0 	cmpeqi	r2,r3,2
 40294bc:	1000261e 	bne	r2,zero,4029558 <alt_set_flash_width_func+0xc4>
 40294c0:	e0ffff17 	ldw	r3,-4(fp)
 40294c4:	18800120 	cmpeqi	r2,r3,4
 40294c8:	1000391e 	bne	r2,zero,40295b0 <alt_set_flash_width_func+0x11c>
 40294cc:	e0ffff17 	ldw	r3,-4(fp)
 40294d0:	18800060 	cmpeqi	r2,r3,1
 40294d4:	1000011e 	bne	r2,zero,40294dc <alt_set_flash_width_func+0x48>
 40294d8:	00003e06 	br	40295d4 <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 40294dc:	e0fffd17 	ldw	r3,-12(fp)
 40294e0:	008100f4 	movhi	r2,1027
 40294e4:	10a4ff04 	addi	r2,r2,-27652
 40294e8:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 40294ec:	e0bffd17 	ldw	r2,-12(fp)
 40294f0:	10802f17 	ldw	r2,188(r2)
 40294f4:	10800058 	cmpnei	r2,r2,1
 40294f8:	1000051e 	bne	r2,zero,4029510 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 40294fc:	e0fffd17 	ldw	r3,-12(fp)
 4029500:	008100f4 	movhi	r2,1027
 4029504:	10a48a04 	addi	r2,r2,-28120
 4029508:	18803315 	stw	r2,204(r3)
 402950c:	00003306 	br	40295dc <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 4029510:	e0bffd17 	ldw	r2,-12(fp)
 4029514:	10802f17 	ldw	r2,188(r2)
 4029518:	10800098 	cmpnei	r2,r2,2
 402951c:	1000051e 	bne	r2,zero,4029534 <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 4029520:	e0fffd17 	ldw	r3,-12(fp)
 4029524:	008100f4 	movhi	r2,1027
 4029528:	10a49904 	addi	r2,r2,-28060
 402952c:	18803315 	stw	r2,204(r3)
 4029530:	00002a06 	br	40295dc <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 4029534:	e0bffd17 	ldw	r2,-12(fp)
 4029538:	10802f17 	ldw	r2,188(r2)
 402953c:	10800118 	cmpnei	r2,r2,4
 4029540:	1000261e 	bne	r2,zero,40295dc <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 4029544:	e0fffd17 	ldw	r3,-12(fp)
 4029548:	008100f4 	movhi	r2,1027
 402954c:	10a4b804 	addi	r2,r2,-27936
 4029550:	18803315 	stw	r2,204(r3)
      }
      break;
 4029554:	00002106 	br	40295dc <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 4029558:	e0fffd17 	ldw	r3,-12(fp)
 402955c:	008100f4 	movhi	r2,1027
 4029560:	10a50c04 	addi	r2,r2,-27600
 4029564:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 4029568:	e0bffd17 	ldw	r2,-12(fp)
 402956c:	10802f17 	ldw	r2,188(r2)
 4029570:	10800098 	cmpnei	r2,r2,2
 4029574:	1000051e 	bne	r2,zero,402958c <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 4029578:	e0fffd17 	ldw	r3,-12(fp)
 402957c:	008100f4 	movhi	r2,1027
 4029580:	10a4ca04 	addi	r2,r2,-27864
 4029584:	18803315 	stw	r2,204(r3)
 4029588:	00001406 	br	40295dc <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 402958c:	e0bffd17 	ldw	r2,-12(fp)
 4029590:	10802f17 	ldw	r2,188(r2)
 4029594:	10800118 	cmpnei	r2,r2,4
 4029598:	1000101e 	bne	r2,zero,40295dc <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 402959c:	e0fffd17 	ldw	r3,-12(fp)
 40295a0:	008100f4 	movhi	r2,1027
 40295a4:	10a4db04 	addi	r2,r2,-27796
 40295a8:	18803315 	stw	r2,204(r3)
      }

      break;
 40295ac:	00000b06 	br	40295dc <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 40295b0:	e0fffd17 	ldw	r3,-12(fp)
 40295b4:	008100f4 	movhi	r2,1027
 40295b8:	10a51904 	addi	r2,r2,-27548
 40295bc:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 40295c0:	e0fffd17 	ldw	r3,-12(fp)
 40295c4:	008100f4 	movhi	r2,1027
 40295c8:	10a4ed04 	addi	r2,r2,-27724
 40295cc:	18803315 	stw	r2,204(r3)
      break;
 40295d0:	00000206 	br	40295dc <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 40295d4:	00bffcc4 	movi	r2,-13
 40295d8:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 40295dc:	e0bffc17 	ldw	r2,-16(fp)
 40295e0:	1004c03a 	cmpne	r2,r2,zero
 40295e4:	10001e1e 	bne	r2,zero,4029660 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 40295e8:	e0bffd17 	ldw	r2,-12(fp)
 40295ec:	10802f17 	ldw	r2,188(r2)
 40295f0:	e0bffe15 	stw	r2,-8(fp)
 40295f4:	e0fffe17 	ldw	r3,-8(fp)
 40295f8:	188000a0 	cmpeqi	r2,r3,2
 40295fc:	10000c1e 	bne	r2,zero,4029630 <alt_set_flash_width_func+0x19c>
 4029600:	e0fffe17 	ldw	r3,-8(fp)
 4029604:	18800120 	cmpeqi	r2,r3,4
 4029608:	10000e1e 	bne	r2,zero,4029644 <alt_set_flash_width_func+0x1b0>
 402960c:	e0fffe17 	ldw	r3,-8(fp)
 4029610:	18800060 	cmpeqi	r2,r3,1
 4029614:	1000011e 	bne	r2,zero,402961c <alt_set_flash_width_func+0x188>
 4029618:	00000f06 	br	4029658 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 402961c:	e0fffd17 	ldw	r3,-12(fp)
 4029620:	008100f4 	movhi	r2,1027
 4029624:	10a45704 	addi	r2,r2,-28324
 4029628:	18803415 	stw	r2,208(r3)
        break;
 402962c:	00000c06 	br	4029660 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 4029630:	e0fffd17 	ldw	r3,-12(fp)
 4029634:	008100f4 	movhi	r2,1027
 4029638:	10a46704 	addi	r2,r2,-28260
 402963c:	18803415 	stw	r2,208(r3)
        break;
 4029640:	00000706 	br	4029660 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 4029644:	e0fffd17 	ldw	r3,-12(fp)
 4029648:	008100f4 	movhi	r2,1027
 402964c:	10a47804 	addi	r2,r2,-28192
 4029650:	18803415 	stw	r2,208(r3)
        break;
 4029654:	00000206 	br	4029660 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 4029658:	00bffcc4 	movi	r2,-13
 402965c:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 4029660:	e0bffc17 	ldw	r2,-16(fp)
}
 4029664:	e037883a 	mov	sp,fp
 4029668:	df000017 	ldw	fp,0(sp)
 402966c:	dec00104 	addi	sp,sp,4
 4029670:	f800283a 	ret

04029674 <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 4029674:	defffc04 	addi	sp,sp,-16
 4029678:	df000315 	stw	fp,12(sp)
 402967c:	df000304 	addi	fp,sp,12
 4029680:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 4029684:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 4029688:	e0bffe17 	ldw	r2,-8(fp)
 402968c:	10802d17 	ldw	r2,180(r2)
 4029690:	e0bfff15 	stw	r2,-4(fp)
 4029694:	e0ffff17 	ldw	r3,-4(fp)
 4029698:	188000a0 	cmpeqi	r2,r3,2
 402969c:	1000071e 	bne	r2,zero,40296bc <alt_set_flash_algorithm_func+0x48>
 40296a0:	e0ffff17 	ldw	r3,-4(fp)
 40296a4:	188000e0 	cmpeqi	r2,r3,3
 40296a8:	10000d1e 	bne	r2,zero,40296e0 <alt_set_flash_algorithm_func+0x6c>
 40296ac:	e0ffff17 	ldw	r3,-4(fp)
 40296b0:	18800060 	cmpeqi	r2,r3,1
 40296b4:	10000a1e 	bne	r2,zero,40296e0 <alt_set_flash_algorithm_func+0x6c>
 40296b8:	00001206 	br	4029704 <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 40296bc:	e0fffe17 	ldw	r3,-8(fp)
 40296c0:	008100f4 	movhi	r2,1027
 40296c4:	10b14104 	addi	r2,r2,-15100
 40296c8:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 40296cc:	e0fffe17 	ldw	r3,-8(fp)
 40296d0:	008100f4 	movhi	r2,1027
 40296d4:	10b12704 	addi	r2,r2,-15204
 40296d8:	18800915 	stw	r2,36(r3)
      break;
 40296dc:	00000b06 	br	402970c <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 40296e0:	e0fffe17 	ldw	r3,-8(fp)
 40296e4:	008100f4 	movhi	r2,1027
 40296e8:	10b26004 	addi	r2,r2,-13952
 40296ec:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 40296f0:	e0fffe17 	ldw	r3,-8(fp)
 40296f4:	008100f4 	movhi	r2,1027
 40296f8:	10b23f04 	addi	r2,r2,-14084
 40296fc:	18800915 	stw	r2,36(r3)
      break;
 4029700:	00000206 	br	402970c <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 4029704:	00bffec4 	movi	r2,-5
 4029708:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 402970c:	e0bffd17 	ldw	r2,-12(fp)
}
 4029710:	e037883a 	mov	sp,fp
 4029714:	df000017 	ldw	fp,0(sp)
 4029718:	dec00104 	addi	sp,sp,4
 402971c:	f800283a 	ret

04029720 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 4029720:	defffb04 	addi	sp,sp,-20
 4029724:	dfc00415 	stw	ra,16(sp)
 4029728:	df000315 	stw	fp,12(sp)
 402972c:	df000304 	addi	fp,sp,12
 4029730:	e13ffe15 	stw	r4,-8(fp)
 4029734:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 4029738:	e0bffe17 	ldw	r2,-8(fp)
 402973c:	10803417 	ldw	r2,208(r2)
 4029740:	e13ffe17 	ldw	r4,-8(fp)
 4029744:	e17fff17 	ldw	r5,-4(fp)
 4029748:	103ee83a 	callr	r2
 402974c:	10803fcc 	andi	r2,r2,255
 4029750:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 4029754:	e0bffe17 	ldw	r2,-8(fp)
 4029758:	10c03417 	ldw	r3,208(r2)
 402975c:	e0bfff17 	ldw	r2,-4(fp)
 4029760:	11400044 	addi	r5,r2,1
 4029764:	e13ffe17 	ldw	r4,-8(fp)
 4029768:	183ee83a 	callr	r3
 402976c:	10803fcc 	andi	r2,r2,255
 4029770:	1004923a 	slli	r2,r2,8
 4029774:	1007883a 	mov	r3,r2
 4029778:	e0bffd0b 	ldhu	r2,-12(fp)
 402977c:	1884b03a 	or	r2,r3,r2
 4029780:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 4029784:	e0bffd0b 	ldhu	r2,-12(fp)
}
 4029788:	e037883a 	mov	sp,fp
 402978c:	dfc00117 	ldw	ra,4(sp)
 4029790:	df000017 	ldw	fp,0(sp)
 4029794:	dec00204 	addi	sp,sp,8
 4029798:	f800283a 	ret

0402979c <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 402979c:	defff204 	addi	sp,sp,-56
 40297a0:	dfc00d15 	stw	ra,52(sp)
 40297a4:	df000c15 	stw	fp,48(sp)
 40297a8:	dc000b15 	stw	r16,44(sp)
 40297ac:	df000b04 	addi	fp,sp,44
 40297b0:	e13fff15 	stw	r4,-4(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 40297b4:	e03ffb15 	stw	zero,-20(fp)
  int   size = 0;
 40297b8:	e03ffa15 	stw	zero,-24(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 40297bc:	e03ff615 	stw	zero,-40(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 40297c0:	e13fff17 	ldw	r4,-4(fp)
 40297c4:	402a4c80 	call	402a4c8 <alt_check_primary_table>
 40297c8:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 40297cc:	e0bffb17 	ldw	r2,-20(fp)
 40297d0:	1004c03a 	cmpne	r2,r2,zero
 40297d4:	10014a1e 	bne	r2,zero,4029d00 <alt_read_cfi_table+0x564>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 40297d8:	e0bfff17 	ldw	r2,-4(fp)
 40297dc:	10803417 	ldw	r2,208(r2)
 40297e0:	e13fff17 	ldw	r4,-4(fp)
 40297e4:	014004c4 	movi	r5,19
 40297e8:	103ee83a 	callr	r2
 40297ec:	10c03fcc 	andi	r3,r2,255
 40297f0:	e0bfff17 	ldw	r2,-4(fp)
 40297f4:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 40297f8:	e0bfff17 	ldw	r2,-4(fp)
 40297fc:	10803417 	ldw	r2,208(r2)
 4029800:	e13fff17 	ldw	r4,-4(fp)
 4029804:	014007c4 	movi	r5,31
 4029808:	103ee83a 	callr	r2
 402980c:	10803fcc 	andi	r2,r2,255
 4029810:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 4029814:	e0bfff17 	ldw	r2,-4(fp)
 4029818:	10803417 	ldw	r2,208(r2)
 402981c:	e13fff17 	ldw	r4,-4(fp)
 4029820:	014008c4 	movi	r5,35
 4029824:	103ee83a 	callr	r2
 4029828:	10803fcc 	andi	r2,r2,255
 402982c:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 4029830:	e0bff817 	ldw	r2,-32(fp)
 4029834:	1005003a 	cmpeq	r2,r2,zero
 4029838:	1000031e 	bne	r2,zero,4029848 <alt_read_cfi_table+0xac>
 402983c:	e0bff717 	ldw	r2,-36(fp)
 4029840:	1004c03a 	cmpne	r2,r2,zero
 4029844:	1000041e 	bne	r2,zero,4029858 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 4029848:	e0ffff17 	ldw	r3,-4(fp)
 402984c:	0080fa04 	movi	r2,1000
 4029850:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 4029854:	00000706 	br	4029874 <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 4029858:	00c00044 	movi	r3,1
 402985c:	e0bff817 	ldw	r2,-32(fp)
 4029860:	1886983a 	sll	r3,r3,r2
 4029864:	e0bff717 	ldw	r2,-36(fp)
 4029868:	1886983a 	sll	r3,r3,r2
 402986c:	e0bfff17 	ldw	r2,-4(fp)
 4029870:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 4029874:	e0bfff17 	ldw	r2,-4(fp)
 4029878:	10803417 	ldw	r2,208(r2)
 402987c:	e13fff17 	ldw	r4,-4(fp)
 4029880:	01400844 	movi	r5,33
 4029884:	103ee83a 	callr	r2
 4029888:	10803fcc 	andi	r2,r2,255
 402988c:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 4029890:	e0bfff17 	ldw	r2,-4(fp)
 4029894:	10803417 	ldw	r2,208(r2)
 4029898:	e13fff17 	ldw	r4,-4(fp)
 402989c:	01400944 	movi	r5,37
 40298a0:	103ee83a 	callr	r2
 40298a4:	10803fcc 	andi	r2,r2,255
 40298a8:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 40298ac:	e0bff817 	ldw	r2,-32(fp)
 40298b0:	1005003a 	cmpeq	r2,r2,zero
 40298b4:	1000031e 	bne	r2,zero,40298c4 <alt_read_cfi_table+0x128>
 40298b8:	e0bff717 	ldw	r2,-36(fp)
 40298bc:	1004c03a 	cmpne	r2,r2,zero
 40298c0:	1000051e 	bne	r2,zero,40298d8 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 40298c4:	e0ffff17 	ldw	r3,-4(fp)
 40298c8:	00804c74 	movhi	r2,305
 40298cc:	108b4004 	addi	r2,r2,11520
 40298d0:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 40298d4:	00000806 	br	40298f8 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 40298d8:	00c00044 	movi	r3,1
 40298dc:	e0bff817 	ldw	r2,-32(fp)
 40298e0:	1886983a 	sll	r3,r3,r2
 40298e4:	e0bff717 	ldw	r2,-36(fp)
 40298e8:	1884983a 	sll	r2,r3,r2
 40298ec:	10c0fa24 	muli	r3,r2,1000
 40298f0:	e0bfff17 	ldw	r2,-4(fp)
 40298f4:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 40298f8:	e0bfff17 	ldw	r2,-4(fp)
 40298fc:	10803417 	ldw	r2,208(r2)
 4029900:	e13fff17 	ldw	r4,-4(fp)
 4029904:	014009c4 	movi	r5,39
 4029908:	103ee83a 	callr	r2
 402990c:	10c03fcc 	andi	r3,r2,255
 4029910:	00800044 	movi	r2,1
 4029914:	10c4983a 	sll	r2,r2,r3
 4029918:	e0bffc15 	stw	r2,-16(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 402991c:	e0bfff17 	ldw	r2,-4(fp)
 4029920:	10803417 	ldw	r2,208(r2)
 4029924:	e13fff17 	ldw	r4,-4(fp)
 4029928:	01400b04 	movi	r5,44
 402992c:	103ee83a 	callr	r2
 4029930:	10c03fcc 	andi	r3,r2,255
 4029934:	e0bfff17 	ldw	r2,-4(fp)
 4029938:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 402993c:	e0bfff17 	ldw	r2,-4(fp)
 4029940:	10800c17 	ldw	r2,48(r2)
 4029944:	10800250 	cmplti	r2,r2,9
 4029948:	1000031e 	bne	r2,zero,4029958 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 402994c:	00bffd04 	movi	r2,-12
 4029950:	e0bffb15 	stw	r2,-20(fp)
 4029954:	00005e06 	br	4029ad0 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 4029958:	e03ffe15 	stw	zero,-8(fp)
 402995c:	00005306 	br	4029aac <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 4029960:	e43ffe17 	ldw	r16,-8(fp)
 4029964:	e0bffe17 	ldw	r2,-8(fp)
 4029968:	1085883a 	add	r2,r2,r2
 402996c:	1085883a 	add	r2,r2,r2
 4029970:	11400b44 	addi	r5,r2,45
 4029974:	e13fff17 	ldw	r4,-4(fp)
 4029978:	40297200 	call	4029720 <alt_read_16bit_query_entry>
 402997c:	113fffcc 	andi	r4,r2,65535
 4029980:	e0ffff17 	ldw	r3,-4(fp)
 4029984:	8004913a 	slli	r2,r16,4
 4029988:	10c5883a 	add	r2,r2,r3
 402998c:	10800f04 	addi	r2,r2,60
 4029990:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 4029994:	e17ffe17 	ldw	r5,-8(fp)
 4029998:	e0bffe17 	ldw	r2,-8(fp)
 402999c:	e0ffff17 	ldw	r3,-4(fp)
 40299a0:	1004913a 	slli	r2,r2,4
 40299a4:	10c5883a 	add	r2,r2,r3
 40299a8:	10800f04 	addi	r2,r2,60
 40299ac:	10800017 	ldw	r2,0(r2)
 40299b0:	11000044 	addi	r4,r2,1
 40299b4:	e0ffff17 	ldw	r3,-4(fp)
 40299b8:	2804913a 	slli	r2,r5,4
 40299bc:	10c5883a 	add	r2,r2,r3
 40299c0:	10800f04 	addi	r2,r2,60
 40299c4:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 40299c8:	e43ffe17 	ldw	r16,-8(fp)
 40299cc:	e0bffe17 	ldw	r2,-8(fp)
 40299d0:	1085883a 	add	r2,r2,r2
 40299d4:	1085883a 	add	r2,r2,r2
 40299d8:	11400bc4 	addi	r5,r2,47
 40299dc:	e13fff17 	ldw	r4,-4(fp)
 40299e0:	40297200 	call	4029720 <alt_read_16bit_query_entry>
 40299e4:	113fffcc 	andi	r4,r2,65535
 40299e8:	e0ffff17 	ldw	r3,-4(fp)
 40299ec:	8004913a 	slli	r2,r16,4
 40299f0:	10c5883a 	add	r2,r2,r3
 40299f4:	10801004 	addi	r2,r2,64
 40299f8:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 40299fc:	e17ffe17 	ldw	r5,-8(fp)
 4029a00:	e0bffe17 	ldw	r2,-8(fp)
 4029a04:	e0ffff17 	ldw	r3,-4(fp)
 4029a08:	1004913a 	slli	r2,r2,4
 4029a0c:	10c5883a 	add	r2,r2,r3
 4029a10:	10801004 	addi	r2,r2,64
 4029a14:	10800017 	ldw	r2,0(r2)
 4029a18:	1008923a 	slli	r4,r2,8
 4029a1c:	e0ffff17 	ldw	r3,-4(fp)
 4029a20:	2804913a 	slli	r2,r5,4
 4029a24:	10c5883a 	add	r2,r2,r3
 4029a28:	10801004 	addi	r2,r2,64
 4029a2c:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 4029a30:	e17ffe17 	ldw	r5,-8(fp)
 4029a34:	e0bffe17 	ldw	r2,-8(fp)
 4029a38:	e0ffff17 	ldw	r3,-4(fp)
 4029a3c:	1004913a 	slli	r2,r2,4
 4029a40:	10c5883a 	add	r2,r2,r3
 4029a44:	10800f04 	addi	r2,r2,60
 4029a48:	11000017 	ldw	r4,0(r2)
 4029a4c:	e0bffe17 	ldw	r2,-8(fp)
 4029a50:	e0ffff17 	ldw	r3,-4(fp)
 4029a54:	1004913a 	slli	r2,r2,4
 4029a58:	10c5883a 	add	r2,r2,r3
 4029a5c:	10801004 	addi	r2,r2,64
 4029a60:	10800017 	ldw	r2,0(r2)
 4029a64:	2089383a 	mul	r4,r4,r2
 4029a68:	e0ffff17 	ldw	r3,-4(fp)
 4029a6c:	2804913a 	slli	r2,r5,4
 4029a70:	10c5883a 	add	r2,r2,r3
 4029a74:	10800e04 	addi	r2,r2,56
 4029a78:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 4029a7c:	e0bffe17 	ldw	r2,-8(fp)
 4029a80:	e0ffff17 	ldw	r3,-4(fp)
 4029a84:	1004913a 	slli	r2,r2,4
 4029a88:	10c5883a 	add	r2,r2,r3
 4029a8c:	10800e04 	addi	r2,r2,56
 4029a90:	10c00017 	ldw	r3,0(r2)
 4029a94:	e0bffa17 	ldw	r2,-24(fp)
 4029a98:	10c5883a 	add	r2,r2,r3
 4029a9c:	e0bffa15 	stw	r2,-24(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 4029aa0:	e0bffe17 	ldw	r2,-8(fp)
 4029aa4:	10800044 	addi	r2,r2,1
 4029aa8:	e0bffe15 	stw	r2,-8(fp)
 4029aac:	e0bfff17 	ldw	r2,-4(fp)
 4029ab0:	10c00c17 	ldw	r3,48(r2)
 4029ab4:	e0bffe17 	ldw	r2,-8(fp)
 4029ab8:	10ffa916 	blt	r2,r3,4029960 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 4029abc:	e0fffa17 	ldw	r3,-24(fp)
 4029ac0:	e0bffc17 	ldw	r2,-16(fp)
 4029ac4:	18800226 	beq	r3,r2,4029ad0 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 4029ac8:	00bffb44 	movi	r2,-19
 4029acc:	e0bffb15 	stw	r2,-20(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 4029ad0:	e0bfff17 	ldw	r2,-4(fp)
 4029ad4:	10c03417 	ldw	r3,208(r2)
 4029ad8:	e0bfff17 	ldw	r2,-4(fp)
 4029adc:	10803217 	ldw	r2,200(r2)
 4029ae0:	114003c4 	addi	r5,r2,15
 4029ae4:	e13fff17 	ldw	r4,-4(fp)
 4029ae8:	183ee83a 	callr	r3
 4029aec:	e0bff505 	stb	r2,-44(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 4029af0:	e0bfff17 	ldw	r2,-4(fp)
 4029af4:	10802d17 	ldw	r2,180(r2)
 4029af8:	10800098 	cmpnei	r2,r2,2
 4029afc:	1000601e 	bne	r2,zero,4029c80 <alt_read_cfi_table+0x4e4>
 4029b00:	e0bff503 	ldbu	r2,-44(fp)
 4029b04:	108000d8 	cmpnei	r2,r2,3
 4029b08:	10005d1e 	bne	r2,zero,4029c80 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 4029b0c:	e0bfff17 	ldw	r2,-4(fp)
 4029b10:	10800c17 	ldw	r2,48(r2)
 4029b14:	10bfffc4 	addi	r2,r2,-1
 4029b18:	e0bffe15 	stw	r2,-8(fp)
 4029b1c:	e03ffd15 	stw	zero,-12(fp)
          j<=i;i--,j++)
 4029b20:	00005406 	br	4029c74 <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 4029b24:	e0bffe17 	ldw	r2,-8(fp)
 4029b28:	e0ffff17 	ldw	r3,-4(fp)
 4029b2c:	1004913a 	slli	r2,r2,4
 4029b30:	10c5883a 	add	r2,r2,r3
 4029b34:	10800e04 	addi	r2,r2,56
 4029b38:	10800017 	ldw	r2,0(r2)
 4029b3c:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].region_size =  
 4029b40:	e17ffe17 	ldw	r5,-8(fp)
 4029b44:	e0bffd17 	ldw	r2,-12(fp)
 4029b48:	e0ffff17 	ldw	r3,-4(fp)
 4029b4c:	1004913a 	slli	r2,r2,4
 4029b50:	10c5883a 	add	r2,r2,r3
 4029b54:	10800e04 	addi	r2,r2,56
 4029b58:	11000017 	ldw	r4,0(r2)
 4029b5c:	e0ffff17 	ldw	r3,-4(fp)
 4029b60:	2804913a 	slli	r2,r5,4
 4029b64:	10c5883a 	add	r2,r2,r3
 4029b68:	10800e04 	addi	r2,r2,56
 4029b6c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 4029b70:	e0bffd17 	ldw	r2,-12(fp)
 4029b74:	e0ffff17 	ldw	r3,-4(fp)
 4029b78:	1004913a 	slli	r2,r2,4
 4029b7c:	10c5883a 	add	r2,r2,r3
 4029b80:	10c00e04 	addi	r3,r2,56
 4029b84:	e0bff917 	ldw	r2,-28(fp)
 4029b88:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 4029b8c:	e0bffe17 	ldw	r2,-8(fp)
 4029b90:	e0ffff17 	ldw	r3,-4(fp)
 4029b94:	1004913a 	slli	r2,r2,4
 4029b98:	10c5883a 	add	r2,r2,r3
 4029b9c:	10801004 	addi	r2,r2,64
 4029ba0:	10800017 	ldw	r2,0(r2)
 4029ba4:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].block_size =  
 4029ba8:	e17ffe17 	ldw	r5,-8(fp)
 4029bac:	e0bffd17 	ldw	r2,-12(fp)
 4029bb0:	e0ffff17 	ldw	r3,-4(fp)
 4029bb4:	1004913a 	slli	r2,r2,4
 4029bb8:	10c5883a 	add	r2,r2,r3
 4029bbc:	10801004 	addi	r2,r2,64
 4029bc0:	11000017 	ldw	r4,0(r2)
 4029bc4:	e0ffff17 	ldw	r3,-4(fp)
 4029bc8:	2804913a 	slli	r2,r5,4
 4029bcc:	10c5883a 	add	r2,r2,r3
 4029bd0:	10801004 	addi	r2,r2,64
 4029bd4:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 4029bd8:	e0bffd17 	ldw	r2,-12(fp)
 4029bdc:	e0ffff17 	ldw	r3,-4(fp)
 4029be0:	1004913a 	slli	r2,r2,4
 4029be4:	10c5883a 	add	r2,r2,r3
 4029be8:	10c01004 	addi	r3,r2,64
 4029bec:	e0bff917 	ldw	r2,-28(fp)
 4029bf0:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 4029bf4:	e0bffe17 	ldw	r2,-8(fp)
 4029bf8:	e0ffff17 	ldw	r3,-4(fp)
 4029bfc:	1004913a 	slli	r2,r2,4
 4029c00:	10c5883a 	add	r2,r2,r3
 4029c04:	10800f04 	addi	r2,r2,60
 4029c08:	10800017 	ldw	r2,0(r2)
 4029c0c:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].number_of_blocks =  
 4029c10:	e17ffe17 	ldw	r5,-8(fp)
 4029c14:	e0bffd17 	ldw	r2,-12(fp)
 4029c18:	e0ffff17 	ldw	r3,-4(fp)
 4029c1c:	1004913a 	slli	r2,r2,4
 4029c20:	10c5883a 	add	r2,r2,r3
 4029c24:	10800f04 	addi	r2,r2,60
 4029c28:	11000017 	ldw	r4,0(r2)
 4029c2c:	e0ffff17 	ldw	r3,-4(fp)
 4029c30:	2804913a 	slli	r2,r5,4
 4029c34:	10c5883a 	add	r2,r2,r3
 4029c38:	10800f04 	addi	r2,r2,60
 4029c3c:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 4029c40:	e0bffd17 	ldw	r2,-12(fp)
 4029c44:	e0ffff17 	ldw	r3,-4(fp)
 4029c48:	1004913a 	slli	r2,r2,4
 4029c4c:	10c5883a 	add	r2,r2,r3
 4029c50:	10c00f04 	addi	r3,r2,60
 4029c54:	e0bff917 	ldw	r2,-28(fp)
 4029c58:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 4029c5c:	e0bffe17 	ldw	r2,-8(fp)
 4029c60:	10bfffc4 	addi	r2,r2,-1
 4029c64:	e0bffe15 	stw	r2,-8(fp)
 4029c68:	e0bffd17 	ldw	r2,-12(fp)
 4029c6c:	10800044 	addi	r2,r2,1
 4029c70:	e0bffd15 	stw	r2,-12(fp)
 4029c74:	e0fffd17 	ldw	r3,-12(fp)
 4029c78:	e0bffe17 	ldw	r2,-8(fp)
 4029c7c:	10ffa90e 	bge	r2,r3,4029b24 <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 4029c80:	e03ffe15 	stw	zero,-8(fp)
 4029c84:	00001306 	br	4029cd4 <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 4029c88:	e0bffe17 	ldw	r2,-8(fp)
 4029c8c:	e0ffff17 	ldw	r3,-4(fp)
 4029c90:	1004913a 	slli	r2,r2,4
 4029c94:	10c5883a 	add	r2,r2,r3
 4029c98:	10c00d04 	addi	r3,r2,52
 4029c9c:	e0bff617 	ldw	r2,-40(fp)
 4029ca0:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 4029ca4:	e0bffe17 	ldw	r2,-8(fp)
 4029ca8:	e0ffff17 	ldw	r3,-4(fp)
 4029cac:	1004913a 	slli	r2,r2,4
 4029cb0:	10c5883a 	add	r2,r2,r3
 4029cb4:	10800e04 	addi	r2,r2,56
 4029cb8:	10c00017 	ldw	r3,0(r2)
 4029cbc:	e0bff617 	ldw	r2,-40(fp)
 4029cc0:	10c5883a 	add	r2,r2,r3
 4029cc4:	e0bff615 	stw	r2,-40(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 4029cc8:	e0bffe17 	ldw	r2,-8(fp)
 4029ccc:	10800044 	addi	r2,r2,1
 4029cd0:	e0bffe15 	stw	r2,-8(fp)
 4029cd4:	e0bfff17 	ldw	r2,-4(fp)
 4029cd8:	10c00c17 	ldw	r3,48(r2)
 4029cdc:	e0bffe17 	ldw	r2,-8(fp)
 4029ce0:	10ffe916 	blt	r2,r3,4029c88 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }
    
    (*flash->write_command)(flash->dev.base_addr, 
 4029ce4:	e0bfff17 	ldw	r2,-4(fp)
 4029ce8:	10c03317 	ldw	r3,204(r2)
 4029cec:	e0bfff17 	ldw	r2,-4(fp)
 4029cf0:	11000a17 	ldw	r4,40(r2)
 4029cf4:	01401544 	movi	r5,85
 4029cf8:	01803fc4 	movi	r6,255
 4029cfc:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_MODE);
  }  

  return ret_code;
 4029d00:	e0bffb17 	ldw	r2,-20(fp)
}
 4029d04:	e037883a 	mov	sp,fp
 4029d08:	dfc00217 	ldw	ra,8(sp)
 4029d0c:	df000117 	ldw	fp,4(sp)
 4029d10:	dc000017 	ldw	r16,0(sp)
 4029d14:	dec00304 	addi	sp,sp,12
 4029d18:	f800283a 	ret

04029d1c <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 4029d1c:	defff704 	addi	sp,sp,-36
 4029d20:	dfc00815 	stw	ra,32(sp)
 4029d24:	df000715 	stw	fp,28(sp)
 4029d28:	df000704 	addi	fp,sp,28
 4029d2c:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 4029d30:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4029d34:	e0bfff17 	ldw	r2,-4(fp)
 4029d38:	11000a17 	ldw	r4,40(r2)
 4029d3c:	01401544 	movi	r5,85
 4029d40:	01802604 	movi	r6,152
 4029d44:	40292280 	call	4029228 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 4029d48:	e03ffb15 	stw	zero,-20(fp)
 4029d4c:	00000f06 	br	4029d8c <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 4029d50:	e13ffb17 	ldw	r4,-20(fp)
 4029d54:	e0bfff17 	ldw	r2,-4(fp)
 4029d58:	10800a17 	ldw	r2,40(r2)
 4029d5c:	1007883a 	mov	r3,r2
 4029d60:	e0bffb17 	ldw	r2,-20(fp)
 4029d64:	1885883a 	add	r2,r3,r2
 4029d68:	10800404 	addi	r2,r2,16
 4029d6c:	10800023 	ldbuio	r2,0(r2)
 4029d70:	1007883a 	mov	r3,r2
 4029d74:	e0bffc04 	addi	r2,fp,-16
 4029d78:	1105883a 	add	r2,r2,r4
 4029d7c:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 4029d80:	e0bffb17 	ldw	r2,-20(fp)
 4029d84:	10800044 	addi	r2,r2,1
 4029d88:	e0bffb15 	stw	r2,-20(fp)
 4029d8c:	e0bffb17 	ldw	r2,-20(fp)
 4029d90:	108000d0 	cmplti	r2,r2,3
 4029d94:	103fee1e 	bne	r2,zero,4029d50 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 4029d98:	e0bffc03 	ldbu	r2,-16(fp)
 4029d9c:	10803fcc 	andi	r2,r2,255
 4029da0:	10801458 	cmpnei	r2,r2,81
 4029da4:	10001d1e 	bne	r2,zero,4029e1c <alt_read_cfi_width+0x100>
 4029da8:	e0bffc43 	ldbu	r2,-15(fp)
 4029dac:	10803fcc 	andi	r2,r2,255
 4029db0:	10801498 	cmpnei	r2,r2,82
 4029db4:	1000191e 	bne	r2,zero,4029e1c <alt_read_cfi_width+0x100>
 4029db8:	e0bffc83 	ldbu	r2,-14(fp)
 4029dbc:	10803fcc 	andi	r2,r2,255
 4029dc0:	10801658 	cmpnei	r2,r2,89
 4029dc4:	1000151e 	bne	r2,zero,4029e1c <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 4029dc8:	e0ffff17 	ldw	r3,-4(fp)
 4029dcc:	00800044 	movi	r2,1
 4029dd0:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 4029dd4:	e0ffff17 	ldw	r3,-4(fp)
 4029dd8:	00800044 	movi	r2,1
 4029ddc:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 4029de0:	e0bfff17 	ldw	r2,-4(fp)
 4029de4:	10800a17 	ldw	r2,40(r2)
 4029de8:	10800a04 	addi	r2,r2,40
 4029dec:	1080002b 	ldhuio	r2,0(r2)
 4029df0:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 4029df4:	e0bffa0b 	ldhu	r2,-24(fp)
 4029df8:	10800044 	addi	r2,r2,1
 4029dfc:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 4029e00:	e0bffa0b 	ldhu	r2,-24(fp)
 4029e04:	1080004c 	andi	r2,r2,1
 4029e08:	1004c03a 	cmpne	r2,r2,zero
 4029e0c:	1001a81e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 4029e10:	00bffb44 	movi	r2,-19
 4029e14:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 4029e18:	0001a506 	br	402a4b0 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4029e1c:	e0bfff17 	ldw	r2,-4(fp)
 4029e20:	11000a17 	ldw	r4,40(r2)
 4029e24:	01401544 	movi	r5,85
 4029e28:	01802604 	movi	r6,152
 4029e2c:	40292640 	call	4029264 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 4029e30:	e03ffb15 	stw	zero,-20(fp)
 4029e34:	00000f06 	br	4029e74 <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 4029e38:	e13ffb17 	ldw	r4,-20(fp)
 4029e3c:	e0bfff17 	ldw	r2,-4(fp)
 4029e40:	10800a17 	ldw	r2,40(r2)
 4029e44:	1007883a 	mov	r3,r2
 4029e48:	e0bffb17 	ldw	r2,-20(fp)
 4029e4c:	1885883a 	add	r2,r3,r2
 4029e50:	10800804 	addi	r2,r2,32
 4029e54:	10800023 	ldbuio	r2,0(r2)
 4029e58:	1007883a 	mov	r3,r2
 4029e5c:	e0bffc04 	addi	r2,fp,-16
 4029e60:	1105883a 	add	r2,r2,r4
 4029e64:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 4029e68:	e0bffb17 	ldw	r2,-20(fp)
 4029e6c:	10800044 	addi	r2,r2,1
 4029e70:	e0bffb15 	stw	r2,-20(fp)
 4029e74:	e0bffb17 	ldw	r2,-20(fp)
 4029e78:	10800190 	cmplti	r2,r2,6
 4029e7c:	103fee1e 	bne	r2,zero,4029e38 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 4029e80:	e0bffc03 	ldbu	r2,-16(fp)
 4029e84:	10803fcc 	andi	r2,r2,255
 4029e88:	10801458 	cmpnei	r2,r2,81
 4029e8c:	1000291e 	bne	r2,zero,4029f34 <alt_read_cfi_width+0x218>
 4029e90:	e0bffc43 	ldbu	r2,-15(fp)
 4029e94:	10803fcc 	andi	r2,r2,255
 4029e98:	10801458 	cmpnei	r2,r2,81
 4029e9c:	1000251e 	bne	r2,zero,4029f34 <alt_read_cfi_width+0x218>
 4029ea0:	e0bffc83 	ldbu	r2,-14(fp)
 4029ea4:	10803fcc 	andi	r2,r2,255
 4029ea8:	10801498 	cmpnei	r2,r2,82
 4029eac:	1000211e 	bne	r2,zero,4029f34 <alt_read_cfi_width+0x218>
 4029eb0:	e0bffcc3 	ldbu	r2,-13(fp)
 4029eb4:	10803fcc 	andi	r2,r2,255
 4029eb8:	10801498 	cmpnei	r2,r2,82
 4029ebc:	10001d1e 	bne	r2,zero,4029f34 <alt_read_cfi_width+0x218>
 4029ec0:	e0bffd03 	ldbu	r2,-12(fp)
 4029ec4:	10803fcc 	andi	r2,r2,255
 4029ec8:	10801658 	cmpnei	r2,r2,89
 4029ecc:	1000191e 	bne	r2,zero,4029f34 <alt_read_cfi_width+0x218>
 4029ed0:	e0bffd43 	ldbu	r2,-11(fp)
 4029ed4:	10803fcc 	andi	r2,r2,255
 4029ed8:	10801658 	cmpnei	r2,r2,89
 4029edc:	1000151e 	bne	r2,zero,4029f34 <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 4029ee0:	e0ffff17 	ldw	r3,-4(fp)
 4029ee4:	00800044 	movi	r2,1
 4029ee8:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 4029eec:	e0ffff17 	ldw	r3,-4(fp)
 4029ef0:	00800084 	movi	r2,2
 4029ef4:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 4029ef8:	e0bfff17 	ldw	r2,-4(fp)
 4029efc:	10800a17 	ldw	r2,40(r2)
 4029f00:	10801404 	addi	r2,r2,80
 4029f04:	1080002b 	ldhuio	r2,0(r2)
 4029f08:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 4029f0c:	e0bffa0b 	ldhu	r2,-24(fp)
 4029f10:	10800044 	addi	r2,r2,1
 4029f14:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 4029f18:	e0bffa0b 	ldhu	r2,-24(fp)
 4029f1c:	1080004c 	andi	r2,r2,1
 4029f20:	1004c03a 	cmpne	r2,r2,zero
 4029f24:	1001621e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 4029f28:	00bffb44 	movi	r2,-19
 4029f2c:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 4029f30:	00015f06 	br	402a4b0 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 4029f34:	e0bfff17 	ldw	r2,-4(fp)
 4029f38:	11000a17 	ldw	r4,40(r2)
 4029f3c:	01401544 	movi	r5,85
 4029f40:	01802604 	movi	r6,152
 4029f44:	40293280 	call	4029328 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 4029f48:	e03ffb15 	stw	zero,-20(fp)
 4029f4c:	00000f06 	br	4029f8c <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 4029f50:	e13ffb17 	ldw	r4,-20(fp)
 4029f54:	e0bfff17 	ldw	r2,-4(fp)
 4029f58:	10800a17 	ldw	r2,40(r2)
 4029f5c:	1007883a 	mov	r3,r2
 4029f60:	e0bffb17 	ldw	r2,-20(fp)
 4029f64:	1885883a 	add	r2,r3,r2
 4029f68:	10800804 	addi	r2,r2,32
 4029f6c:	10800023 	ldbuio	r2,0(r2)
 4029f70:	1007883a 	mov	r3,r2
 4029f74:	e0bffc04 	addi	r2,fp,-16
 4029f78:	1105883a 	add	r2,r2,r4
 4029f7c:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 4029f80:	e0bffb17 	ldw	r2,-20(fp)
 4029f84:	10800044 	addi	r2,r2,1
 4029f88:	e0bffb15 	stw	r2,-20(fp)
 4029f8c:	e0bffb17 	ldw	r2,-20(fp)
 4029f90:	10800190 	cmplti	r2,r2,6
 4029f94:	103fee1e 	bne	r2,zero,4029f50 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 4029f98:	e0bffc03 	ldbu	r2,-16(fp)
 4029f9c:	10803fcc 	andi	r2,r2,255
 4029fa0:	10801458 	cmpnei	r2,r2,81
 4029fa4:	1000291e 	bne	r2,zero,402a04c <alt_read_cfi_width+0x330>
 4029fa8:	e0bffc43 	ldbu	r2,-15(fp)
 4029fac:	10803fcc 	andi	r2,r2,255
 4029fb0:	1004c03a 	cmpne	r2,r2,zero
 4029fb4:	1000251e 	bne	r2,zero,402a04c <alt_read_cfi_width+0x330>
 4029fb8:	e0bffc83 	ldbu	r2,-14(fp)
 4029fbc:	10803fcc 	andi	r2,r2,255
 4029fc0:	10801498 	cmpnei	r2,r2,82
 4029fc4:	1000211e 	bne	r2,zero,402a04c <alt_read_cfi_width+0x330>
 4029fc8:	e0bffcc3 	ldbu	r2,-13(fp)
 4029fcc:	10803fcc 	andi	r2,r2,255
 4029fd0:	1004c03a 	cmpne	r2,r2,zero
 4029fd4:	10001d1e 	bne	r2,zero,402a04c <alt_read_cfi_width+0x330>
 4029fd8:	e0bffd03 	ldbu	r2,-12(fp)
 4029fdc:	10803fcc 	andi	r2,r2,255
 4029fe0:	10801658 	cmpnei	r2,r2,89
 4029fe4:	1000191e 	bne	r2,zero,402a04c <alt_read_cfi_width+0x330>
 4029fe8:	e0bffd43 	ldbu	r2,-11(fp)
 4029fec:	10803fcc 	andi	r2,r2,255
 4029ff0:	1004c03a 	cmpne	r2,r2,zero
 4029ff4:	1000151e 	bne	r2,zero,402a04c <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 4029ff8:	e0ffff17 	ldw	r3,-4(fp)
 4029ffc:	00800084 	movi	r2,2
 402a000:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 402a004:	e0ffff17 	ldw	r3,-4(fp)
 402a008:	00800084 	movi	r2,2
 402a00c:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 402a010:	e0bfff17 	ldw	r2,-4(fp)
 402a014:	10800a17 	ldw	r2,40(r2)
 402a018:	10801404 	addi	r2,r2,80
 402a01c:	1080002b 	ldhuio	r2,0(r2)
 402a020:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 402a024:	e0bffa0b 	ldhu	r2,-24(fp)
 402a028:	10800044 	addi	r2,r2,1
 402a02c:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 402a030:	e0bffa0b 	ldhu	r2,-24(fp)
 402a034:	1080008c 	andi	r2,r2,2
 402a038:	1004c03a 	cmpne	r2,r2,zero
 402a03c:	10011c1e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 402a040:	00bffb44 	movi	r2,-19
 402a044:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 402a048:	00011906 	br	402a4b0 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 402a04c:	e0bfff17 	ldw	r2,-4(fp)
 402a050:	11000a17 	ldw	r4,40(r2)
 402a054:	01401544 	movi	r5,85
 402a058:	01802604 	movi	r6,152
 402a05c:	40293b40 	call	40293b4 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 402a060:	e03ffb15 	stw	zero,-20(fp)
 402a064:	00000f06 	br	402a0a4 <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 402a068:	e13ffb17 	ldw	r4,-20(fp)
 402a06c:	e0bfff17 	ldw	r2,-4(fp)
 402a070:	10800a17 	ldw	r2,40(r2)
 402a074:	1007883a 	mov	r3,r2
 402a078:	e0bffb17 	ldw	r2,-20(fp)
 402a07c:	1885883a 	add	r2,r3,r2
 402a080:	10801004 	addi	r2,r2,64
 402a084:	10800023 	ldbuio	r2,0(r2)
 402a088:	1007883a 	mov	r3,r2
 402a08c:	e0bffc04 	addi	r2,fp,-16
 402a090:	1105883a 	add	r2,r2,r4
 402a094:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 402a098:	e0bffb17 	ldw	r2,-20(fp)
 402a09c:	10800044 	addi	r2,r2,1
 402a0a0:	e0bffb15 	stw	r2,-20(fp)
 402a0a4:	e0bffb17 	ldw	r2,-20(fp)
 402a0a8:	10800310 	cmplti	r2,r2,12
 402a0ac:	103fee1e 	bne	r2,zero,402a068 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 402a0b0:	e0bffc03 	ldbu	r2,-16(fp)
 402a0b4:	10803fcc 	andi	r2,r2,255
 402a0b8:	10801458 	cmpnei	r2,r2,81
 402a0bc:	1000411e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a0c0:	e0bffc43 	ldbu	r2,-15(fp)
 402a0c4:	10803fcc 	andi	r2,r2,255
 402a0c8:	1004c03a 	cmpne	r2,r2,zero
 402a0cc:	10003d1e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a0d0:	e0bffc83 	ldbu	r2,-14(fp)
 402a0d4:	10803fcc 	andi	r2,r2,255
 402a0d8:	1004c03a 	cmpne	r2,r2,zero
 402a0dc:	1000391e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a0e0:	e0bffcc3 	ldbu	r2,-13(fp)
 402a0e4:	10803fcc 	andi	r2,r2,255
 402a0e8:	1004c03a 	cmpne	r2,r2,zero
 402a0ec:	1000351e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a0f0:	e0bffd03 	ldbu	r2,-12(fp)
 402a0f4:	10803fcc 	andi	r2,r2,255
 402a0f8:	10801498 	cmpnei	r2,r2,82
 402a0fc:	1000311e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a100:	e0bffd43 	ldbu	r2,-11(fp)
 402a104:	10803fcc 	andi	r2,r2,255
 402a108:	1004c03a 	cmpne	r2,r2,zero
 402a10c:	10002d1e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a110:	e0bffd83 	ldbu	r2,-10(fp)
 402a114:	10803fcc 	andi	r2,r2,255
 402a118:	1004c03a 	cmpne	r2,r2,zero
 402a11c:	1000291e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a120:	e0bffdc3 	ldbu	r2,-9(fp)
 402a124:	10803fcc 	andi	r2,r2,255
 402a128:	1004c03a 	cmpne	r2,r2,zero
 402a12c:	1000251e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a130:	e0bffe03 	ldbu	r2,-8(fp)
 402a134:	10803fcc 	andi	r2,r2,255
 402a138:	10801658 	cmpnei	r2,r2,89
 402a13c:	1000211e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a140:	e0bffe43 	ldbu	r2,-7(fp)
 402a144:	10803fcc 	andi	r2,r2,255
 402a148:	1004c03a 	cmpne	r2,r2,zero
 402a14c:	10001d1e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a150:	e0bffe83 	ldbu	r2,-6(fp)
 402a154:	10803fcc 	andi	r2,r2,255
 402a158:	1004c03a 	cmpne	r2,r2,zero
 402a15c:	1000191e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
 402a160:	e0bffec3 	ldbu	r2,-5(fp)
 402a164:	10803fcc 	andi	r2,r2,255
 402a168:	1004c03a 	cmpne	r2,r2,zero
 402a16c:	1000151e 	bne	r2,zero,402a1c4 <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 402a170:	e0ffff17 	ldw	r3,-4(fp)
 402a174:	00800104 	movi	r2,4
 402a178:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 402a17c:	e0ffff17 	ldw	r3,-4(fp)
 402a180:	00800104 	movi	r2,4
 402a184:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 402a188:	e0bfff17 	ldw	r2,-4(fp)
 402a18c:	10800a17 	ldw	r2,40(r2)
 402a190:	10802804 	addi	r2,r2,160
 402a194:	10800037 	ldwio	r2,0(r2)
 402a198:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 402a19c:	e0bffa0b 	ldhu	r2,-24(fp)
 402a1a0:	10800044 	addi	r2,r2,1
 402a1a4:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 402a1a8:	e0bffa0b 	ldhu	r2,-24(fp)
 402a1ac:	1080010c 	andi	r2,r2,4
 402a1b0:	1004c03a 	cmpne	r2,r2,zero
 402a1b4:	1000be1e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 402a1b8:	00bffb44 	movi	r2,-19
 402a1bc:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 402a1c0:	0000bb06 	br	402a4b0 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 402a1c4:	e0bfff17 	ldw	r2,-4(fp)
 402a1c8:	11000a17 	ldw	r4,40(r2)
 402a1cc:	01401544 	movi	r5,85
 402a1d0:	01802604 	movi	r6,152
 402a1d4:	402936c0 	call	402936c <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 402a1d8:	e03ffb15 	stw	zero,-20(fp)
 402a1dc:	00000f06 	br	402a21c <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 402a1e0:	e13ffb17 	ldw	r4,-20(fp)
 402a1e4:	e0bfff17 	ldw	r2,-4(fp)
 402a1e8:	10800a17 	ldw	r2,40(r2)
 402a1ec:	1007883a 	mov	r3,r2
 402a1f0:	e0bffb17 	ldw	r2,-20(fp)
 402a1f4:	1885883a 	add	r2,r3,r2
 402a1f8:	10801004 	addi	r2,r2,64
 402a1fc:	10800023 	ldbuio	r2,0(r2)
 402a200:	1007883a 	mov	r3,r2
 402a204:	e0bffc04 	addi	r2,fp,-16
 402a208:	1105883a 	add	r2,r2,r4
 402a20c:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 402a210:	e0bffb17 	ldw	r2,-20(fp)
 402a214:	10800044 	addi	r2,r2,1
 402a218:	e0bffb15 	stw	r2,-20(fp)
 402a21c:	e0bffb17 	ldw	r2,-20(fp)
 402a220:	10800310 	cmplti	r2,r2,12
 402a224:	103fee1e 	bne	r2,zero,402a1e0 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 402a228:	e0bffc03 	ldbu	r2,-16(fp)
 402a22c:	10803fcc 	andi	r2,r2,255
 402a230:	10801458 	cmpnei	r2,r2,81
 402a234:	1000411e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a238:	e0bffc43 	ldbu	r2,-15(fp)
 402a23c:	10803fcc 	andi	r2,r2,255
 402a240:	1004c03a 	cmpne	r2,r2,zero
 402a244:	10003d1e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a248:	e0bffc83 	ldbu	r2,-14(fp)
 402a24c:	10803fcc 	andi	r2,r2,255
 402a250:	10801458 	cmpnei	r2,r2,81
 402a254:	1000391e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a258:	e0bffcc3 	ldbu	r2,-13(fp)
 402a25c:	10803fcc 	andi	r2,r2,255
 402a260:	1004c03a 	cmpne	r2,r2,zero
 402a264:	1000351e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a268:	e0bffd03 	ldbu	r2,-12(fp)
 402a26c:	10803fcc 	andi	r2,r2,255
 402a270:	10801498 	cmpnei	r2,r2,82
 402a274:	1000311e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a278:	e0bffd43 	ldbu	r2,-11(fp)
 402a27c:	10803fcc 	andi	r2,r2,255
 402a280:	1004c03a 	cmpne	r2,r2,zero
 402a284:	10002d1e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a288:	e0bffd83 	ldbu	r2,-10(fp)
 402a28c:	10803fcc 	andi	r2,r2,255
 402a290:	10801498 	cmpnei	r2,r2,82
 402a294:	1000291e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a298:	e0bffdc3 	ldbu	r2,-9(fp)
 402a29c:	10803fcc 	andi	r2,r2,255
 402a2a0:	1004c03a 	cmpne	r2,r2,zero
 402a2a4:	1000251e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a2a8:	e0bffe03 	ldbu	r2,-8(fp)
 402a2ac:	10803fcc 	andi	r2,r2,255
 402a2b0:	10801658 	cmpnei	r2,r2,89
 402a2b4:	1000211e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a2b8:	e0bffe43 	ldbu	r2,-7(fp)
 402a2bc:	10803fcc 	andi	r2,r2,255
 402a2c0:	1004c03a 	cmpne	r2,r2,zero
 402a2c4:	10001d1e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a2c8:	e0bffe83 	ldbu	r2,-6(fp)
 402a2cc:	10803fcc 	andi	r2,r2,255
 402a2d0:	10801658 	cmpnei	r2,r2,89
 402a2d4:	1000191e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
 402a2d8:	e0bffec3 	ldbu	r2,-5(fp)
 402a2dc:	10803fcc 	andi	r2,r2,255
 402a2e0:	1004c03a 	cmpne	r2,r2,zero
 402a2e4:	1000151e 	bne	r2,zero,402a33c <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 402a2e8:	e0ffff17 	ldw	r3,-4(fp)
 402a2ec:	00800084 	movi	r2,2
 402a2f0:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 402a2f4:	e0ffff17 	ldw	r3,-4(fp)
 402a2f8:	00800104 	movi	r2,4
 402a2fc:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 402a300:	e0bfff17 	ldw	r2,-4(fp)
 402a304:	10800a17 	ldw	r2,40(r2)
 402a308:	10802804 	addi	r2,r2,160
 402a30c:	10800037 	ldwio	r2,0(r2)
 402a310:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 402a314:	e0bffa0b 	ldhu	r2,-24(fp)
 402a318:	10800044 	addi	r2,r2,1
 402a31c:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 402a320:	e0bffa0b 	ldhu	r2,-24(fp)
 402a324:	1080010c 	andi	r2,r2,4
 402a328:	1004c03a 	cmpne	r2,r2,zero
 402a32c:	1000601e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 402a330:	00bffb44 	movi	r2,-19
 402a334:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 402a338:	00005d06 	br	402a4b0 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 402a33c:	e0bfff17 	ldw	r2,-4(fp)
 402a340:	11000a17 	ldw	r4,40(r2)
 402a344:	01401544 	movi	r5,85
 402a348:	01802604 	movi	r6,152
 402a34c:	40292e00 	call	40292e0 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 402a350:	e03ffb15 	stw	zero,-20(fp)
 402a354:	00000f06 	br	402a394 <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 402a358:	e13ffb17 	ldw	r4,-20(fp)
 402a35c:	e0bfff17 	ldw	r2,-4(fp)
 402a360:	10800a17 	ldw	r2,40(r2)
 402a364:	1007883a 	mov	r3,r2
 402a368:	e0bffb17 	ldw	r2,-20(fp)
 402a36c:	1885883a 	add	r2,r3,r2
 402a370:	10801004 	addi	r2,r2,64
 402a374:	10800023 	ldbuio	r2,0(r2)
 402a378:	1007883a 	mov	r3,r2
 402a37c:	e0bffc04 	addi	r2,fp,-16
 402a380:	1105883a 	add	r2,r2,r4
 402a384:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 402a388:	e0bffb17 	ldw	r2,-20(fp)
 402a38c:	10800044 	addi	r2,r2,1
 402a390:	e0bffb15 	stw	r2,-20(fp)
 402a394:	e0bffb17 	ldw	r2,-20(fp)
 402a398:	10800310 	cmplti	r2,r2,12
 402a39c:	103fee1e 	bne	r2,zero,402a358 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 402a3a0:	e0bffc03 	ldbu	r2,-16(fp)
 402a3a4:	10803fcc 	andi	r2,r2,255
 402a3a8:	10801458 	cmpnei	r2,r2,81
 402a3ac:	1000401e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a3b0:	e0bffc43 	ldbu	r2,-15(fp)
 402a3b4:	10803fcc 	andi	r2,r2,255
 402a3b8:	10801458 	cmpnei	r2,r2,81
 402a3bc:	10003c1e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a3c0:	e0bffc83 	ldbu	r2,-14(fp)
 402a3c4:	10803fcc 	andi	r2,r2,255
 402a3c8:	10801458 	cmpnei	r2,r2,81
 402a3cc:	1000381e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a3d0:	e0bffcc3 	ldbu	r2,-13(fp)
 402a3d4:	10803fcc 	andi	r2,r2,255
 402a3d8:	10801458 	cmpnei	r2,r2,81
 402a3dc:	1000341e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a3e0:	e0bffd03 	ldbu	r2,-12(fp)
 402a3e4:	10803fcc 	andi	r2,r2,255
 402a3e8:	10801498 	cmpnei	r2,r2,82
 402a3ec:	1000301e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a3f0:	e0bffd43 	ldbu	r2,-11(fp)
 402a3f4:	10803fcc 	andi	r2,r2,255
 402a3f8:	10801498 	cmpnei	r2,r2,82
 402a3fc:	10002c1e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a400:	e0bffd83 	ldbu	r2,-10(fp)
 402a404:	10803fcc 	andi	r2,r2,255
 402a408:	10801498 	cmpnei	r2,r2,82
 402a40c:	1000281e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a410:	e0bffdc3 	ldbu	r2,-9(fp)
 402a414:	10803fcc 	andi	r2,r2,255
 402a418:	10801498 	cmpnei	r2,r2,82
 402a41c:	1000241e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a420:	e0bffe03 	ldbu	r2,-8(fp)
 402a424:	10803fcc 	andi	r2,r2,255
 402a428:	10801658 	cmpnei	r2,r2,89
 402a42c:	1000201e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a430:	e0bffe43 	ldbu	r2,-7(fp)
 402a434:	10803fcc 	andi	r2,r2,255
 402a438:	10801658 	cmpnei	r2,r2,89
 402a43c:	10001c1e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a440:	e0bffe83 	ldbu	r2,-6(fp)
 402a444:	10803fcc 	andi	r2,r2,255
 402a448:	10801658 	cmpnei	r2,r2,89
 402a44c:	1000181e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
 402a450:	e0bffec3 	ldbu	r2,-5(fp)
 402a454:	10803fcc 	andi	r2,r2,255
 402a458:	10801658 	cmpnei	r2,r2,89
 402a45c:	1000141e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 402a460:	e0ffff17 	ldw	r3,-4(fp)
 402a464:	00800044 	movi	r2,1
 402a468:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 402a46c:	e0ffff17 	ldw	r3,-4(fp)
 402a470:	00800104 	movi	r2,4
 402a474:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 402a478:	e0bfff17 	ldw	r2,-4(fp)
 402a47c:	10800a17 	ldw	r2,40(r2)
 402a480:	10802804 	addi	r2,r2,160
 402a484:	10800037 	ldwio	r2,0(r2)
 402a488:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 402a48c:	e0bffa0b 	ldhu	r2,-24(fp)
 402a490:	10800044 	addi	r2,r2,1
 402a494:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 402a498:	e0bffa0b 	ldhu	r2,-24(fp)
 402a49c:	1080010c 	andi	r2,r2,4
 402a4a0:	1004c03a 	cmpne	r2,r2,zero
 402a4a4:	1000021e 	bne	r2,zero,402a4b0 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 402a4a8:	00bffb44 	movi	r2,-19
 402a4ac:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 402a4b0:	e0bff917 	ldw	r2,-28(fp)
}
 402a4b4:	e037883a 	mov	sp,fp
 402a4b8:	dfc00117 	ldw	ra,4(sp)
 402a4bc:	df000017 	ldw	fp,0(sp)
 402a4c0:	dec00204 	addi	sp,sp,8
 402a4c4:	f800283a 	ret

0402a4c8 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 402a4c8:	defff904 	addi	sp,sp,-28
 402a4cc:	dfc00615 	stw	ra,24(sp)
 402a4d0:	df000515 	stw	fp,20(sp)
 402a4d4:	dc000415 	stw	r16,16(sp)
 402a4d8:	df000404 	addi	fp,sp,16
 402a4dc:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 402a4e0:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 402a4e4:	e13fff17 	ldw	r4,-4(fp)
 402a4e8:	01400544 	movi	r5,21
 402a4ec:	40297200 	call	4029720 <alt_read_16bit_query_entry>
 402a4f0:	10ffffcc 	andi	r3,r2,65535
 402a4f4:	e0bfff17 	ldw	r2,-4(fp)
 402a4f8:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 402a4fc:	e03ffd15 	stw	zero,-12(fp)
 402a500:	00001006 	br	402a544 <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 402a504:	e43ffd17 	ldw	r16,-12(fp)
 402a508:	e0bfff17 	ldw	r2,-4(fp)
 402a50c:	11803417 	ldw	r6,208(r2)
 402a510:	e0bfff17 	ldw	r2,-4(fp)
 402a514:	10c03217 	ldw	r3,200(r2)
 402a518:	e0bffd17 	ldw	r2,-12(fp)
 402a51c:	188b883a 	add	r5,r3,r2
 402a520:	e13fff17 	ldw	r4,-4(fp)
 402a524:	303ee83a 	callr	r6
 402a528:	1007883a 	mov	r3,r2
 402a52c:	e0bffe04 	addi	r2,fp,-8
 402a530:	1405883a 	add	r2,r2,r16
 402a534:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 402a538:	e0bffd17 	ldw	r2,-12(fp)
 402a53c:	10800044 	addi	r2,r2,1
 402a540:	e0bffd15 	stw	r2,-12(fp)
 402a544:	e0bffd17 	ldw	r2,-12(fp)
 402a548:	108000d0 	cmplti	r2,r2,3
 402a54c:	103fed1e 	bne	r2,zero,402a504 <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 402a550:	e0bffe03 	ldbu	r2,-8(fp)
 402a554:	10803fcc 	andi	r2,r2,255
 402a558:	10801418 	cmpnei	r2,r2,80
 402a55c:	1000081e 	bne	r2,zero,402a580 <alt_check_primary_table+0xb8>
 402a560:	e0bffe43 	ldbu	r2,-7(fp)
 402a564:	10803fcc 	andi	r2,r2,255
 402a568:	10801498 	cmpnei	r2,r2,82
 402a56c:	1000041e 	bne	r2,zero,402a580 <alt_check_primary_table+0xb8>
 402a570:	e0bffe83 	ldbu	r2,-6(fp)
 402a574:	10803fcc 	andi	r2,r2,255
 402a578:	10801260 	cmpeqi	r2,r2,73
 402a57c:	1000021e 	bne	r2,zero,402a588 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 402a580:	00bffb44 	movi	r2,-19
 402a584:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 402a588:	e0bffc17 	ldw	r2,-16(fp)
}
 402a58c:	e037883a 	mov	sp,fp
 402a590:	dfc00217 	ldw	ra,8(sp)
 402a594:	df000117 	ldw	fp,4(sp)
 402a598:	dc000017 	ldw	r16,0(sp)
 402a59c:	dec00304 	addi	sp,sp,12
 402a5a0:	f800283a 	ret

0402a5a4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 402a5a4:	defffa04 	addi	sp,sp,-24
 402a5a8:	dfc00515 	stw	ra,20(sp)
 402a5ac:	df000415 	stw	fp,16(sp)
 402a5b0:	df000404 	addi	fp,sp,16
 402a5b4:	e13ffd15 	stw	r4,-12(fp)
 402a5b8:	e17ffe15 	stw	r5,-8(fp)
 402a5bc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 402a5c0:	e0bffd17 	ldw	r2,-12(fp)
 402a5c4:	10800017 	ldw	r2,0(r2)
 402a5c8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 402a5cc:	e0bffc17 	ldw	r2,-16(fp)
 402a5d0:	11000a04 	addi	r4,r2,40
 402a5d4:	e0bffd17 	ldw	r2,-12(fp)
 402a5d8:	11c00217 	ldw	r7,8(r2)
 402a5dc:	e17ffe17 	ldw	r5,-8(fp)
 402a5e0:	e1bfff17 	ldw	r6,-4(fp)
 402a5e4:	402abec0 	call	402abec <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 402a5e8:	e037883a 	mov	sp,fp
 402a5ec:	dfc00117 	ldw	ra,4(sp)
 402a5f0:	df000017 	ldw	fp,0(sp)
 402a5f4:	dec00204 	addi	sp,sp,8
 402a5f8:	f800283a 	ret

0402a5fc <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 402a5fc:	defffa04 	addi	sp,sp,-24
 402a600:	dfc00515 	stw	ra,20(sp)
 402a604:	df000415 	stw	fp,16(sp)
 402a608:	df000404 	addi	fp,sp,16
 402a60c:	e13ffd15 	stw	r4,-12(fp)
 402a610:	e17ffe15 	stw	r5,-8(fp)
 402a614:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 402a618:	e0bffd17 	ldw	r2,-12(fp)
 402a61c:	10800017 	ldw	r2,0(r2)
 402a620:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 402a624:	e0bffc17 	ldw	r2,-16(fp)
 402a628:	11000a04 	addi	r4,r2,40
 402a62c:	e0bffd17 	ldw	r2,-12(fp)
 402a630:	11c00217 	ldw	r7,8(r2)
 402a634:	e17ffe17 	ldw	r5,-8(fp)
 402a638:	e1bfff17 	ldw	r6,-4(fp)
 402a63c:	402ae100 	call	402ae10 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 402a640:	e037883a 	mov	sp,fp
 402a644:	dfc00117 	ldw	ra,4(sp)
 402a648:	df000017 	ldw	fp,0(sp)
 402a64c:	dec00204 	addi	sp,sp,8
 402a650:	f800283a 	ret

0402a654 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 402a654:	defffc04 	addi	sp,sp,-16
 402a658:	dfc00315 	stw	ra,12(sp)
 402a65c:	df000215 	stw	fp,8(sp)
 402a660:	df000204 	addi	fp,sp,8
 402a664:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 402a668:	e0bfff17 	ldw	r2,-4(fp)
 402a66c:	10800017 	ldw	r2,0(r2)
 402a670:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 402a674:	e0bffe17 	ldw	r2,-8(fp)
 402a678:	11000a04 	addi	r4,r2,40
 402a67c:	e0bfff17 	ldw	r2,-4(fp)
 402a680:	11400217 	ldw	r5,8(r2)
 402a684:	402aa840 	call	402aa84 <altera_avalon_jtag_uart_close>
}
 402a688:	e037883a 	mov	sp,fp
 402a68c:	dfc00117 	ldw	ra,4(sp)
 402a690:	df000017 	ldw	fp,0(sp)
 402a694:	dec00204 	addi	sp,sp,8
 402a698:	f800283a 	ret

0402a69c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 402a69c:	defffa04 	addi	sp,sp,-24
 402a6a0:	dfc00515 	stw	ra,20(sp)
 402a6a4:	df000415 	stw	fp,16(sp)
 402a6a8:	df000404 	addi	fp,sp,16
 402a6ac:	e13ffd15 	stw	r4,-12(fp)
 402a6b0:	e17ffe15 	stw	r5,-8(fp)
 402a6b4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 402a6b8:	e0bffd17 	ldw	r2,-12(fp)
 402a6bc:	10800017 	ldw	r2,0(r2)
 402a6c0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 402a6c4:	e0bffc17 	ldw	r2,-16(fp)
 402a6c8:	11000a04 	addi	r4,r2,40
 402a6cc:	e17ffe17 	ldw	r5,-8(fp)
 402a6d0:	e1bfff17 	ldw	r6,-4(fp)
 402a6d4:	402aaf80 	call	402aaf8 <altera_avalon_jtag_uart_ioctl>
}
 402a6d8:	e037883a 	mov	sp,fp
 402a6dc:	dfc00117 	ldw	ra,4(sp)
 402a6e0:	df000017 	ldw	fp,0(sp)
 402a6e4:	dec00204 	addi	sp,sp,8
 402a6e8:	f800283a 	ret

0402a6ec <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 402a6ec:	defffa04 	addi	sp,sp,-24
 402a6f0:	dfc00515 	stw	ra,20(sp)
 402a6f4:	df000415 	stw	fp,16(sp)
 402a6f8:	df000404 	addi	fp,sp,16
 402a6fc:	e13ffd15 	stw	r4,-12(fp)
 402a700:	e17ffe15 	stw	r5,-8(fp)
 402a704:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 402a708:	e0fffd17 	ldw	r3,-12(fp)
 402a70c:	00800044 	movi	r2,1
 402a710:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 402a714:	e0bffd17 	ldw	r2,-12(fp)
 402a718:	10800017 	ldw	r2,0(r2)
 402a71c:	11000104 	addi	r4,r2,4
 402a720:	e0bffd17 	ldw	r2,-12(fp)
 402a724:	10800817 	ldw	r2,32(r2)
 402a728:	1007883a 	mov	r3,r2
 402a72c:	2005883a 	mov	r2,r4
 402a730:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 402a734:	e13ffe17 	ldw	r4,-8(fp)
 402a738:	e17fff17 	ldw	r5,-4(fp)
 402a73c:	d8000015 	stw	zero,0(sp)
 402a740:	018100f4 	movhi	r6,1027
 402a744:	31a9eb04 	addi	r6,r6,-22612
 402a748:	e1fffd17 	ldw	r7,-12(fp)
 402a74c:	402bbac0 	call	402bbac <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 402a750:	e0bffd17 	ldw	r2,-12(fp)
 402a754:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 402a758:	e0bffd17 	ldw	r2,-12(fp)
 402a75c:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 402a760:	008100f4 	movhi	r2,1027
 402a764:	10842904 	addi	r2,r2,4260
 402a768:	10800017 	ldw	r2,0(r2)
 402a76c:	100b883a 	mov	r5,r2
 402a770:	018100f4 	movhi	r6,1027
 402a774:	31aa7504 	addi	r6,r6,-22060
 402a778:	e1fffd17 	ldw	r7,-12(fp)
 402a77c:	402b4f00 	call	402b4f0 <alt_alarm_start>
 402a780:	1004403a 	cmpge	r2,r2,zero
 402a784:	1000041e 	bne	r2,zero,402a798 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 402a788:	e0fffd17 	ldw	r3,-12(fp)
 402a78c:	00a00034 	movhi	r2,32768
 402a790:	10bfffc4 	addi	r2,r2,-1
 402a794:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 402a798:	e037883a 	mov	sp,fp
 402a79c:	dfc00117 	ldw	ra,4(sp)
 402a7a0:	df000017 	ldw	fp,0(sp)
 402a7a4:	dec00204 	addi	sp,sp,8
 402a7a8:	f800283a 	ret

0402a7ac <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 402a7ac:	defff804 	addi	sp,sp,-32
 402a7b0:	df000715 	stw	fp,28(sp)
 402a7b4:	df000704 	addi	fp,sp,28
 402a7b8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 402a7bc:	e0bfff17 	ldw	r2,-4(fp)
 402a7c0:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
 402a7c4:	e0bffe17 	ldw	r2,-8(fp)
 402a7c8:	10800017 	ldw	r2,0(r2)
 402a7cc:	e0bffd15 	stw	r2,-12(fp)
 402a7d0:	00000006 	br	402a7d4 <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 402a7d4:	e0bffd17 	ldw	r2,-12(fp)
 402a7d8:	10800104 	addi	r2,r2,4
 402a7dc:	10800037 	ldwio	r2,0(r2)
 402a7e0:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 402a7e4:	e0bffc17 	ldw	r2,-16(fp)
 402a7e8:	1080c00c 	andi	r2,r2,768
 402a7ec:	1005003a 	cmpeq	r2,r2,zero
 402a7f0:	1000741e 	bne	r2,zero,402a9c4 <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 402a7f4:	e0bffc17 	ldw	r2,-16(fp)
 402a7f8:	1080400c 	andi	r2,r2,256
 402a7fc:	1005003a 	cmpeq	r2,r2,zero
 402a800:	1000351e 	bne	r2,zero,402a8d8 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 402a804:	00800074 	movhi	r2,1
 402a808:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 402a80c:	e0bffe17 	ldw	r2,-8(fp)
 402a810:	10800a17 	ldw	r2,40(r2)
 402a814:	10800044 	addi	r2,r2,1
 402a818:	1081ffcc 	andi	r2,r2,2047
 402a81c:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 402a820:	e0bffe17 	ldw	r2,-8(fp)
 402a824:	10c00b17 	ldw	r3,44(r2)
 402a828:	e0bffa17 	ldw	r2,-24(fp)
 402a82c:	18801626 	beq	r3,r2,402a888 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 402a830:	e0bffd17 	ldw	r2,-12(fp)
 402a834:	10800037 	ldwio	r2,0(r2)
 402a838:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 402a83c:	e0bffb17 	ldw	r2,-20(fp)
 402a840:	10a0000c 	andi	r2,r2,32768
 402a844:	1005003a 	cmpeq	r2,r2,zero
 402a848:	10000f1e 	bne	r2,zero,402a888 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 402a84c:	e0bffe17 	ldw	r2,-8(fp)
 402a850:	10c00a17 	ldw	r3,40(r2)
 402a854:	e0bffb17 	ldw	r2,-20(fp)
 402a858:	1009883a 	mov	r4,r2
 402a85c:	e0bffe17 	ldw	r2,-8(fp)
 402a860:	1885883a 	add	r2,r3,r2
 402a864:	10800e04 	addi	r2,r2,56
 402a868:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 402a86c:	e0bffe17 	ldw	r2,-8(fp)
 402a870:	10800a17 	ldw	r2,40(r2)
 402a874:	10800044 	addi	r2,r2,1
 402a878:	10c1ffcc 	andi	r3,r2,2047
 402a87c:	e0bffe17 	ldw	r2,-8(fp)
 402a880:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 402a884:	003fe106 	br	402a80c <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 402a888:	e0bffb17 	ldw	r2,-20(fp)
 402a88c:	10bfffec 	andhi	r2,r2,65535
 402a890:	1005003a 	cmpeq	r2,r2,zero
 402a894:	1000101e 	bne	r2,zero,402a8d8 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 402a898:	e0bffe17 	ldw	r2,-8(fp)
 402a89c:	10c00817 	ldw	r3,32(r2)
 402a8a0:	00bfff84 	movi	r2,-2
 402a8a4:	1886703a 	and	r3,r3,r2
 402a8a8:	e0bffe17 	ldw	r2,-8(fp)
 402a8ac:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 402a8b0:	e0bffd17 	ldw	r2,-12(fp)
 402a8b4:	11000104 	addi	r4,r2,4
 402a8b8:	e0bffe17 	ldw	r2,-8(fp)
 402a8bc:	10800817 	ldw	r2,32(r2)
 402a8c0:	1007883a 	mov	r3,r2
 402a8c4:	2005883a 	mov	r2,r4
 402a8c8:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 402a8cc:	e0bffd17 	ldw	r2,-12(fp)
 402a8d0:	10800104 	addi	r2,r2,4
 402a8d4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 402a8d8:	e0bffc17 	ldw	r2,-16(fp)
 402a8dc:	1080800c 	andi	r2,r2,512
 402a8e0:	1005003a 	cmpeq	r2,r2,zero
 402a8e4:	103fbb1e 	bne	r2,zero,402a7d4 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 402a8e8:	e0bffc17 	ldw	r2,-16(fp)
 402a8ec:	10bfffec 	andhi	r2,r2,65535
 402a8f0:	1004d43a 	srli	r2,r2,16
 402a8f4:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 402a8f8:	00001506 	br	402a950 <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 402a8fc:	e13ffd17 	ldw	r4,-12(fp)
 402a900:	e0bffe17 	ldw	r2,-8(fp)
 402a904:	10c00d17 	ldw	r3,52(r2)
 402a908:	e0bffe17 	ldw	r2,-8(fp)
 402a90c:	1885883a 	add	r2,r3,r2
 402a910:	10820e04 	addi	r2,r2,2104
 402a914:	10800003 	ldbu	r2,0(r2)
 402a918:	10c03fcc 	andi	r3,r2,255
 402a91c:	18c0201c 	xori	r3,r3,128
 402a920:	18ffe004 	addi	r3,r3,-128
 402a924:	2005883a 	mov	r2,r4
 402a928:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 402a92c:	e0bffe17 	ldw	r2,-8(fp)
 402a930:	10800d17 	ldw	r2,52(r2)
 402a934:	10800044 	addi	r2,r2,1
 402a938:	10c1ffcc 	andi	r3,r2,2047
 402a93c:	e0bffe17 	ldw	r2,-8(fp)
 402a940:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 402a944:	e0bff917 	ldw	r2,-28(fp)
 402a948:	10bfffc4 	addi	r2,r2,-1
 402a94c:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 402a950:	e0bff917 	ldw	r2,-28(fp)
 402a954:	1005003a 	cmpeq	r2,r2,zero
 402a958:	1000051e 	bne	r2,zero,402a970 <altera_avalon_jtag_uart_irq+0x1c4>
 402a95c:	e0bffe17 	ldw	r2,-8(fp)
 402a960:	10c00d17 	ldw	r3,52(r2)
 402a964:	e0bffe17 	ldw	r2,-8(fp)
 402a968:	10800c17 	ldw	r2,48(r2)
 402a96c:	18bfe31e 	bne	r3,r2,402a8fc <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 402a970:	e0bff917 	ldw	r2,-28(fp)
 402a974:	1005003a 	cmpeq	r2,r2,zero
 402a978:	103f961e 	bne	r2,zero,402a7d4 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 402a97c:	e0bffe17 	ldw	r2,-8(fp)
 402a980:	10c00817 	ldw	r3,32(r2)
 402a984:	00bfff44 	movi	r2,-3
 402a988:	1886703a 	and	r3,r3,r2
 402a98c:	e0bffe17 	ldw	r2,-8(fp)
 402a990:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 402a994:	e0bffe17 	ldw	r2,-8(fp)
 402a998:	10800017 	ldw	r2,0(r2)
 402a99c:	11000104 	addi	r4,r2,4
 402a9a0:	e0bffe17 	ldw	r2,-8(fp)
 402a9a4:	10800817 	ldw	r2,32(r2)
 402a9a8:	1007883a 	mov	r3,r2
 402a9ac:	2005883a 	mov	r2,r4
 402a9b0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 402a9b4:	e0bffd17 	ldw	r2,-12(fp)
 402a9b8:	10800104 	addi	r2,r2,4
 402a9bc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 402a9c0:	003f8406 	br	402a7d4 <altera_avalon_jtag_uart_irq+0x28>
}
 402a9c4:	e037883a 	mov	sp,fp
 402a9c8:	df000017 	ldw	fp,0(sp)
 402a9cc:	dec00104 	addi	sp,sp,4
 402a9d0:	f800283a 	ret

0402a9d4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 402a9d4:	defffc04 	addi	sp,sp,-16
 402a9d8:	df000315 	stw	fp,12(sp)
 402a9dc:	df000304 	addi	fp,sp,12
 402a9e0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 402a9e4:	e0bfff17 	ldw	r2,-4(fp)
 402a9e8:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 402a9ec:	e0bffe17 	ldw	r2,-8(fp)
 402a9f0:	10800017 	ldw	r2,0(r2)
 402a9f4:	10800104 	addi	r2,r2,4
 402a9f8:	10800037 	ldwio	r2,0(r2)
 402a9fc:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 402aa00:	e0bffd17 	ldw	r2,-12(fp)
 402aa04:	1081000c 	andi	r2,r2,1024
 402aa08:	1005003a 	cmpeq	r2,r2,zero
 402aa0c:	10000c1e 	bne	r2,zero,402aa40 <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 402aa10:	e0bffe17 	ldw	r2,-8(fp)
 402aa14:	10800017 	ldw	r2,0(r2)
 402aa18:	11000104 	addi	r4,r2,4
 402aa1c:	e0bffe17 	ldw	r2,-8(fp)
 402aa20:	10800817 	ldw	r2,32(r2)
 402aa24:	10810014 	ori	r2,r2,1024
 402aa28:	1007883a 	mov	r3,r2
 402aa2c:	2005883a 	mov	r2,r4
 402aa30:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 402aa34:	e0bffe17 	ldw	r2,-8(fp)
 402aa38:	10000915 	stw	zero,36(r2)
 402aa3c:	00000a06 	br	402aa68 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 402aa40:	e0bffe17 	ldw	r2,-8(fp)
 402aa44:	10c00917 	ldw	r3,36(r2)
 402aa48:	00a00034 	movhi	r2,32768
 402aa4c:	10bfff04 	addi	r2,r2,-4
 402aa50:	10c00536 	bltu	r2,r3,402aa68 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 402aa54:	e0bffe17 	ldw	r2,-8(fp)
 402aa58:	10800917 	ldw	r2,36(r2)
 402aa5c:	10c00044 	addi	r3,r2,1
 402aa60:	e0bffe17 	ldw	r2,-8(fp)
 402aa64:	10c00915 	stw	r3,36(r2)
 402aa68:	008100f4 	movhi	r2,1027
 402aa6c:	10842904 	addi	r2,r2,4260
 402aa70:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 402aa74:	e037883a 	mov	sp,fp
 402aa78:	df000017 	ldw	fp,0(sp)
 402aa7c:	dec00104 	addi	sp,sp,4
 402aa80:	f800283a 	ret

0402aa84 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 402aa84:	defffc04 	addi	sp,sp,-16
 402aa88:	df000315 	stw	fp,12(sp)
 402aa8c:	df000304 	addi	fp,sp,12
 402aa90:	e13ffd15 	stw	r4,-12(fp)
 402aa94:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 402aa98:	00000706 	br	402aab8 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 402aa9c:	e0bffe17 	ldw	r2,-8(fp)
 402aaa0:	1090000c 	andi	r2,r2,16384
 402aaa4:	1005003a 	cmpeq	r2,r2,zero
 402aaa8:	1000031e 	bne	r2,zero,402aab8 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 402aaac:	00bffd44 	movi	r2,-11
 402aab0:	e0bfff15 	stw	r2,-4(fp)
 402aab4:	00000b06 	br	402aae4 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 402aab8:	e0bffd17 	ldw	r2,-12(fp)
 402aabc:	10c00d17 	ldw	r3,52(r2)
 402aac0:	e0bffd17 	ldw	r2,-12(fp)
 402aac4:	10800c17 	ldw	r2,48(r2)
 402aac8:	18800526 	beq	r3,r2,402aae0 <altera_avalon_jtag_uart_close+0x5c>
 402aacc:	e0bffd17 	ldw	r2,-12(fp)
 402aad0:	10c00917 	ldw	r3,36(r2)
 402aad4:	e0bffd17 	ldw	r2,-12(fp)
 402aad8:	10800117 	ldw	r2,4(r2)
 402aadc:	18bfef36 	bltu	r3,r2,402aa9c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 402aae0:	e03fff15 	stw	zero,-4(fp)
 402aae4:	e0bfff17 	ldw	r2,-4(fp)
}
 402aae8:	e037883a 	mov	sp,fp
 402aaec:	df000017 	ldw	fp,0(sp)
 402aaf0:	dec00104 	addi	sp,sp,4
 402aaf4:	f800283a 	ret

0402aaf8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 402aaf8:	defff804 	addi	sp,sp,-32
 402aafc:	df000715 	stw	fp,28(sp)
 402ab00:	df000704 	addi	fp,sp,28
 402ab04:	e13ffb15 	stw	r4,-20(fp)
 402ab08:	e17ffc15 	stw	r5,-16(fp)
 402ab0c:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 402ab10:	00bff9c4 	movi	r2,-25
 402ab14:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 402ab18:	e0bffc17 	ldw	r2,-16(fp)
 402ab1c:	e0bfff15 	stw	r2,-4(fp)
 402ab20:	e0ffff17 	ldw	r3,-4(fp)
 402ab24:	189a8060 	cmpeqi	r2,r3,27137
 402ab28:	1000041e 	bne	r2,zero,402ab3c <altera_avalon_jtag_uart_ioctl+0x44>
 402ab2c:	e0ffff17 	ldw	r3,-4(fp)
 402ab30:	189a80a0 	cmpeqi	r2,r3,27138
 402ab34:	10001b1e 	bne	r2,zero,402aba4 <altera_avalon_jtag_uart_ioctl+0xac>
 402ab38:	00002706 	br	402abd8 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 402ab3c:	e0bffb17 	ldw	r2,-20(fp)
 402ab40:	10c00117 	ldw	r3,4(r2)
 402ab44:	00a00034 	movhi	r2,32768
 402ab48:	10bfffc4 	addi	r2,r2,-1
 402ab4c:	18802226 	beq	r3,r2,402abd8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 402ab50:	e0bffd17 	ldw	r2,-12(fp)
 402ab54:	10800017 	ldw	r2,0(r2)
 402ab58:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 402ab5c:	e0bff917 	ldw	r2,-28(fp)
 402ab60:	10800090 	cmplti	r2,r2,2
 402ab64:	1000071e 	bne	r2,zero,402ab84 <altera_avalon_jtag_uart_ioctl+0x8c>
 402ab68:	e0fff917 	ldw	r3,-28(fp)
 402ab6c:	00a00034 	movhi	r2,32768
 402ab70:	10bfffc4 	addi	r2,r2,-1
 402ab74:	18800326 	beq	r3,r2,402ab84 <altera_avalon_jtag_uart_ioctl+0x8c>
 402ab78:	e0bff917 	ldw	r2,-28(fp)
 402ab7c:	e0bffe15 	stw	r2,-8(fp)
 402ab80:	00000306 	br	402ab90 <altera_avalon_jtag_uart_ioctl+0x98>
 402ab84:	00e00034 	movhi	r3,32768
 402ab88:	18ffff84 	addi	r3,r3,-2
 402ab8c:	e0fffe15 	stw	r3,-8(fp)
 402ab90:	e0bffb17 	ldw	r2,-20(fp)
 402ab94:	e0fffe17 	ldw	r3,-8(fp)
 402ab98:	10c00115 	stw	r3,4(r2)
      rc = 0;
 402ab9c:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 402aba0:	00000d06 	br	402abd8 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 402aba4:	e0bffb17 	ldw	r2,-20(fp)
 402aba8:	10c00117 	ldw	r3,4(r2)
 402abac:	00a00034 	movhi	r2,32768
 402abb0:	10bfffc4 	addi	r2,r2,-1
 402abb4:	18800826 	beq	r3,r2,402abd8 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 402abb8:	e13ffd17 	ldw	r4,-12(fp)
 402abbc:	e0bffb17 	ldw	r2,-20(fp)
 402abc0:	10c00917 	ldw	r3,36(r2)
 402abc4:	e0bffb17 	ldw	r2,-20(fp)
 402abc8:	10800117 	ldw	r2,4(r2)
 402abcc:	1885803a 	cmpltu	r2,r3,r2
 402abd0:	20800015 	stw	r2,0(r4)
      rc = 0;
 402abd4:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 402abd8:	e0bffa17 	ldw	r2,-24(fp)
}
 402abdc:	e037883a 	mov	sp,fp
 402abe0:	df000017 	ldw	fp,0(sp)
 402abe4:	dec00104 	addi	sp,sp,4
 402abe8:	f800283a 	ret

0402abec <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 402abec:	defff204 	addi	sp,sp,-56
 402abf0:	dfc00d15 	stw	ra,52(sp)
 402abf4:	df000c15 	stw	fp,48(sp)
 402abf8:	df000c04 	addi	fp,sp,48
 402abfc:	e13ffb15 	stw	r4,-20(fp)
 402ac00:	e17ffc15 	stw	r5,-16(fp)
 402ac04:	e1bffd15 	stw	r6,-12(fp)
 402ac08:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 402ac0c:	e0bffc17 	ldw	r2,-16(fp)
 402ac10:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 402ac14:	00004806 	br	402ad38 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 402ac18:	e0bffb17 	ldw	r2,-20(fp)
 402ac1c:	10800a17 	ldw	r2,40(r2)
 402ac20:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 402ac24:	e0bffb17 	ldw	r2,-20(fp)
 402ac28:	10800b17 	ldw	r2,44(r2)
 402ac2c:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 402ac30:	e0fff717 	ldw	r3,-36(fp)
 402ac34:	e0bff617 	ldw	r2,-40(fp)
 402ac38:	18800536 	bltu	r3,r2,402ac50 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 402ac3c:	e0bff717 	ldw	r2,-36(fp)
 402ac40:	e0fff617 	ldw	r3,-40(fp)
 402ac44:	10c5c83a 	sub	r2,r2,r3
 402ac48:	e0bff815 	stw	r2,-32(fp)
 402ac4c:	00000406 	br	402ac60 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 402ac50:	00820004 	movi	r2,2048
 402ac54:	e0fff617 	ldw	r3,-40(fp)
 402ac58:	10c5c83a 	sub	r2,r2,r3
 402ac5c:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 402ac60:	e0bff817 	ldw	r2,-32(fp)
 402ac64:	1005003a 	cmpeq	r2,r2,zero
 402ac68:	10001f1e 	bne	r2,zero,402ace8 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
 402ac6c:	e0fffd17 	ldw	r3,-12(fp)
 402ac70:	e0bff817 	ldw	r2,-32(fp)
 402ac74:	1880022e 	bgeu	r3,r2,402ac80 <altera_avalon_jtag_uart_read+0x94>
        n = space;
 402ac78:	e0bffd17 	ldw	r2,-12(fp)
 402ac7c:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 402ac80:	e0bffb17 	ldw	r2,-20(fp)
 402ac84:	10c00e04 	addi	r3,r2,56
 402ac88:	e0bff617 	ldw	r2,-40(fp)
 402ac8c:	1887883a 	add	r3,r3,r2
 402ac90:	e0bffa17 	ldw	r2,-24(fp)
 402ac94:	1009883a 	mov	r4,r2
 402ac98:	180b883a 	mov	r5,r3
 402ac9c:	e1bff817 	ldw	r6,-32(fp)
 402aca0:	40273c80 	call	40273c8 <memcpy>
      ptr   += n;
 402aca4:	e0fff817 	ldw	r3,-32(fp)
 402aca8:	e0bffa17 	ldw	r2,-24(fp)
 402acac:	10c5883a 	add	r2,r2,r3
 402acb0:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
 402acb4:	e0fffd17 	ldw	r3,-12(fp)
 402acb8:	e0bff817 	ldw	r2,-32(fp)
 402acbc:	1885c83a 	sub	r2,r3,r2
 402acc0:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 402acc4:	e0fff617 	ldw	r3,-40(fp)
 402acc8:	e0bff817 	ldw	r2,-32(fp)
 402accc:	1885883a 	add	r2,r3,r2
 402acd0:	10c1ffcc 	andi	r3,r2,2047
 402acd4:	e0bffb17 	ldw	r2,-20(fp)
 402acd8:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 402acdc:	e0bffd17 	ldw	r2,-12(fp)
 402ace0:	10800048 	cmpgei	r2,r2,1
 402ace4:	103fcc1e 	bne	r2,zero,402ac18 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
 402ace8:	e0fffa17 	ldw	r3,-24(fp)
 402acec:	e0bffc17 	ldw	r2,-16(fp)
 402acf0:	1880141e 	bne	r3,r2,402ad44 <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 402acf4:	e0bffe17 	ldw	r2,-8(fp)
 402acf8:	1090000c 	andi	r2,r2,16384
 402acfc:	1004c03a 	cmpne	r2,r2,zero
 402ad00:	1000101e 	bne	r2,zero,402ad44 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 402ad04:	e0bffb17 	ldw	r2,-20(fp)
 402ad08:	10c00a17 	ldw	r3,40(r2)
 402ad0c:	e0bff717 	ldw	r2,-36(fp)
 402ad10:	1880051e 	bne	r3,r2,402ad28 <altera_avalon_jtag_uart_read+0x13c>
 402ad14:	e0bffb17 	ldw	r2,-20(fp)
 402ad18:	10c00917 	ldw	r3,36(r2)
 402ad1c:	e0bffb17 	ldw	r2,-20(fp)
 402ad20:	10800117 	ldw	r2,4(r2)
 402ad24:	18bff736 	bltu	r3,r2,402ad04 <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 402ad28:	e0bffb17 	ldw	r2,-20(fp)
 402ad2c:	10c00a17 	ldw	r3,40(r2)
 402ad30:	e0bff717 	ldw	r2,-36(fp)
 402ad34:	18800326 	beq	r3,r2,402ad44 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 402ad38:	e0bffd17 	ldw	r2,-12(fp)
 402ad3c:	10800048 	cmpgei	r2,r2,1
 402ad40:	103fb51e 	bne	r2,zero,402ac18 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 402ad44:	e0fffa17 	ldw	r3,-24(fp)
 402ad48:	e0bffc17 	ldw	r2,-16(fp)
 402ad4c:	18801926 	beq	r3,r2,402adb4 <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402ad50:	0005303a 	rdctl	r2,status
 402ad54:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402ad58:	e0fff517 	ldw	r3,-44(fp)
 402ad5c:	00bfff84 	movi	r2,-2
 402ad60:	1884703a 	and	r2,r3,r2
 402ad64:	1001703a 	wrctl	status,r2
  
  return context;
 402ad68:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 402ad6c:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 402ad70:	e0bffb17 	ldw	r2,-20(fp)
 402ad74:	10800817 	ldw	r2,32(r2)
 402ad78:	10c00054 	ori	r3,r2,1
 402ad7c:	e0bffb17 	ldw	r2,-20(fp)
 402ad80:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 402ad84:	e0bffb17 	ldw	r2,-20(fp)
 402ad88:	10800017 	ldw	r2,0(r2)
 402ad8c:	11000104 	addi	r4,r2,4
 402ad90:	e0bffb17 	ldw	r2,-20(fp)
 402ad94:	10800817 	ldw	r2,32(r2)
 402ad98:	1007883a 	mov	r3,r2
 402ad9c:	2005883a 	mov	r2,r4
 402ada0:	10c00035 	stwio	r3,0(r2)
 402ada4:	e0bff917 	ldw	r2,-28(fp)
 402ada8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402adac:	e0bff417 	ldw	r2,-48(fp)
 402adb0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 402adb4:	e0fffa17 	ldw	r3,-24(fp)
 402adb8:	e0bffc17 	ldw	r2,-16(fp)
 402adbc:	18800526 	beq	r3,r2,402add4 <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
 402adc0:	e0fffa17 	ldw	r3,-24(fp)
 402adc4:	e0bffc17 	ldw	r2,-16(fp)
 402adc8:	1887c83a 	sub	r3,r3,r2
 402adcc:	e0ffff15 	stw	r3,-4(fp)
 402add0:	00000906 	br	402adf8 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 402add4:	e0bffe17 	ldw	r2,-8(fp)
 402add8:	1090000c 	andi	r2,r2,16384
 402addc:	1005003a 	cmpeq	r2,r2,zero
 402ade0:	1000031e 	bne	r2,zero,402adf0 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 402ade4:	00bffd44 	movi	r2,-11
 402ade8:	e0bfff15 	stw	r2,-4(fp)
 402adec:	00000206 	br	402adf8 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 402adf0:	00bffec4 	movi	r2,-5
 402adf4:	e0bfff15 	stw	r2,-4(fp)
 402adf8:	e0bfff17 	ldw	r2,-4(fp)
}
 402adfc:	e037883a 	mov	sp,fp
 402ae00:	dfc00117 	ldw	ra,4(sp)
 402ae04:	df000017 	ldw	fp,0(sp)
 402ae08:	dec00204 	addi	sp,sp,8
 402ae0c:	f800283a 	ret

0402ae10 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 402ae10:	defff204 	addi	sp,sp,-56
 402ae14:	dfc00d15 	stw	ra,52(sp)
 402ae18:	df000c15 	stw	fp,48(sp)
 402ae1c:	df000c04 	addi	fp,sp,48
 402ae20:	e13ffb15 	stw	r4,-20(fp)
 402ae24:	e17ffc15 	stw	r5,-16(fp)
 402ae28:	e1bffd15 	stw	r6,-12(fp)
 402ae2c:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 402ae30:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 402ae34:	e0bffc17 	ldw	r2,-16(fp)
 402ae38:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 402ae3c:	00003a06 	br	402af28 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 402ae40:	e0bffb17 	ldw	r2,-20(fp)
 402ae44:	10800c17 	ldw	r2,48(r2)
 402ae48:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
 402ae4c:	e0bffb17 	ldw	r2,-20(fp)
 402ae50:	10800d17 	ldw	r2,52(r2)
 402ae54:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
 402ae58:	e0fffa17 	ldw	r3,-24(fp)
 402ae5c:	e0bff917 	ldw	r2,-28(fp)
 402ae60:	1880062e 	bgeu	r3,r2,402ae7c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 402ae64:	e0fff917 	ldw	r3,-28(fp)
 402ae68:	e0bffa17 	ldw	r2,-24(fp)
 402ae6c:	1885c83a 	sub	r2,r3,r2
 402ae70:	10bfffc4 	addi	r2,r2,-1
 402ae74:	e0bff815 	stw	r2,-32(fp)
 402ae78:	00000c06 	br	402aeac <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
 402ae7c:	e0bff917 	ldw	r2,-28(fp)
 402ae80:	1005003a 	cmpeq	r2,r2,zero
 402ae84:	1000051e 	bne	r2,zero,402ae9c <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 402ae88:	00820004 	movi	r2,2048
 402ae8c:	e0fffa17 	ldw	r3,-24(fp)
 402ae90:	10c5c83a 	sub	r2,r2,r3
 402ae94:	e0bff815 	stw	r2,-32(fp)
 402ae98:	00000406 	br	402aeac <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 402ae9c:	0081ffc4 	movi	r2,2047
 402aea0:	e0fffa17 	ldw	r3,-24(fp)
 402aea4:	10c5c83a 	sub	r2,r2,r3
 402aea8:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 402aeac:	e0bff817 	ldw	r2,-32(fp)
 402aeb0:	1005003a 	cmpeq	r2,r2,zero
 402aeb4:	10001f1e 	bne	r2,zero,402af34 <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
 402aeb8:	e0fffd17 	ldw	r3,-12(fp)
 402aebc:	e0bff817 	ldw	r2,-32(fp)
 402aec0:	1880022e 	bgeu	r3,r2,402aecc <altera_avalon_jtag_uart_write+0xbc>
        n = count;
 402aec4:	e0bffd17 	ldw	r2,-12(fp)
 402aec8:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 402aecc:	e0bffb17 	ldw	r2,-20(fp)
 402aed0:	10c20e04 	addi	r3,r2,2104
 402aed4:	e0bffa17 	ldw	r2,-24(fp)
 402aed8:	1885883a 	add	r2,r3,r2
 402aedc:	e0fffc17 	ldw	r3,-16(fp)
 402aee0:	1009883a 	mov	r4,r2
 402aee4:	180b883a 	mov	r5,r3
 402aee8:	e1bff817 	ldw	r6,-32(fp)
 402aeec:	40273c80 	call	40273c8 <memcpy>
      ptr   += n;
 402aef0:	e0fff817 	ldw	r3,-32(fp)
 402aef4:	e0bffc17 	ldw	r2,-16(fp)
 402aef8:	10c5883a 	add	r2,r2,r3
 402aefc:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 402af00:	e0fffd17 	ldw	r3,-12(fp)
 402af04:	e0bff817 	ldw	r2,-32(fp)
 402af08:	1885c83a 	sub	r2,r3,r2
 402af0c:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 402af10:	e0fffa17 	ldw	r3,-24(fp)
 402af14:	e0bff817 	ldw	r2,-32(fp)
 402af18:	1885883a 	add	r2,r3,r2
 402af1c:	10c1ffcc 	andi	r3,r2,2047
 402af20:	e0bffb17 	ldw	r2,-20(fp)
 402af24:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 402af28:	e0bffd17 	ldw	r2,-12(fp)
 402af2c:	10800048 	cmpgei	r2,r2,1
 402af30:	103fc31e 	bne	r2,zero,402ae40 <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402af34:	0005303a 	rdctl	r2,status
 402af38:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402af3c:	e0fff517 	ldw	r3,-44(fp)
 402af40:	00bfff84 	movi	r2,-2
 402af44:	1884703a 	and	r2,r3,r2
 402af48:	1001703a 	wrctl	status,r2
  
  return context;
 402af4c:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 402af50:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 402af54:	e0bffb17 	ldw	r2,-20(fp)
 402af58:	10800817 	ldw	r2,32(r2)
 402af5c:	10c00094 	ori	r3,r2,2
 402af60:	e0bffb17 	ldw	r2,-20(fp)
 402af64:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 402af68:	e0bffb17 	ldw	r2,-20(fp)
 402af6c:	10800017 	ldw	r2,0(r2)
 402af70:	11000104 	addi	r4,r2,4
 402af74:	e0bffb17 	ldw	r2,-20(fp)
 402af78:	10800817 	ldw	r2,32(r2)
 402af7c:	1007883a 	mov	r3,r2
 402af80:	2005883a 	mov	r2,r4
 402af84:	10c00035 	stwio	r3,0(r2)
 402af88:	e0bff717 	ldw	r2,-36(fp)
 402af8c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402af90:	e0bff417 	ldw	r2,-48(fp)
 402af94:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 402af98:	e0bffd17 	ldw	r2,-12(fp)
 402af9c:	10800050 	cmplti	r2,r2,1
 402afa0:	1000111e 	bne	r2,zero,402afe8 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
 402afa4:	e0bffe17 	ldw	r2,-8(fp)
 402afa8:	1090000c 	andi	r2,r2,16384
 402afac:	1004c03a 	cmpne	r2,r2,zero
 402afb0:	1000101e 	bne	r2,zero,402aff4 <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 402afb4:	e0bffb17 	ldw	r2,-20(fp)
 402afb8:	10c00d17 	ldw	r3,52(r2)
 402afbc:	e0bff917 	ldw	r2,-28(fp)
 402afc0:	1880051e 	bne	r3,r2,402afd8 <altera_avalon_jtag_uart_write+0x1c8>
 402afc4:	e0bffb17 	ldw	r2,-20(fp)
 402afc8:	10c00917 	ldw	r3,36(r2)
 402afcc:	e0bffb17 	ldw	r2,-20(fp)
 402afd0:	10800117 	ldw	r2,4(r2)
 402afd4:	18bff736 	bltu	r3,r2,402afb4 <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 402afd8:	e0bffb17 	ldw	r2,-20(fp)
 402afdc:	10c00d17 	ldw	r3,52(r2)
 402afe0:	e0bff917 	ldw	r2,-28(fp)
 402afe4:	18800326 	beq	r3,r2,402aff4 <altera_avalon_jtag_uart_write+0x1e4>
        break;
    }
  }
  while (count > 0);
 402afe8:	e0bffd17 	ldw	r2,-12(fp)
 402afec:	10800048 	cmpgei	r2,r2,1
 402aff0:	103fcd1e 	bne	r2,zero,402af28 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 402aff4:	e0fffc17 	ldw	r3,-16(fp)
 402aff8:	e0bff617 	ldw	r2,-40(fp)
 402affc:	18800526 	beq	r3,r2,402b014 <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
 402b000:	e0fffc17 	ldw	r3,-16(fp)
 402b004:	e0bff617 	ldw	r2,-40(fp)
 402b008:	1887c83a 	sub	r3,r3,r2
 402b00c:	e0ffff15 	stw	r3,-4(fp)
 402b010:	00000906 	br	402b038 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
 402b014:	e0bffe17 	ldw	r2,-8(fp)
 402b018:	1090000c 	andi	r2,r2,16384
 402b01c:	1005003a 	cmpeq	r2,r2,zero
 402b020:	1000031e 	bne	r2,zero,402b030 <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
 402b024:	00bffd44 	movi	r2,-11
 402b028:	e0bfff15 	stw	r2,-4(fp)
 402b02c:	00000206 	br	402b038 <altera_avalon_jtag_uart_write+0x228>
  else
    return -EIO; /* Host not connected */
 402b030:	00bffec4 	movi	r2,-5
 402b034:	e0bfff15 	stw	r2,-4(fp)
 402b038:	e0bfff17 	ldw	r2,-4(fp)
}
 402b03c:	e037883a 	mov	sp,fp
 402b040:	dfc00117 	ldw	ra,4(sp)
 402b044:	df000017 	ldw	fp,0(sp)
 402b048:	dec00204 	addi	sp,sp,8
 402b04c:	f800283a 	ret

0402b050 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 402b050:	defff404 	addi	sp,sp,-48
 402b054:	df000b15 	stw	fp,44(sp)
 402b058:	df000b04 	addi	fp,sp,44
 402b05c:	e13ffc15 	stw	r4,-16(fp)
 402b060:	e17ffd15 	stw	r5,-12(fp)
 402b064:	e1bffe15 	stw	r6,-8(fp)
 402b068:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 402b06c:	e0fffe17 	ldw	r3,-8(fp)
 402b070:	e0bfff17 	ldw	r2,-4(fp)
 402b074:	10c5883a 	add	r2,r2,r3
 402b078:	e0bffb15 	stw	r2,-20(fp)
  alt_u8 * read_end = read_data + read_length;
 402b07c:	e0c00117 	ldw	r3,4(fp)
 402b080:	e0800217 	ldw	r2,8(fp)
 402b084:	10c5883a 	add	r2,r2,r3
 402b088:	e0bffa15 	stw	r2,-24(fp)

  alt_u32 write_zeros = read_length;
 402b08c:	e0800117 	ldw	r2,4(fp)
 402b090:	e0bff915 	stw	r2,-28(fp)
  alt_u32 read_ignore = write_length;
 402b094:	e0bffe17 	ldw	r2,-8(fp)
 402b098:	e0bff815 	stw	r2,-32(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 402b09c:	00800044 	movi	r2,1
 402b0a0:	e0bff615 	stw	r2,-40(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 402b0a4:	e0bffc17 	ldw	r2,-16(fp)
 402b0a8:	11000504 	addi	r4,r2,20
 402b0ac:	e0fffd17 	ldw	r3,-12(fp)
 402b0b0:	00800044 	movi	r2,1
 402b0b4:	10c6983a 	sll	r3,r2,r3
 402b0b8:	2005883a 	mov	r2,r4
 402b0bc:	10c00035 	stwio	r3,0(r2)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 402b0c0:	e0800317 	ldw	r2,12(fp)
 402b0c4:	1080008c 	andi	r2,r2,2
 402b0c8:	1004c03a 	cmpne	r2,r2,zero
 402b0cc:	1000051e 	bne	r2,zero,402b0e4 <alt_avalon_spi_command+0x94>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 402b0d0:	e0bffc17 	ldw	r2,-16(fp)
 402b0d4:	10800304 	addi	r2,r2,12
 402b0d8:	1007883a 	mov	r3,r2
 402b0dc:	00810004 	movi	r2,1024
 402b0e0:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 402b0e4:	e0bffc17 	ldw	r2,-16(fp)
 402b0e8:	10800037 	ldwio	r2,0(r2)
 402b0ec:	00000006 	br	402b0f0 <alt_avalon_spi_command+0xa0>
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 402b0f0:	e0bffc17 	ldw	r2,-16(fp)
 402b0f4:	10800204 	addi	r2,r2,8
 402b0f8:	10800037 	ldwio	r2,0(r2)
 402b0fc:	e0bff715 	stw	r2,-36(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 402b100:	e0bff717 	ldw	r2,-36(fp)
 402b104:	1080100c 	andi	r2,r2,64
 402b108:	1005003a 	cmpeq	r2,r2,zero
 402b10c:	1000031e 	bne	r2,zero,402b11c <alt_avalon_spi_command+0xcc>
 402b110:	e0bff617 	ldw	r2,-40(fp)
 402b114:	1004c03a 	cmpne	r2,r2,zero
 402b118:	1000041e 	bne	r2,zero,402b12c <alt_avalon_spi_command+0xdc>
 402b11c:	e0bff717 	ldw	r2,-36(fp)
 402b120:	1080200c 	andi	r2,r2,128
 402b124:	1005003a 	cmpeq	r2,r2,zero
 402b128:	103ff11e 	bne	r2,zero,402b0f0 <alt_avalon_spi_command+0xa0>

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 402b12c:	e0bff717 	ldw	r2,-36(fp)
 402b130:	1080100c 	andi	r2,r2,64
 402b134:	1005003a 	cmpeq	r2,r2,zero
 402b138:	1000201e 	bne	r2,zero,402b1bc <alt_avalon_spi_command+0x16c>
 402b13c:	e0bff617 	ldw	r2,-40(fp)
 402b140:	10800050 	cmplti	r2,r2,1
 402b144:	10001d1e 	bne	r2,zero,402b1bc <alt_avalon_spi_command+0x16c>
    {
      credits--;
 402b148:	e0bff617 	ldw	r2,-40(fp)
 402b14c:	10bfffc4 	addi	r2,r2,-1
 402b150:	e0bff615 	stw	r2,-40(fp)

      if (write_data < write_end)
 402b154:	e0ffff17 	ldw	r3,-4(fp)
 402b158:	e0bffb17 	ldw	r2,-20(fp)
 402b15c:	18800b2e 	bgeu	r3,r2,402b18c <alt_avalon_spi_command+0x13c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 402b160:	e0bffc17 	ldw	r2,-16(fp)
 402b164:	11000104 	addi	r4,r2,4
 402b168:	e0bfff17 	ldw	r2,-4(fp)
 402b16c:	10800003 	ldbu	r2,0(r2)
 402b170:	10c03fcc 	andi	r3,r2,255
 402b174:	e0bfff17 	ldw	r2,-4(fp)
 402b178:	10800044 	addi	r2,r2,1
 402b17c:	e0bfff15 	stw	r2,-4(fp)
 402b180:	2005883a 	mov	r2,r4
 402b184:	10c00035 	stwio	r3,0(r2)
 402b188:	00000c06 	br	402b1bc <alt_avalon_spi_command+0x16c>
      else if (write_zeros > 0)
 402b18c:	e0bff917 	ldw	r2,-28(fp)
 402b190:	1005003a 	cmpeq	r2,r2,zero
 402b194:	1000071e 	bne	r2,zero,402b1b4 <alt_avalon_spi_command+0x164>
      {
        write_zeros--;
 402b198:	e0bff917 	ldw	r2,-28(fp)
 402b19c:	10bfffc4 	addi	r2,r2,-1
 402b1a0:	e0bff915 	stw	r2,-28(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 402b1a4:	e0bffc17 	ldw	r2,-16(fp)
 402b1a8:	10800104 	addi	r2,r2,4
 402b1ac:	10000035 	stwio	zero,0(r2)
 402b1b0:	00000206 	br	402b1bc <alt_avalon_spi_command+0x16c>
      }
      else
        credits = -1024;
 402b1b4:	00bf0004 	movi	r2,-1024
 402b1b8:	e0bff615 	stw	r2,-40(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 402b1bc:	e0bff717 	ldw	r2,-36(fp)
 402b1c0:	1080200c 	andi	r2,r2,128
 402b1c4:	1005003a 	cmpeq	r2,r2,zero
 402b1c8:	103fc91e 	bne	r2,zero,402b0f0 <alt_avalon_spi_command+0xa0>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 402b1cc:	e0bffc17 	ldw	r2,-16(fp)
 402b1d0:	10800037 	ldwio	r2,0(r2)
 402b1d4:	e0bff515 	stw	r2,-44(fp)

      if (read_ignore > 0)
 402b1d8:	e0bff817 	ldw	r2,-32(fp)
 402b1dc:	1005003a 	cmpeq	r2,r2,zero
 402b1e0:	1000041e 	bne	r2,zero,402b1f4 <alt_avalon_spi_command+0x1a4>
        read_ignore--;
 402b1e4:	e0bff817 	ldw	r2,-32(fp)
 402b1e8:	10bfffc4 	addi	r2,r2,-1
 402b1ec:	e0bff815 	stw	r2,-32(fp)
 402b1f0:	00000706 	br	402b210 <alt_avalon_spi_command+0x1c0>
      else
        *read_data++ = (alt_u8)rxdata;
 402b1f4:	e0bff517 	ldw	r2,-44(fp)
 402b1f8:	1007883a 	mov	r3,r2
 402b1fc:	e0800217 	ldw	r2,8(fp)
 402b200:	10c00005 	stb	r3,0(r2)
 402b204:	e0800217 	ldw	r2,8(fp)
 402b208:	10800044 	addi	r2,r2,1
 402b20c:	e0800215 	stw	r2,8(fp)
      credits++;
 402b210:	e0bff617 	ldw	r2,-40(fp)
 402b214:	10800044 	addi	r2,r2,1
 402b218:	e0bff615 	stw	r2,-40(fp)

      if (read_ignore == 0 && read_data == read_end)
 402b21c:	e0bff817 	ldw	r2,-32(fp)
 402b220:	1004c03a 	cmpne	r2,r2,zero
 402b224:	103fb21e 	bne	r2,zero,402b0f0 <alt_avalon_spi_command+0xa0>
 402b228:	e0c00217 	ldw	r3,8(fp)
 402b22c:	e0bffa17 	ldw	r2,-24(fp)
 402b230:	18800126 	beq	r3,r2,402b238 <alt_avalon_spi_command+0x1e8>
        break;
    }
    
  }
 402b234:	003fae06 	br	402b0f0 <alt_avalon_spi_command+0xa0>

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 402b238:	e0bffc17 	ldw	r2,-16(fp)
 402b23c:	10800204 	addi	r2,r2,8
 402b240:	10800037 	ldwio	r2,0(r2)
 402b244:	e0bff715 	stw	r2,-36(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 402b248:	e0bff717 	ldw	r2,-36(fp)
 402b24c:	1080080c 	andi	r2,r2,32
 402b250:	1005003a 	cmpeq	r2,r2,zero
 402b254:	103ff81e 	bne	r2,zero,402b238 <alt_avalon_spi_command+0x1e8>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 402b258:	e0800317 	ldw	r2,12(fp)
 402b25c:	1080004c 	andi	r2,r2,1
 402b260:	1004c03a 	cmpne	r2,r2,zero
 402b264:	1000031e 	bne	r2,zero,402b274 <alt_avalon_spi_command+0x224>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 402b268:	e0bffc17 	ldw	r2,-16(fp)
 402b26c:	10800304 	addi	r2,r2,12
 402b270:	10000035 	stwio	zero,0(r2)

  return read_length;
 402b274:	e0800117 	ldw	r2,4(fp)
}
 402b278:	e037883a 	mov	sp,fp
 402b27c:	df000017 	ldw	fp,0(sp)
 402b280:	dec00104 	addi	sp,sp,4
 402b284:	f800283a 	ret

0402b288 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 402b288:	defffa04 	addi	sp,sp,-24
 402b28c:	dfc00515 	stw	ra,20(sp)
 402b290:	df000415 	stw	fp,16(sp)
 402b294:	df000404 	addi	fp,sp,16
 402b298:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 402b29c:	e0bfff17 	ldw	r2,-4(fp)
 402b2a0:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 402b2a4:	e0bfff17 	ldw	r2,-4(fp)
 402b2a8:	10800104 	addi	r2,r2,4
 402b2ac:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402b2b0:	0005303a 	rdctl	r2,status
 402b2b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402b2b8:	e0fffd17 	ldw	r3,-12(fp)
 402b2bc:	00bfff84 	movi	r2,-2
 402b2c0:	1884703a 	and	r2,r3,r2
 402b2c4:	1001703a 	wrctl	status,r2
  
  return context;
 402b2c8:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 402b2cc:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 402b2d0:	402c3700 	call	402c370 <alt_tick>
 402b2d4:	e0bffe17 	ldw	r2,-8(fp)
 402b2d8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402b2dc:	e0bffc17 	ldw	r2,-16(fp)
 402b2e0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 402b2e4:	e037883a 	mov	sp,fp
 402b2e8:	dfc00117 	ldw	ra,4(sp)
 402b2ec:	df000017 	ldw	fp,0(sp)
 402b2f0:	dec00204 	addi	sp,sp,8
 402b2f4:	f800283a 	ret

0402b2f8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 402b2f8:	defff804 	addi	sp,sp,-32
 402b2fc:	dfc00715 	stw	ra,28(sp)
 402b300:	df000615 	stw	fp,24(sp)
 402b304:	df000604 	addi	fp,sp,24
 402b308:	e13ffc15 	stw	r4,-16(fp)
 402b30c:	e17ffd15 	stw	r5,-12(fp)
 402b310:	e1bffe15 	stw	r6,-8(fp)
 402b314:	e1ffff15 	stw	r7,-4(fp)
 402b318:	e0bfff17 	ldw	r2,-4(fp)
 402b31c:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 402b320:	008100f4 	movhi	r2,1027
 402b324:	10842904 	addi	r2,r2,4260
 402b328:	10800017 	ldw	r2,0(r2)
 402b32c:	1004c03a 	cmpne	r2,r2,zero
 402b330:	1000041e 	bne	r2,zero,402b344 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 402b334:	00c100f4 	movhi	r3,1027
 402b338:	18c42904 	addi	r3,r3,4260
 402b33c:	e0bffb17 	ldw	r2,-20(fp)
 402b340:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 402b344:	e0bffc17 	ldw	r2,-16(fp)
 402b348:	10800104 	addi	r2,r2,4
 402b34c:	1007883a 	mov	r3,r2
 402b350:	008001c4 	movi	r2,7
 402b354:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 402b358:	d8000015 	stw	zero,0(sp)
 402b35c:	e13ffd17 	ldw	r4,-12(fp)
 402b360:	e17ffe17 	ldw	r5,-8(fp)
 402b364:	018100f4 	movhi	r6,1027
 402b368:	31aca204 	addi	r6,r6,-19832
 402b36c:	e1fffc17 	ldw	r7,-16(fp)
 402b370:	402bbac0 	call	402bbac <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 402b374:	e037883a 	mov	sp,fp
 402b378:	dfc00117 	ldw	ra,4(sp)
 402b37c:	df000017 	ldw	fp,0(sp)
 402b380:	dec00204 	addi	sp,sp,8
 402b384:	f800283a 	ret

0402b388 <alt_timestamp_start>:
 * The return value of this function is 0 upon sucess and -1 if in timestamp
 * device has not been registered. 
 */

int alt_timestamp_start(void)
{
 402b388:	defffd04 	addi	sp,sp,-12
 402b38c:	df000215 	stw	fp,8(sp)
 402b390:	df000204 	addi	fp,sp,8
  void* base = altera_avalon_timer_ts_base;
 402b394:	008100f4 	movhi	r2,1027
 402b398:	10842604 	addi	r2,r2,4248
 402b39c:	10800017 	ldw	r2,0(r2)
 402b3a0:	e0bffe15 	stw	r2,-8(fp)

  if (!altera_avalon_timer_ts_freq)
 402b3a4:	008100f4 	movhi	r2,1027
 402b3a8:	10842704 	addi	r2,r2,4252
 402b3ac:	10800017 	ldw	r2,0(r2)
 402b3b0:	1004c03a 	cmpne	r2,r2,zero
 402b3b4:	1000031e 	bne	r2,zero,402b3c4 <alt_timestamp_start+0x3c>
  {
    return -1;
 402b3b8:	00bfffc4 	movi	r2,-1
 402b3bc:	e0bfff15 	stw	r2,-4(fp)
 402b3c0:	00001506 	br	402b418 <alt_timestamp_start+0x90>
        IOWR_ALTERA_AVALON_TIMER_PERIOD_1 (base, 0xFFFF);;
        IOWR_ALTERA_AVALON_TIMER_PERIOD_2 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_PERIOD_3 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
    } else {
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base,ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
 402b3c4:	e0bffe17 	ldw	r2,-8(fp)
 402b3c8:	10800104 	addi	r2,r2,4
 402b3cc:	1007883a 	mov	r3,r2
 402b3d0:	00800204 	movi	r2,8
 402b3d4:	18800035 	stwio	r2,0(r3)
        IOWR_ALTERA_AVALON_TIMER_PERIODL (base, 0xFFFF);
 402b3d8:	e0bffe17 	ldw	r2,-8(fp)
 402b3dc:	10800204 	addi	r2,r2,8
 402b3e0:	1007883a 	mov	r3,r2
 402b3e4:	00bfffd4 	movui	r2,65535
 402b3e8:	18800035 	stwio	r2,0(r3)
        IOWR_ALTERA_AVALON_TIMER_PERIODH (base, 0xFFFF);
 402b3ec:	e0bffe17 	ldw	r2,-8(fp)
 402b3f0:	10800304 	addi	r2,r2,12
 402b3f4:	1007883a 	mov	r3,r2
 402b3f8:	00bfffd4 	movui	r2,65535
 402b3fc:	18800035 	stwio	r2,0(r3)
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK); 
 402b400:	e0bffe17 	ldw	r2,-8(fp)
 402b404:	10800104 	addi	r2,r2,4
 402b408:	1007883a 	mov	r3,r2
 402b40c:	00800104 	movi	r2,4
 402b410:	18800035 	stwio	r2,0(r3)
    } 
  }
  return 0;
 402b414:	e03fff15 	stw	zero,-4(fp)
 402b418:	e0bfff17 	ldw	r2,-4(fp)
}
 402b41c:	e037883a 	mov	sp,fp
 402b420:	df000017 	ldw	fp,0(sp)
 402b424:	dec00104 	addi	sp,sp,4
 402b428:	f800283a 	ret

0402b42c <alt_timestamp>:
 * The returned timestamp counts up from the last time the period register
 * was reset. 
 */

alt_timestamp_type alt_timestamp(void)
{
 402b42c:	defffb04 	addi	sp,sp,-20
 402b430:	df000415 	stw	fp,16(sp)
 402b434:	df000404 	addi	fp,sp,16

  void* base = altera_avalon_timer_ts_base;
 402b438:	008100f4 	movhi	r2,1027
 402b43c:	10842604 	addi	r2,r2,4248
 402b440:	10800017 	ldw	r2,0(r2)
 402b444:	e0bffe15 	stw	r2,-8(fp)

  if (!altera_avalon_timer_ts_freq)
 402b448:	008100f4 	movhi	r2,1027
 402b44c:	10842704 	addi	r2,r2,4252
 402b450:	10800017 	ldw	r2,0(r2)
 402b454:	1004c03a 	cmpne	r2,r2,zero
 402b458:	1000031e 	bne	r2,zero,402b468 <alt_timestamp+0x3c>
  {
	if(ALT_TIMESTAMP_COUNTER_SIZE == 64) {
        return 0xFFFFFFFFFFFFFFFFULL;
    } else {
        return 0xFFFFFFFF;
 402b45c:	00bfffc4 	movi	r2,-1
 402b460:	e0bfff15 	stw	r2,-4(fp)
 402b464:	00001306 	br	402b4b4 <alt_timestamp+0x88>
        alt_timestamp_type snap_2 = IORD_ALTERA_AVALON_TIMER_SNAP_2(base) & ALTERA_AVALON_TIMER_SNAP_2_MSK;
        alt_timestamp_type snap_3 = IORD_ALTERA_AVALON_TIMER_SNAP_3(base) & ALTERA_AVALON_TIMER_SNAP_3_MSK;
        
        return (0xFFFFFFFFFFFFFFFFULL - ( (snap_3 << 48) | (snap_2 << 32) | (snap_1 << 16) | (snap_0) ));
    } else {
        IOWR_ALTERA_AVALON_TIMER_SNAPL (base, 0);
 402b468:	e0bffe17 	ldw	r2,-8(fp)
 402b46c:	10800404 	addi	r2,r2,16
 402b470:	10000035 	stwio	zero,0(r2)
        alt_timestamp_type lower = IORD_ALTERA_AVALON_TIMER_SNAPL(base) & ALTERA_AVALON_TIMER_SNAPL_MSK;
 402b474:	e0bffe17 	ldw	r2,-8(fp)
 402b478:	10800404 	addi	r2,r2,16
 402b47c:	10800037 	ldwio	r2,0(r2)
 402b480:	10bfffcc 	andi	r2,r2,65535
 402b484:	e0bffd15 	stw	r2,-12(fp)
        alt_timestamp_type upper = IORD_ALTERA_AVALON_TIMER_SNAPH(base) & ALTERA_AVALON_TIMER_SNAPH_MSK;
 402b488:	e0bffe17 	ldw	r2,-8(fp)
 402b48c:	10800504 	addi	r2,r2,20
 402b490:	10800037 	ldwio	r2,0(r2)
 402b494:	10bfffcc 	andi	r2,r2,65535
 402b498:	e0bffc15 	stw	r2,-16(fp)
        
        return (0xFFFFFFFF - ((upper << 16) | lower)); 
 402b49c:	e0bffc17 	ldw	r2,-16(fp)
 402b4a0:	1006943a 	slli	r3,r2,16
 402b4a4:	e0bffd17 	ldw	r2,-12(fp)
 402b4a8:	1884b03a 	or	r2,r3,r2
 402b4ac:	0084303a 	nor	r2,zero,r2
 402b4b0:	e0bfff15 	stw	r2,-4(fp)
 402b4b4:	e0bfff17 	ldw	r2,-4(fp)
    }  
  }
}
 402b4b8:	e037883a 	mov	sp,fp
 402b4bc:	df000017 	ldw	fp,0(sp)
 402b4c0:	dec00104 	addi	sp,sp,4
 402b4c4:	f800283a 	ret

0402b4c8 <alt_timestamp_freq>:
 * Return the number of timestamp ticks per second. This will be 0 if no
 * timestamp device has been registered.
 */

alt_u32 alt_timestamp_freq(void)
{
 402b4c8:	deffff04 	addi	sp,sp,-4
 402b4cc:	df000015 	stw	fp,0(sp)
 402b4d0:	d839883a 	mov	fp,sp
  return altera_avalon_timer_ts_freq;
 402b4d4:	008100f4 	movhi	r2,1027
 402b4d8:	10842704 	addi	r2,r2,4252
 402b4dc:	10800017 	ldw	r2,0(r2)
}
 402b4e0:	e037883a 	mov	sp,fp
 402b4e4:	df000017 	ldw	fp,0(sp)
 402b4e8:	dec00104 	addi	sp,sp,4
 402b4ec:	f800283a 	ret

0402b4f0 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 402b4f0:	defff404 	addi	sp,sp,-48
 402b4f4:	df000b15 	stw	fp,44(sp)
 402b4f8:	df000b04 	addi	fp,sp,44
 402b4fc:	e13ffb15 	stw	r4,-20(fp)
 402b500:	e17ffc15 	stw	r5,-16(fp)
 402b504:	e1bffd15 	stw	r6,-12(fp)
 402b508:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 402b50c:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 402b510:	008100f4 	movhi	r2,1027
 402b514:	10842904 	addi	r2,r2,4260
 402b518:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 402b51c:	1005003a 	cmpeq	r2,r2,zero
 402b520:	1000411e 	bne	r2,zero,402b628 <alt_alarm_start+0x138>
  {
    if (alarm)
 402b524:	e0bffb17 	ldw	r2,-20(fp)
 402b528:	1005003a 	cmpeq	r2,r2,zero
 402b52c:	10003b1e 	bne	r2,zero,402b61c <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 402b530:	e0fffb17 	ldw	r3,-20(fp)
 402b534:	e0bffd17 	ldw	r2,-12(fp)
 402b538:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 402b53c:	e0fffb17 	ldw	r3,-20(fp)
 402b540:	e0bffe17 	ldw	r2,-8(fp)
 402b544:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402b548:	0005303a 	rdctl	r2,status
 402b54c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402b550:	e0fff817 	ldw	r3,-32(fp)
 402b554:	00bfff84 	movi	r2,-2
 402b558:	1884703a 	and	r2,r3,r2
 402b55c:	1001703a 	wrctl	status,r2
  
  return context;
 402b560:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 402b564:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 402b568:	008100f4 	movhi	r2,1027
 402b56c:	10842a04 	addi	r2,r2,4264
 402b570:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 402b574:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 402b578:	e0fffc17 	ldw	r3,-16(fp)
 402b57c:	e0bff917 	ldw	r2,-28(fp)
 402b580:	1885883a 	add	r2,r3,r2
 402b584:	10c00044 	addi	r3,r2,1
 402b588:	e0bffb17 	ldw	r2,-20(fp)
 402b58c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 402b590:	e0bffb17 	ldw	r2,-20(fp)
 402b594:	10c00217 	ldw	r3,8(r2)
 402b598:	e0bff917 	ldw	r2,-28(fp)
 402b59c:	1880042e 	bgeu	r3,r2,402b5b0 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 402b5a0:	e0fffb17 	ldw	r3,-20(fp)
 402b5a4:	00800044 	movi	r2,1
 402b5a8:	18800405 	stb	r2,16(r3)
 402b5ac:	00000206 	br	402b5b8 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 402b5b0:	e0bffb17 	ldw	r2,-20(fp)
 402b5b4:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 402b5b8:	e0fffb17 	ldw	r3,-20(fp)
 402b5bc:	008100f4 	movhi	r2,1027
 402b5c0:	10bd7304 	addi	r2,r2,-2612
 402b5c4:	e0bff615 	stw	r2,-40(fp)
 402b5c8:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 402b5cc:	e0fff717 	ldw	r3,-36(fp)
 402b5d0:	e0bff617 	ldw	r2,-40(fp)
 402b5d4:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 402b5d8:	e0bff617 	ldw	r2,-40(fp)
 402b5dc:	10c00017 	ldw	r3,0(r2)
 402b5e0:	e0bff717 	ldw	r2,-36(fp)
 402b5e4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 402b5e8:	e0bff617 	ldw	r2,-40(fp)
 402b5ec:	10c00017 	ldw	r3,0(r2)
 402b5f0:	e0bff717 	ldw	r2,-36(fp)
 402b5f4:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 402b5f8:	e0fff617 	ldw	r3,-40(fp)
 402b5fc:	e0bff717 	ldw	r2,-36(fp)
 402b600:	18800015 	stw	r2,0(r3)
 402b604:	e0bffa17 	ldw	r2,-24(fp)
 402b608:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402b60c:	e0bff517 	ldw	r2,-44(fp)
 402b610:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 402b614:	e03fff15 	stw	zero,-4(fp)
 402b618:	00000506 	br	402b630 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 402b61c:	00bffa84 	movi	r2,-22
 402b620:	e0bfff15 	stw	r2,-4(fp)
 402b624:	00000206 	br	402b630 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 402b628:	00bfde84 	movi	r2,-134
 402b62c:	e0bfff15 	stw	r2,-4(fp)
 402b630:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 402b634:	e037883a 	mov	sp,fp
 402b638:	df000017 	ldw	fp,0(sp)
 402b63c:	dec00104 	addi	sp,sp,4
 402b640:	f800283a 	ret

0402b644 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 402b644:	defffa04 	addi	sp,sp,-24
 402b648:	dfc00515 	stw	ra,20(sp)
 402b64c:	df000415 	stw	fp,16(sp)
 402b650:	df000404 	addi	fp,sp,16
 402b654:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 402b658:	008000c4 	movi	r2,3
 402b65c:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 402b660:	e0fffc17 	ldw	r3,-16(fp)
 402b664:	008003f4 	movhi	r2,15
 402b668:	10909004 	addi	r2,r2,16960
 402b66c:	188b383a 	mul	r5,r3,r2
 402b670:	0100bef4 	movhi	r4,763
 402b674:	213c2004 	addi	r4,r4,-3968
 402b678:	40266940 	call	4026694 <__udivsi3>
 402b67c:	100b883a 	mov	r5,r2
 402b680:	01200034 	movhi	r4,32768
 402b684:	213fffc4 	addi	r4,r4,-1
 402b688:	40266940 	call	4026694 <__udivsi3>
 402b68c:	100b883a 	mov	r5,r2
 402b690:	e13fff17 	ldw	r4,-4(fp)
 402b694:	40266940 	call	4026694 <__udivsi3>
 402b698:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 402b69c:	e0bffd17 	ldw	r2,-12(fp)
 402b6a0:	1005003a 	cmpeq	r2,r2,zero
 402b6a4:	1000281e 	bne	r2,zero,402b748 <alt_busy_sleep+0x104>
  {
    for(i=0;i<big_loops;i++)
 402b6a8:	e03ffe15 	stw	zero,-8(fp)
 402b6ac:	00001606 	br	402b708 <alt_busy_sleep+0xc4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 402b6b0:	00a00034 	movhi	r2,32768
 402b6b4:	10bfffc4 	addi	r2,r2,-1
 402b6b8:	10bfffc4 	addi	r2,r2,-1
 402b6bc:	103ffe1e 	bne	r2,zero,402b6b8 <alt_busy_sleep+0x74>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 402b6c0:	e0fffc17 	ldw	r3,-16(fp)
 402b6c4:	008003f4 	movhi	r2,15
 402b6c8:	10909004 	addi	r2,r2,16960
 402b6cc:	188b383a 	mul	r5,r3,r2
 402b6d0:	0100bef4 	movhi	r4,763
 402b6d4:	213c2004 	addi	r4,r4,-3968
 402b6d8:	40266940 	call	4026694 <__udivsi3>
 402b6dc:	100b883a 	mov	r5,r2
 402b6e0:	01200034 	movhi	r4,32768
 402b6e4:	213fffc4 	addi	r4,r4,-1
 402b6e8:	40266940 	call	4026694 <__udivsi3>
 402b6ec:	1007883a 	mov	r3,r2
 402b6f0:	e0bfff17 	ldw	r2,-4(fp)
 402b6f4:	10c5c83a 	sub	r2,r2,r3
 402b6f8:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 402b6fc:	e0bffe17 	ldw	r2,-8(fp)
 402b700:	10800044 	addi	r2,r2,1
 402b704:	e0bffe15 	stw	r2,-8(fp)
 402b708:	e0fffe17 	ldw	r3,-8(fp)
 402b70c:	e0bffd17 	ldw	r2,-12(fp)
 402b710:	18bfe716 	blt	r3,r2,402b6b0 <alt_busy_sleep+0x6c>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 402b714:	e0fffc17 	ldw	r3,-16(fp)
 402b718:	008003f4 	movhi	r2,15
 402b71c:	10909004 	addi	r2,r2,16960
 402b720:	188b383a 	mul	r5,r3,r2
 402b724:	0100bef4 	movhi	r4,763
 402b728:	213c2004 	addi	r4,r4,-3968
 402b72c:	40266940 	call	4026694 <__udivsi3>
 402b730:	1007883a 	mov	r3,r2
 402b734:	e0bfff17 	ldw	r2,-4(fp)
 402b738:	1885383a 	mul	r2,r3,r2
 402b73c:	10bfffc4 	addi	r2,r2,-1
 402b740:	103ffe1e 	bne	r2,zero,402b73c <alt_busy_sleep+0xf8>
 402b744:	00000c06 	br	402b778 <alt_busy_sleep+0x134>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 402b748:	e0fffc17 	ldw	r3,-16(fp)
 402b74c:	008003f4 	movhi	r2,15
 402b750:	10909004 	addi	r2,r2,16960
 402b754:	188b383a 	mul	r5,r3,r2
 402b758:	0100bef4 	movhi	r4,763
 402b75c:	213c2004 	addi	r4,r4,-3968
 402b760:	40266940 	call	4026694 <__udivsi3>
 402b764:	1007883a 	mov	r3,r2
 402b768:	e0bfff17 	ldw	r2,-4(fp)
 402b76c:	1885383a 	mul	r2,r3,r2
 402b770:	10bfffc4 	addi	r2,r2,-1
 402b774:	00bffe16 	blt	zero,r2,402b770 <alt_busy_sleep+0x12c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 402b778:	0005883a 	mov	r2,zero
}
 402b77c:	e037883a 	mov	sp,fp
 402b780:	dfc00117 	ldw	ra,4(sp)
 402b784:	df000017 	ldw	fp,0(sp)
 402b788:	dec00204 	addi	sp,sp,8
 402b78c:	f800283a 	ret

0402b790 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 402b790:	defff804 	addi	sp,sp,-32
 402b794:	dfc00715 	stw	ra,28(sp)
 402b798:	df000615 	stw	fp,24(sp)
 402b79c:	df000604 	addi	fp,sp,24
 402b7a0:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 402b7a4:	e0bffc17 	ldw	r2,-16(fp)
 402b7a8:	1004803a 	cmplt	r2,r2,zero
 402b7ac:	1000081e 	bne	r2,zero,402b7d0 <close+0x40>
 402b7b0:	e0bffc17 	ldw	r2,-16(fp)
 402b7b4:	10800324 	muli	r2,r2,12
 402b7b8:	1007883a 	mov	r3,r2
 402b7bc:	008100f4 	movhi	r2,1027
 402b7c0:	10bcf904 	addi	r2,r2,-3100
 402b7c4:	1887883a 	add	r3,r3,r2
 402b7c8:	e0ffff15 	stw	r3,-4(fp)
 402b7cc:	00000106 	br	402b7d4 <close+0x44>
 402b7d0:	e03fff15 	stw	zero,-4(fp)
 402b7d4:	e0bfff17 	ldw	r2,-4(fp)
 402b7d8:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 402b7dc:	e0bffb17 	ldw	r2,-20(fp)
 402b7e0:	1005003a 	cmpeq	r2,r2,zero
 402b7e4:	10001d1e 	bne	r2,zero,402b85c <close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 402b7e8:	e0bffb17 	ldw	r2,-20(fp)
 402b7ec:	10800017 	ldw	r2,0(r2)
 402b7f0:	10800417 	ldw	r2,16(r2)
 402b7f4:	1005003a 	cmpeq	r2,r2,zero
 402b7f8:	1000071e 	bne	r2,zero,402b818 <close+0x88>
 402b7fc:	e0bffb17 	ldw	r2,-20(fp)
 402b800:	10800017 	ldw	r2,0(r2)
 402b804:	10800417 	ldw	r2,16(r2)
 402b808:	e13ffb17 	ldw	r4,-20(fp)
 402b80c:	103ee83a 	callr	r2
 402b810:	e0bffe15 	stw	r2,-8(fp)
 402b814:	00000106 	br	402b81c <close+0x8c>
 402b818:	e03ffe15 	stw	zero,-8(fp)
 402b81c:	e0bffe17 	ldw	r2,-8(fp)
 402b820:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 402b824:	e13ffc17 	ldw	r4,-16(fp)
 402b828:	402c2780 	call	402c278 <alt_release_fd>
    if (rval < 0)
 402b82c:	e0bffa17 	ldw	r2,-24(fp)
 402b830:	1004403a 	cmpge	r2,r2,zero
 402b834:	1000071e 	bne	r2,zero,402b854 <close+0xc4>
    {
      ALT_ERRNO = -rval;
 402b838:	402b88c0 	call	402b88c <alt_get_errno>
 402b83c:	e0fffa17 	ldw	r3,-24(fp)
 402b840:	00c7c83a 	sub	r3,zero,r3
 402b844:	10c00015 	stw	r3,0(r2)
      return -1;
 402b848:	00bfffc4 	movi	r2,-1
 402b84c:	e0bffd15 	stw	r2,-12(fp)
 402b850:	00000806 	br	402b874 <close+0xe4>
    }
    return 0;
 402b854:	e03ffd15 	stw	zero,-12(fp)
 402b858:	00000606 	br	402b874 <close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 402b85c:	402b88c0 	call	402b88c <alt_get_errno>
 402b860:	1007883a 	mov	r3,r2
 402b864:	00801444 	movi	r2,81
 402b868:	18800015 	stw	r2,0(r3)
    return -1;
 402b86c:	00bfffc4 	movi	r2,-1
 402b870:	e0bffd15 	stw	r2,-12(fp)
 402b874:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 402b878:	e037883a 	mov	sp,fp
 402b87c:	dfc00117 	ldw	ra,4(sp)
 402b880:	df000017 	ldw	fp,0(sp)
 402b884:	dec00204 	addi	sp,sp,8
 402b888:	f800283a 	ret

0402b88c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 402b88c:	defffd04 	addi	sp,sp,-12
 402b890:	dfc00215 	stw	ra,8(sp)
 402b894:	df000115 	stw	fp,4(sp)
 402b898:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 402b89c:	008100f4 	movhi	r2,1027
 402b8a0:	10bd7104 	addi	r2,r2,-2620
 402b8a4:	10800017 	ldw	r2,0(r2)
 402b8a8:	1005003a 	cmpeq	r2,r2,zero
 402b8ac:	1000061e 	bne	r2,zero,402b8c8 <alt_get_errno+0x3c>
 402b8b0:	008100f4 	movhi	r2,1027
 402b8b4:	10bd7104 	addi	r2,r2,-2620
 402b8b8:	10800017 	ldw	r2,0(r2)
 402b8bc:	103ee83a 	callr	r2
 402b8c0:	e0bfff15 	stw	r2,-4(fp)
 402b8c4:	00000306 	br	402b8d4 <alt_get_errno+0x48>
 402b8c8:	008100f4 	movhi	r2,1027
 402b8cc:	10842204 	addi	r2,r2,4232
 402b8d0:	e0bfff15 	stw	r2,-4(fp)
 402b8d4:	e0bfff17 	ldw	r2,-4(fp)
}
 402b8d8:	e037883a 	mov	sp,fp
 402b8dc:	dfc00117 	ldw	ra,4(sp)
 402b8e0:	df000017 	ldw	fp,0(sp)
 402b8e4:	dec00204 	addi	sp,sp,8
 402b8e8:	f800283a 	ret

0402b8ec <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 402b8ec:	defffb04 	addi	sp,sp,-20
 402b8f0:	df000415 	stw	fp,16(sp)
 402b8f4:	df000404 	addi	fp,sp,16
 402b8f8:	e13ffe15 	stw	r4,-8(fp)
 402b8fc:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 402b900:	e0fffe17 	ldw	r3,-8(fp)
 402b904:	e0bfff17 	ldw	r2,-4(fp)
 402b908:	1885883a 	add	r2,r3,r2
 402b90c:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 402b910:	e0bffe17 	ldw	r2,-8(fp)
 402b914:	e0bffd15 	stw	r2,-12(fp)
 402b918:	00000506 	br	402b930 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 402b91c:	e0bffd17 	ldw	r2,-12(fp)
 402b920:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 402b924:	e0bffd17 	ldw	r2,-12(fp)
 402b928:	10800804 	addi	r2,r2,32
 402b92c:	e0bffd15 	stw	r2,-12(fp)
 402b930:	e0fffd17 	ldw	r3,-12(fp)
 402b934:	e0bffc17 	ldw	r2,-16(fp)
 402b938:	18bff836 	bltu	r3,r2,402b91c <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 402b93c:	e0bffe17 	ldw	r2,-8(fp)
 402b940:	108007cc 	andi	r2,r2,31
 402b944:	1005003a 	cmpeq	r2,r2,zero
 402b948:	1000021e 	bne	r2,zero,402b954 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 402b94c:	e0bffd17 	ldw	r2,-12(fp)
 402b950:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 402b954:	e037883a 	mov	sp,fp
 402b958:	df000017 	ldw	fp,0(sp)
 402b95c:	dec00104 	addi	sp,sp,4
 402b960:	f800283a 	ret

0402b964 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 402b964:	defffe04 	addi	sp,sp,-8
 402b968:	df000115 	stw	fp,4(sp)
 402b96c:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 402b970:	e03fff15 	stw	zero,-4(fp)
 402b974:	00000506 	br	402b98c <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 402b978:	e0bfff17 	ldw	r2,-4(fp)
 402b97c:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 402b980:	e0bfff17 	ldw	r2,-4(fp)
 402b984:	10800804 	addi	r2,r2,32
 402b988:	e0bfff15 	stw	r2,-4(fp)
 402b98c:	e0bfff17 	ldw	r2,-4(fp)
 402b990:	10820030 	cmpltui	r2,r2,2048
 402b994:	103ff81e 	bne	r2,zero,402b978 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 402b998:	e037883a 	mov	sp,fp
 402b99c:	df000017 	ldw	fp,0(sp)
 402b9a0:	dec00104 	addi	sp,sp,4
 402b9a4:	f800283a 	ret

0402b9a8 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 402b9a8:	defffc04 	addi	sp,sp,-16
 402b9ac:	df000315 	stw	fp,12(sp)
 402b9b0:	df000304 	addi	fp,sp,12
 402b9b4:	e13ffd15 	stw	r4,-12(fp)
 402b9b8:	e17ffe15 	stw	r5,-8(fp)
 402b9bc:	e1bfff15 	stw	r6,-4(fp)
  return len;
 402b9c0:	e0bfff17 	ldw	r2,-4(fp)
}
 402b9c4:	e037883a 	mov	sp,fp
 402b9c8:	df000017 	ldw	fp,0(sp)
 402b9cc:	dec00104 	addi	sp,sp,4
 402b9d0:	f800283a 	ret

0402b9d4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 402b9d4:	defff904 	addi	sp,sp,-28
 402b9d8:	dfc00615 	stw	ra,24(sp)
 402b9dc:	df000515 	stw	fp,20(sp)
 402b9e0:	df000504 	addi	fp,sp,20
 402b9e4:	e13ffd15 	stw	r4,-12(fp)
 402b9e8:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 402b9ec:	e0bffd17 	ldw	r2,-12(fp)
 402b9f0:	1005003a 	cmpeq	r2,r2,zero
 402b9f4:	1000041e 	bne	r2,zero,402ba08 <alt_dev_llist_insert+0x34>
 402b9f8:	e0bffd17 	ldw	r2,-12(fp)
 402b9fc:	10800217 	ldw	r2,8(r2)
 402ba00:	1004c03a 	cmpne	r2,r2,zero
 402ba04:	1000071e 	bne	r2,zero,402ba24 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 402ba08:	402ba880 	call	402ba88 <alt_get_errno>
 402ba0c:	1007883a 	mov	r3,r2
 402ba10:	00800584 	movi	r2,22
 402ba14:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 402ba18:	00bffa84 	movi	r2,-22
 402ba1c:	e0bfff15 	stw	r2,-4(fp)
 402ba20:	00001306 	br	402ba70 <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 402ba24:	e0fffd17 	ldw	r3,-12(fp)
 402ba28:	e0bffe17 	ldw	r2,-8(fp)
 402ba2c:	e0bffb15 	stw	r2,-20(fp)
 402ba30:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 402ba34:	e0fffc17 	ldw	r3,-16(fp)
 402ba38:	e0bffb17 	ldw	r2,-20(fp)
 402ba3c:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 402ba40:	e0bffb17 	ldw	r2,-20(fp)
 402ba44:	10c00017 	ldw	r3,0(r2)
 402ba48:	e0bffc17 	ldw	r2,-16(fp)
 402ba4c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 402ba50:	e0bffb17 	ldw	r2,-20(fp)
 402ba54:	10c00017 	ldw	r3,0(r2)
 402ba58:	e0bffc17 	ldw	r2,-16(fp)
 402ba5c:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 402ba60:	e0fffb17 	ldw	r3,-20(fp)
 402ba64:	e0bffc17 	ldw	r2,-16(fp)
 402ba68:	18800015 	stw	r2,0(r3)

  return 0;  
 402ba6c:	e03fff15 	stw	zero,-4(fp)
 402ba70:	e0bfff17 	ldw	r2,-4(fp)
}
 402ba74:	e037883a 	mov	sp,fp
 402ba78:	dfc00117 	ldw	ra,4(sp)
 402ba7c:	df000017 	ldw	fp,0(sp)
 402ba80:	dec00204 	addi	sp,sp,8
 402ba84:	f800283a 	ret

0402ba88 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 402ba88:	defffd04 	addi	sp,sp,-12
 402ba8c:	dfc00215 	stw	ra,8(sp)
 402ba90:	df000115 	stw	fp,4(sp)
 402ba94:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 402ba98:	008100f4 	movhi	r2,1027
 402ba9c:	10bd7104 	addi	r2,r2,-2620
 402baa0:	10800017 	ldw	r2,0(r2)
 402baa4:	1005003a 	cmpeq	r2,r2,zero
 402baa8:	1000061e 	bne	r2,zero,402bac4 <alt_get_errno+0x3c>
 402baac:	008100f4 	movhi	r2,1027
 402bab0:	10bd7104 	addi	r2,r2,-2620
 402bab4:	10800017 	ldw	r2,0(r2)
 402bab8:	103ee83a 	callr	r2
 402babc:	e0bfff15 	stw	r2,-4(fp)
 402bac0:	00000306 	br	402bad0 <alt_get_errno+0x48>
 402bac4:	008100f4 	movhi	r2,1027
 402bac8:	10842204 	addi	r2,r2,4232
 402bacc:	e0bfff15 	stw	r2,-4(fp)
 402bad0:	e0bfff17 	ldw	r2,-4(fp)
}
 402bad4:	e037883a 	mov	sp,fp
 402bad8:	dfc00117 	ldw	ra,4(sp)
 402badc:	df000017 	ldw	fp,0(sp)
 402bae0:	dec00204 	addi	sp,sp,8
 402bae4:	f800283a 	ret

0402bae8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 402bae8:	defff904 	addi	sp,sp,-28
 402baec:	dfc00615 	stw	ra,24(sp)
 402baf0:	df000515 	stw	fp,20(sp)
 402baf4:	df000504 	addi	fp,sp,20
 402baf8:	e13ffd15 	stw	r4,-12(fp)
 402bafc:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 402bb00:	e0bffe17 	ldw	r2,-8(fp)
 402bb04:	10800017 	ldw	r2,0(r2)
 402bb08:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 402bb0c:	e13ffd17 	ldw	r4,-12(fp)
 402bb10:	40275e40 	call	40275e4 <strlen>
 402bb14:	10800044 	addi	r2,r2,1
 402bb18:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 402bb1c:	00000d06 	br	402bb54 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 402bb20:	e0bffc17 	ldw	r2,-16(fp)
 402bb24:	11000217 	ldw	r4,8(r2)
 402bb28:	e1bffb17 	ldw	r6,-20(fp)
 402bb2c:	e17ffd17 	ldw	r5,-12(fp)
 402bb30:	402cfe40 	call	402cfe4 <memcmp>
 402bb34:	1004c03a 	cmpne	r2,r2,zero
 402bb38:	1000031e 	bne	r2,zero,402bb48 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 402bb3c:	e0bffc17 	ldw	r2,-16(fp)
 402bb40:	e0bfff15 	stw	r2,-4(fp)
 402bb44:	00000706 	br	402bb64 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 402bb48:	e0bffc17 	ldw	r2,-16(fp)
 402bb4c:	10800017 	ldw	r2,0(r2)
 402bb50:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 402bb54:	e0fffe17 	ldw	r3,-8(fp)
 402bb58:	e0bffc17 	ldw	r2,-16(fp)
 402bb5c:	10fff01e 	bne	r2,r3,402bb20 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 402bb60:	e03fff15 	stw	zero,-4(fp)
 402bb64:	e0bfff17 	ldw	r2,-4(fp)
}
 402bb68:	e037883a 	mov	sp,fp
 402bb6c:	dfc00117 	ldw	ra,4(sp)
 402bb70:	df000017 	ldw	fp,0(sp)
 402bb74:	dec00204 	addi	sp,sp,8
 402bb78:	f800283a 	ret

0402bb7c <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 402bb7c:	defffe04 	addi	sp,sp,-8
 402bb80:	dfc00115 	stw	ra,4(sp)
 402bb84:	df000015 	stw	fp,0(sp)
 402bb88:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 402bb8c:	0009883a 	mov	r4,zero
 402bb90:	01440004 	movi	r5,4096
 402bb94:	402cf340 	call	402cf34 <alt_icache_flush>
#endif
}
 402bb98:	e037883a 	mov	sp,fp
 402bb9c:	dfc00117 	ldw	ra,4(sp)
 402bba0:	df000017 	ldw	fp,0(sp)
 402bba4:	dec00204 	addi	sp,sp,8
 402bba8:	f800283a 	ret

0402bbac <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 402bbac:	defff904 	addi	sp,sp,-28
 402bbb0:	dfc00615 	stw	ra,24(sp)
 402bbb4:	df000515 	stw	fp,20(sp)
 402bbb8:	df000504 	addi	fp,sp,20
 402bbbc:	e13ffc15 	stw	r4,-16(fp)
 402bbc0:	e17ffd15 	stw	r5,-12(fp)
 402bbc4:	e1bffe15 	stw	r6,-8(fp)
 402bbc8:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 402bbcc:	e0800217 	ldw	r2,8(fp)
 402bbd0:	d8800015 	stw	r2,0(sp)
 402bbd4:	e13ffc17 	ldw	r4,-16(fp)
 402bbd8:	e17ffd17 	ldw	r5,-12(fp)
 402bbdc:	e1bffe17 	ldw	r6,-8(fp)
 402bbe0:	e1ffff17 	ldw	r7,-4(fp)
 402bbe4:	402bd800 	call	402bd80 <alt_iic_isr_register>
}  
 402bbe8:	e037883a 	mov	sp,fp
 402bbec:	dfc00117 	ldw	ra,4(sp)
 402bbf0:	df000017 	ldw	fp,0(sp)
 402bbf4:	dec00204 	addi	sp,sp,8
 402bbf8:	f800283a 	ret

0402bbfc <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 402bbfc:	defff904 	addi	sp,sp,-28
 402bc00:	df000615 	stw	fp,24(sp)
 402bc04:	df000604 	addi	fp,sp,24
 402bc08:	e13ffe15 	stw	r4,-8(fp)
 402bc0c:	e17fff15 	stw	r5,-4(fp)
 402bc10:	e0bfff17 	ldw	r2,-4(fp)
 402bc14:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402bc18:	0005303a 	rdctl	r2,status
 402bc1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402bc20:	e0fffb17 	ldw	r3,-20(fp)
 402bc24:	00bfff84 	movi	r2,-2
 402bc28:	1884703a 	and	r2,r3,r2
 402bc2c:	1001703a 	wrctl	status,r2
  
  return context;
 402bc30:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 402bc34:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 402bc38:	e0fffc17 	ldw	r3,-16(fp)
 402bc3c:	00800044 	movi	r2,1
 402bc40:	10c4983a 	sll	r2,r2,r3
 402bc44:	1007883a 	mov	r3,r2
 402bc48:	008100f4 	movhi	r2,1027
 402bc4c:	10842804 	addi	r2,r2,4256
 402bc50:	10800017 	ldw	r2,0(r2)
 402bc54:	1886b03a 	or	r3,r3,r2
 402bc58:	008100f4 	movhi	r2,1027
 402bc5c:	10842804 	addi	r2,r2,4256
 402bc60:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 402bc64:	008100f4 	movhi	r2,1027
 402bc68:	10842804 	addi	r2,r2,4256
 402bc6c:	10800017 	ldw	r2,0(r2)
 402bc70:	100170fa 	wrctl	ienable,r2
 402bc74:	e0bffd17 	ldw	r2,-12(fp)
 402bc78:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402bc7c:	e0bffa17 	ldw	r2,-24(fp)
 402bc80:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 402bc84:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 402bc88:	e037883a 	mov	sp,fp
 402bc8c:	df000017 	ldw	fp,0(sp)
 402bc90:	dec00104 	addi	sp,sp,4
 402bc94:	f800283a 	ret

0402bc98 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 402bc98:	defff904 	addi	sp,sp,-28
 402bc9c:	df000615 	stw	fp,24(sp)
 402bca0:	df000604 	addi	fp,sp,24
 402bca4:	e13ffe15 	stw	r4,-8(fp)
 402bca8:	e17fff15 	stw	r5,-4(fp)
 402bcac:	e0bfff17 	ldw	r2,-4(fp)
 402bcb0:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402bcb4:	0005303a 	rdctl	r2,status
 402bcb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402bcbc:	e0fffb17 	ldw	r3,-20(fp)
 402bcc0:	00bfff84 	movi	r2,-2
 402bcc4:	1884703a 	and	r2,r3,r2
 402bcc8:	1001703a 	wrctl	status,r2
  
  return context;
 402bccc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 402bcd0:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 402bcd4:	e0fffc17 	ldw	r3,-16(fp)
 402bcd8:	00800044 	movi	r2,1
 402bcdc:	10c4983a 	sll	r2,r2,r3
 402bce0:	0084303a 	nor	r2,zero,r2
 402bce4:	1007883a 	mov	r3,r2
 402bce8:	008100f4 	movhi	r2,1027
 402bcec:	10842804 	addi	r2,r2,4256
 402bcf0:	10800017 	ldw	r2,0(r2)
 402bcf4:	1886703a 	and	r3,r3,r2
 402bcf8:	008100f4 	movhi	r2,1027
 402bcfc:	10842804 	addi	r2,r2,4256
 402bd00:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 402bd04:	008100f4 	movhi	r2,1027
 402bd08:	10842804 	addi	r2,r2,4256
 402bd0c:	10800017 	ldw	r2,0(r2)
 402bd10:	100170fa 	wrctl	ienable,r2
 402bd14:	e0bffd17 	ldw	r2,-12(fp)
 402bd18:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402bd1c:	e0bffa17 	ldw	r2,-24(fp)
 402bd20:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 402bd24:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 402bd28:	e037883a 	mov	sp,fp
 402bd2c:	df000017 	ldw	fp,0(sp)
 402bd30:	dec00104 	addi	sp,sp,4
 402bd34:	f800283a 	ret

0402bd38 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 402bd38:	defffc04 	addi	sp,sp,-16
 402bd3c:	df000315 	stw	fp,12(sp)
 402bd40:	df000304 	addi	fp,sp,12
 402bd44:	e13ffe15 	stw	r4,-8(fp)
 402bd48:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 402bd4c:	000530fa 	rdctl	r2,ienable
 402bd50:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 402bd54:	e0ffff17 	ldw	r3,-4(fp)
 402bd58:	00800044 	movi	r2,1
 402bd5c:	10c4983a 	sll	r2,r2,r3
 402bd60:	1007883a 	mov	r3,r2
 402bd64:	e0bffd17 	ldw	r2,-12(fp)
 402bd68:	1884703a 	and	r2,r3,r2
 402bd6c:	1004c03a 	cmpne	r2,r2,zero
}
 402bd70:	e037883a 	mov	sp,fp
 402bd74:	df000017 	ldw	fp,0(sp)
 402bd78:	dec00104 	addi	sp,sp,4
 402bd7c:	f800283a 	ret

0402bd80 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 402bd80:	defff404 	addi	sp,sp,-48
 402bd84:	dfc00b15 	stw	ra,44(sp)
 402bd88:	df000a15 	stw	fp,40(sp)
 402bd8c:	df000a04 	addi	fp,sp,40
 402bd90:	e13ffb15 	stw	r4,-20(fp)
 402bd94:	e17ffc15 	stw	r5,-16(fp)
 402bd98:	e1bffd15 	stw	r6,-12(fp)
 402bd9c:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 402bda0:	00bffa84 	movi	r2,-22
 402bda4:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 402bda8:	e0bffc17 	ldw	r2,-16(fp)
 402bdac:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 402bdb0:	e0bff917 	ldw	r2,-28(fp)
 402bdb4:	10800808 	cmpgei	r2,r2,32
 402bdb8:	1000291e 	bne	r2,zero,402be60 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402bdbc:	0005303a 	rdctl	r2,status
 402bdc0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402bdc4:	e0fff717 	ldw	r3,-36(fp)
 402bdc8:	00bfff84 	movi	r2,-2
 402bdcc:	1884703a 	and	r2,r3,r2
 402bdd0:	1001703a 	wrctl	status,r2
  
  return context;
 402bdd4:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 402bdd8:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 402bddc:	e0bff917 	ldw	r2,-28(fp)
 402bde0:	00c100f4 	movhi	r3,1027
 402bde4:	18c54504 	addi	r3,r3,5396
 402bde8:	100490fa 	slli	r2,r2,3
 402bdec:	10c7883a 	add	r3,r2,r3
 402bdf0:	e0bffd17 	ldw	r2,-12(fp)
 402bdf4:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 402bdf8:	e0bff917 	ldw	r2,-28(fp)
 402bdfc:	00c100f4 	movhi	r3,1027
 402be00:	18c54504 	addi	r3,r3,5396
 402be04:	100490fa 	slli	r2,r2,3
 402be08:	10c5883a 	add	r2,r2,r3
 402be0c:	10c00104 	addi	r3,r2,4
 402be10:	e0bffe17 	ldw	r2,-8(fp)
 402be14:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 402be18:	e0bffd17 	ldw	r2,-12(fp)
 402be1c:	1005003a 	cmpeq	r2,r2,zero
 402be20:	1000051e 	bne	r2,zero,402be38 <alt_iic_isr_register+0xb8>
 402be24:	e17ff917 	ldw	r5,-28(fp)
 402be28:	e13ffb17 	ldw	r4,-20(fp)
 402be2c:	402bbfc0 	call	402bbfc <alt_ic_irq_enable>
 402be30:	e0bfff15 	stw	r2,-4(fp)
 402be34:	00000406 	br	402be48 <alt_iic_isr_register+0xc8>
 402be38:	e17ff917 	ldw	r5,-28(fp)
 402be3c:	e13ffb17 	ldw	r4,-20(fp)
 402be40:	402bc980 	call	402bc98 <alt_ic_irq_disable>
 402be44:	e0bfff15 	stw	r2,-4(fp)
 402be48:	e0bfff17 	ldw	r2,-4(fp)
 402be4c:	e0bffa15 	stw	r2,-24(fp)
 402be50:	e0bff817 	ldw	r2,-32(fp)
 402be54:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402be58:	e0bff617 	ldw	r2,-40(fp)
 402be5c:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 402be60:	e0bffa17 	ldw	r2,-24(fp)
}
 402be64:	e037883a 	mov	sp,fp
 402be68:	dfc00117 	ldw	ra,4(sp)
 402be6c:	df000017 	ldw	fp,0(sp)
 402be70:	dec00204 	addi	sp,sp,8
 402be74:	f800283a 	ret

0402be78 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 402be78:	defff904 	addi	sp,sp,-28
 402be7c:	dfc00615 	stw	ra,24(sp)
 402be80:	df000515 	stw	fp,20(sp)
 402be84:	df000504 	addi	fp,sp,20
 402be88:	e13ffc15 	stw	r4,-16(fp)
 402be8c:	e17ffd15 	stw	r5,-12(fp)
 402be90:	e1bffe15 	stw	r6,-8(fp)
 402be94:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 402be98:	e13ffd17 	ldw	r4,-12(fp)
 402be9c:	e17ffe17 	ldw	r5,-8(fp)
 402bea0:	e1bfff17 	ldw	r6,-4(fp)
 402bea4:	402c0900 	call	402c090 <open>
 402bea8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 402beac:	e0bffb17 	ldw	r2,-20(fp)
 402beb0:	1004803a 	cmplt	r2,r2,zero
 402beb4:	10001c1e 	bne	r2,zero,402bf28 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 402beb8:	e0bffb17 	ldw	r2,-20(fp)
 402bebc:	00c100f4 	movhi	r3,1027
 402bec0:	18fcf904 	addi	r3,r3,-3100
 402bec4:	10800324 	muli	r2,r2,12
 402bec8:	10c5883a 	add	r2,r2,r3
 402becc:	10c00017 	ldw	r3,0(r2)
 402bed0:	e0bffc17 	ldw	r2,-16(fp)
 402bed4:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 402bed8:	e0bffb17 	ldw	r2,-20(fp)
 402bedc:	00c100f4 	movhi	r3,1027
 402bee0:	18fcf904 	addi	r3,r3,-3100
 402bee4:	10800324 	muli	r2,r2,12
 402bee8:	10c5883a 	add	r2,r2,r3
 402beec:	10800104 	addi	r2,r2,4
 402bef0:	10c00017 	ldw	r3,0(r2)
 402bef4:	e0bffc17 	ldw	r2,-16(fp)
 402bef8:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 402befc:	e0bffb17 	ldw	r2,-20(fp)
 402bf00:	00c100f4 	movhi	r3,1027
 402bf04:	18fcf904 	addi	r3,r3,-3100
 402bf08:	10800324 	muli	r2,r2,12
 402bf0c:	10c5883a 	add	r2,r2,r3
 402bf10:	10800204 	addi	r2,r2,8
 402bf14:	10c00017 	ldw	r3,0(r2)
 402bf18:	e0bffc17 	ldw	r2,-16(fp)
 402bf1c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 402bf20:	e13ffb17 	ldw	r4,-20(fp)
 402bf24:	402c2780 	call	402c278 <alt_release_fd>
  }
} 
 402bf28:	e037883a 	mov	sp,fp
 402bf2c:	dfc00117 	ldw	ra,4(sp)
 402bf30:	df000017 	ldw	fp,0(sp)
 402bf34:	dec00204 	addi	sp,sp,8
 402bf38:	f800283a 	ret

0402bf3c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 402bf3c:	defffb04 	addi	sp,sp,-20
 402bf40:	dfc00415 	stw	ra,16(sp)
 402bf44:	df000315 	stw	fp,12(sp)
 402bf48:	df000304 	addi	fp,sp,12
 402bf4c:	e13ffd15 	stw	r4,-12(fp)
 402bf50:	e17ffe15 	stw	r5,-8(fp)
 402bf54:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 402bf58:	010100f4 	movhi	r4,1027
 402bf5c:	213cfc04 	addi	r4,r4,-3088
 402bf60:	e17ffd17 	ldw	r5,-12(fp)
 402bf64:	01800044 	movi	r6,1
 402bf68:	01c07fc4 	movi	r7,511
 402bf6c:	402be780 	call	402be78 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 402bf70:	010100f4 	movhi	r4,1027
 402bf74:	213cf904 	addi	r4,r4,-3100
 402bf78:	e17ffe17 	ldw	r5,-8(fp)
 402bf7c:	000d883a 	mov	r6,zero
 402bf80:	01c07fc4 	movi	r7,511
 402bf84:	402be780 	call	402be78 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 402bf88:	010100f4 	movhi	r4,1027
 402bf8c:	213cff04 	addi	r4,r4,-3076
 402bf90:	e17fff17 	ldw	r5,-4(fp)
 402bf94:	01800044 	movi	r6,1
 402bf98:	01c07fc4 	movi	r7,511
 402bf9c:	402be780 	call	402be78 <alt_open_fd>
}  
 402bfa0:	e037883a 	mov	sp,fp
 402bfa4:	dfc00117 	ldw	ra,4(sp)
 402bfa8:	df000017 	ldw	fp,0(sp)
 402bfac:	dec00204 	addi	sp,sp,8
 402bfb0:	f800283a 	ret

0402bfb4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 402bfb4:	defffc04 	addi	sp,sp,-16
 402bfb8:	df000315 	stw	fp,12(sp)
 402bfbc:	df000304 	addi	fp,sp,12
 402bfc0:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 402bfc4:	e0bffe17 	ldw	r2,-8(fp)
 402bfc8:	10800217 	ldw	r2,8(r2)
 402bfcc:	10d00034 	orhi	r3,r2,16384
 402bfd0:	e0bffe17 	ldw	r2,-8(fp)
 402bfd4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 402bfd8:	e03ffd15 	stw	zero,-12(fp)
 402bfdc:	00002006 	br	402c060 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 402bfe0:	e0bffd17 	ldw	r2,-12(fp)
 402bfe4:	00c100f4 	movhi	r3,1027
 402bfe8:	18fcf904 	addi	r3,r3,-3100
 402bfec:	10800324 	muli	r2,r2,12
 402bff0:	10c5883a 	add	r2,r2,r3
 402bff4:	10c00017 	ldw	r3,0(r2)
 402bff8:	e0bffe17 	ldw	r2,-8(fp)
 402bffc:	10800017 	ldw	r2,0(r2)
 402c000:	1880141e 	bne	r3,r2,402c054 <alt_file_locked+0xa0>
 402c004:	e0bffd17 	ldw	r2,-12(fp)
 402c008:	00c100f4 	movhi	r3,1027
 402c00c:	18fcf904 	addi	r3,r3,-3100
 402c010:	10800324 	muli	r2,r2,12
 402c014:	10c5883a 	add	r2,r2,r3
 402c018:	10800204 	addi	r2,r2,8
 402c01c:	10800017 	ldw	r2,0(r2)
 402c020:	1004403a 	cmpge	r2,r2,zero
 402c024:	10000b1e 	bne	r2,zero,402c054 <alt_file_locked+0xa0>
 402c028:	e0bffd17 	ldw	r2,-12(fp)
 402c02c:	10800324 	muli	r2,r2,12
 402c030:	1007883a 	mov	r3,r2
 402c034:	008100f4 	movhi	r2,1027
 402c038:	10bcf904 	addi	r2,r2,-3100
 402c03c:	1887883a 	add	r3,r3,r2
 402c040:	e0bffe17 	ldw	r2,-8(fp)
 402c044:	18800326 	beq	r3,r2,402c054 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 402c048:	00bffcc4 	movi	r2,-13
 402c04c:	e0bfff15 	stw	r2,-4(fp)
 402c050:	00000a06 	br	402c07c <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 402c054:	e0bffd17 	ldw	r2,-12(fp)
 402c058:	10800044 	addi	r2,r2,1
 402c05c:	e0bffd15 	stw	r2,-12(fp)
 402c060:	008100f4 	movhi	r2,1027
 402c064:	10bd7004 	addi	r2,r2,-2624
 402c068:	10800017 	ldw	r2,0(r2)
 402c06c:	1007883a 	mov	r3,r2
 402c070:	e0bffd17 	ldw	r2,-12(fp)
 402c074:	18bfda2e 	bgeu	r3,r2,402bfe0 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 402c078:	e03fff15 	stw	zero,-4(fp)
 402c07c:	e0bfff17 	ldw	r2,-4(fp)
}
 402c080:	e037883a 	mov	sp,fp
 402c084:	df000017 	ldw	fp,0(sp)
 402c088:	dec00104 	addi	sp,sp,4
 402c08c:	f800283a 	ret

0402c090 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 402c090:	defff404 	addi	sp,sp,-48
 402c094:	dfc00b15 	stw	ra,44(sp)
 402c098:	df000a15 	stw	fp,40(sp)
 402c09c:	df000a04 	addi	fp,sp,40
 402c0a0:	e13ffb15 	stw	r4,-20(fp)
 402c0a4:	e17ffc15 	stw	r5,-16(fp)
 402c0a8:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 402c0ac:	00bfffc4 	movi	r2,-1
 402c0b0:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 402c0b4:	00bffb44 	movi	r2,-19
 402c0b8:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 402c0bc:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 402c0c0:	e13ffb17 	ldw	r4,-20(fp)
 402c0c4:	014100f4 	movhi	r5,1027
 402c0c8:	297d6e04 	addi	r5,r5,-2632
 402c0cc:	402bae80 	call	402bae8 <alt_find_dev>
 402c0d0:	e0bffa15 	stw	r2,-24(fp)
 402c0d4:	e0bffa17 	ldw	r2,-24(fp)
 402c0d8:	1004c03a 	cmpne	r2,r2,zero
 402c0dc:	1000051e 	bne	r2,zero,402c0f4 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 402c0e0:	e13ffb17 	ldw	r4,-20(fp)
 402c0e4:	402cd5c0 	call	402cd5c <alt_find_file>
 402c0e8:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 402c0ec:	00800044 	movi	r2,1
 402c0f0:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 402c0f4:	e0bffa17 	ldw	r2,-24(fp)
 402c0f8:	1005003a 	cmpeq	r2,r2,zero
 402c0fc:	1000301e 	bne	r2,zero,402c1c0 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 402c100:	e13ffa17 	ldw	r4,-24(fp)
 402c104:	402ce7c0 	call	402ce7c <alt_get_fd>
 402c108:	e0bff815 	stw	r2,-32(fp)
 402c10c:	e0bff817 	ldw	r2,-32(fp)
 402c110:	1004403a 	cmpge	r2,r2,zero
 402c114:	1000031e 	bne	r2,zero,402c124 <open+0x94>
    {
      status = index;
 402c118:	e0bff817 	ldw	r2,-32(fp)
 402c11c:	e0bff715 	stw	r2,-36(fp)
 402c120:	00002906 	br	402c1c8 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 402c124:	e0bff817 	ldw	r2,-32(fp)
 402c128:	10800324 	muli	r2,r2,12
 402c12c:	1007883a 	mov	r3,r2
 402c130:	008100f4 	movhi	r2,1027
 402c134:	10bcf904 	addi	r2,r2,-3100
 402c138:	1885883a 	add	r2,r3,r2
 402c13c:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 402c140:	e0fffc17 	ldw	r3,-16(fp)
 402c144:	00900034 	movhi	r2,16384
 402c148:	10bfffc4 	addi	r2,r2,-1
 402c14c:	1886703a 	and	r3,r3,r2
 402c150:	e0bff917 	ldw	r2,-28(fp)
 402c154:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 402c158:	e0bff617 	ldw	r2,-40(fp)
 402c15c:	1004c03a 	cmpne	r2,r2,zero
 402c160:	1000061e 	bne	r2,zero,402c17c <open+0xec>
 402c164:	e13ff917 	ldw	r4,-28(fp)
 402c168:	402bfb40 	call	402bfb4 <alt_file_locked>
 402c16c:	e0bff715 	stw	r2,-36(fp)
 402c170:	e0bff717 	ldw	r2,-36(fp)
 402c174:	1004803a 	cmplt	r2,r2,zero
 402c178:	1000131e 	bne	r2,zero,402c1c8 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 402c17c:	e0bffa17 	ldw	r2,-24(fp)
 402c180:	10800317 	ldw	r2,12(r2)
 402c184:	1005003a 	cmpeq	r2,r2,zero
 402c188:	1000091e 	bne	r2,zero,402c1b0 <open+0x120>
 402c18c:	e0bffa17 	ldw	r2,-24(fp)
 402c190:	10800317 	ldw	r2,12(r2)
 402c194:	e13ff917 	ldw	r4,-28(fp)
 402c198:	e17ffb17 	ldw	r5,-20(fp)
 402c19c:	e1bffc17 	ldw	r6,-16(fp)
 402c1a0:	e1fffd17 	ldw	r7,-12(fp)
 402c1a4:	103ee83a 	callr	r2
 402c1a8:	e0bfff15 	stw	r2,-4(fp)
 402c1ac:	00000106 	br	402c1b4 <open+0x124>
 402c1b0:	e03fff15 	stw	zero,-4(fp)
 402c1b4:	e0bfff17 	ldw	r2,-4(fp)
 402c1b8:	e0bff715 	stw	r2,-36(fp)
 402c1bc:	00000206 	br	402c1c8 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 402c1c0:	00bffb44 	movi	r2,-19
 402c1c4:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 402c1c8:	e0bff717 	ldw	r2,-36(fp)
 402c1cc:	1004403a 	cmpge	r2,r2,zero
 402c1d0:	1000091e 	bne	r2,zero,402c1f8 <open+0x168>
  {
    alt_release_fd (index);  
 402c1d4:	e13ff817 	ldw	r4,-32(fp)
 402c1d8:	402c2780 	call	402c278 <alt_release_fd>
    ALT_ERRNO = -status;
 402c1dc:	402c2180 	call	402c218 <alt_get_errno>
 402c1e0:	e0fff717 	ldw	r3,-36(fp)
 402c1e4:	00c7c83a 	sub	r3,zero,r3
 402c1e8:	10c00015 	stw	r3,0(r2)
    return -1;
 402c1ec:	00bfffc4 	movi	r2,-1
 402c1f0:	e0bffe15 	stw	r2,-8(fp)
 402c1f4:	00000206 	br	402c200 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 402c1f8:	e0bff817 	ldw	r2,-32(fp)
 402c1fc:	e0bffe15 	stw	r2,-8(fp)
 402c200:	e0bffe17 	ldw	r2,-8(fp)
}
 402c204:	e037883a 	mov	sp,fp
 402c208:	dfc00117 	ldw	ra,4(sp)
 402c20c:	df000017 	ldw	fp,0(sp)
 402c210:	dec00204 	addi	sp,sp,8
 402c214:	f800283a 	ret

0402c218 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 402c218:	defffd04 	addi	sp,sp,-12
 402c21c:	dfc00215 	stw	ra,8(sp)
 402c220:	df000115 	stw	fp,4(sp)
 402c224:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 402c228:	008100f4 	movhi	r2,1027
 402c22c:	10bd7104 	addi	r2,r2,-2620
 402c230:	10800017 	ldw	r2,0(r2)
 402c234:	1005003a 	cmpeq	r2,r2,zero
 402c238:	1000061e 	bne	r2,zero,402c254 <alt_get_errno+0x3c>
 402c23c:	008100f4 	movhi	r2,1027
 402c240:	10bd7104 	addi	r2,r2,-2620
 402c244:	10800017 	ldw	r2,0(r2)
 402c248:	103ee83a 	callr	r2
 402c24c:	e0bfff15 	stw	r2,-4(fp)
 402c250:	00000306 	br	402c260 <alt_get_errno+0x48>
 402c254:	008100f4 	movhi	r2,1027
 402c258:	10842204 	addi	r2,r2,4232
 402c25c:	e0bfff15 	stw	r2,-4(fp)
 402c260:	e0bfff17 	ldw	r2,-4(fp)
}
 402c264:	e037883a 	mov	sp,fp
 402c268:	dfc00117 	ldw	ra,4(sp)
 402c26c:	df000017 	ldw	fp,0(sp)
 402c270:	dec00204 	addi	sp,sp,8
 402c274:	f800283a 	ret

0402c278 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 402c278:	defffe04 	addi	sp,sp,-8
 402c27c:	df000115 	stw	fp,4(sp)
 402c280:	df000104 	addi	fp,sp,4
 402c284:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 402c288:	e0bfff17 	ldw	r2,-4(fp)
 402c28c:	108000d0 	cmplti	r2,r2,3
 402c290:	10000d1e 	bne	r2,zero,402c2c8 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 402c294:	e0bfff17 	ldw	r2,-4(fp)
 402c298:	00c100f4 	movhi	r3,1027
 402c29c:	18fcf904 	addi	r3,r3,-3100
 402c2a0:	10800324 	muli	r2,r2,12
 402c2a4:	10c5883a 	add	r2,r2,r3
 402c2a8:	10800204 	addi	r2,r2,8
 402c2ac:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 402c2b0:	e0bfff17 	ldw	r2,-4(fp)
 402c2b4:	00c100f4 	movhi	r3,1027
 402c2b8:	18fcf904 	addi	r3,r3,-3100
 402c2bc:	10800324 	muli	r2,r2,12
 402c2c0:	10c5883a 	add	r2,r2,r3
 402c2c4:	10000015 	stw	zero,0(r2)
  }
}
 402c2c8:	e037883a 	mov	sp,fp
 402c2cc:	df000017 	ldw	fp,0(sp)
 402c2d0:	dec00104 	addi	sp,sp,4
 402c2d4:	f800283a 	ret

0402c2d8 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 402c2d8:	defffa04 	addi	sp,sp,-24
 402c2dc:	df000515 	stw	fp,20(sp)
 402c2e0:	df000504 	addi	fp,sp,20
 402c2e4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 402c2e8:	0005303a 	rdctl	r2,status
 402c2ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 402c2f0:	e0fffd17 	ldw	r3,-12(fp)
 402c2f4:	00bfff84 	movi	r2,-2
 402c2f8:	1884703a 	and	r2,r3,r2
 402c2fc:	1001703a 	wrctl	status,r2
  
  return context;
 402c300:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 402c304:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 402c308:	e0bfff17 	ldw	r2,-4(fp)
 402c30c:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 402c310:	e0bffc17 	ldw	r2,-16(fp)
 402c314:	10c00017 	ldw	r3,0(r2)
 402c318:	e0bffc17 	ldw	r2,-16(fp)
 402c31c:	10800117 	ldw	r2,4(r2)
 402c320:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 402c324:	e0bffc17 	ldw	r2,-16(fp)
 402c328:	10c00117 	ldw	r3,4(r2)
 402c32c:	e0bffc17 	ldw	r2,-16(fp)
 402c330:	10800017 	ldw	r2,0(r2)
 402c334:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 402c338:	e0fffc17 	ldw	r3,-16(fp)
 402c33c:	e0bffc17 	ldw	r2,-16(fp)
 402c340:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 402c344:	e0fffc17 	ldw	r3,-16(fp)
 402c348:	e0bffc17 	ldw	r2,-16(fp)
 402c34c:	18800015 	stw	r2,0(r3)
 402c350:	e0bffe17 	ldw	r2,-8(fp)
 402c354:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 402c358:	e0bffb17 	ldw	r2,-20(fp)
 402c35c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 402c360:	e037883a 	mov	sp,fp
 402c364:	df000017 	ldw	fp,0(sp)
 402c368:	dec00104 	addi	sp,sp,4
 402c36c:	f800283a 	ret

0402c370 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 402c370:	defffb04 	addi	sp,sp,-20
 402c374:	dfc00415 	stw	ra,16(sp)
 402c378:	df000315 	stw	fp,12(sp)
 402c37c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 402c380:	d0a01a17 	ldw	r2,-32664(gp)
 402c384:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 402c388:	d0a6d117 	ldw	r2,-25788(gp)
 402c38c:	10800044 	addi	r2,r2,1
 402c390:	d0a6d115 	stw	r2,-25788(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 402c394:	00003106 	br	402c45c <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 402c398:	e0bffe17 	ldw	r2,-8(fp)
 402c39c:	10800017 	ldw	r2,0(r2)
 402c3a0:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 402c3a4:	e0bffe17 	ldw	r2,-8(fp)
 402c3a8:	10800403 	ldbu	r2,16(r2)
 402c3ac:	10803fcc 	andi	r2,r2,255
 402c3b0:	1005003a 	cmpeq	r2,r2,zero
 402c3b4:	1000051e 	bne	r2,zero,402c3cc <alt_tick+0x5c>
 402c3b8:	d0a6d117 	ldw	r2,-25788(gp)
 402c3bc:	1004c03a 	cmpne	r2,r2,zero
 402c3c0:	1000021e 	bne	r2,zero,402c3cc <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 402c3c4:	e0bffe17 	ldw	r2,-8(fp)
 402c3c8:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 402c3cc:	e0bffe17 	ldw	r2,-8(fp)
 402c3d0:	10c00217 	ldw	r3,8(r2)
 402c3d4:	d0a6d117 	ldw	r2,-25788(gp)
 402c3d8:	10c01e36 	bltu	r2,r3,402c454 <alt_tick+0xe4>
 402c3dc:	e0bffe17 	ldw	r2,-8(fp)
 402c3e0:	10800403 	ldbu	r2,16(r2)
 402c3e4:	10803fcc 	andi	r2,r2,255
 402c3e8:	1004c03a 	cmpne	r2,r2,zero
 402c3ec:	1000191e 	bne	r2,zero,402c454 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 402c3f0:	e0bffe17 	ldw	r2,-8(fp)
 402c3f4:	10c00317 	ldw	r3,12(r2)
 402c3f8:	e0bffe17 	ldw	r2,-8(fp)
 402c3fc:	11000517 	ldw	r4,20(r2)
 402c400:	183ee83a 	callr	r3
 402c404:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 402c408:	e0bffd17 	ldw	r2,-12(fp)
 402c40c:	1004c03a 	cmpne	r2,r2,zero
 402c410:	1000031e 	bne	r2,zero,402c420 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 402c414:	e13ffe17 	ldw	r4,-8(fp)
 402c418:	402c2d80 	call	402c2d8 <alt_alarm_stop>
 402c41c:	00000d06 	br	402c454 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 402c420:	e0bffe17 	ldw	r2,-8(fp)
 402c424:	10c00217 	ldw	r3,8(r2)
 402c428:	e0bffd17 	ldw	r2,-12(fp)
 402c42c:	1887883a 	add	r3,r3,r2
 402c430:	e0bffe17 	ldw	r2,-8(fp)
 402c434:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 402c438:	e0bffe17 	ldw	r2,-8(fp)
 402c43c:	10c00217 	ldw	r3,8(r2)
 402c440:	d0a6d117 	ldw	r2,-25788(gp)
 402c444:	1880032e 	bgeu	r3,r2,402c454 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 402c448:	e0fffe17 	ldw	r3,-8(fp)
 402c44c:	00800044 	movi	r2,1
 402c450:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 402c454:	e0bfff17 	ldw	r2,-4(fp)
 402c458:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 402c45c:	d0e01a04 	addi	r3,gp,-32664
 402c460:	e0bffe17 	ldw	r2,-8(fp)
 402c464:	10ffcc1e 	bne	r2,r3,402c398 <alt_tick+0x28>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 402c468:	e037883a 	mov	sp,fp
 402c46c:	dfc00117 	ldw	ra,4(sp)
 402c470:	df000017 	ldw	fp,0(sp)
 402c474:	dec00204 	addi	sp,sp,8
 402c478:	f800283a 	ret

0402c47c <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 402c47c:	deffff04 	addi	sp,sp,-4
 402c480:	df000015 	stw	fp,0(sp)
 402c484:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 402c488:	000170fa 	wrctl	ienable,zero
}
 402c48c:	e037883a 	mov	sp,fp
 402c490:	df000017 	ldw	fp,0(sp)
 402c494:	dec00104 	addi	sp,sp,4
 402c498:	f800283a 	ret

0402c49c <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 402c49c:	defff704 	addi	sp,sp,-36
 402c4a0:	dfc00815 	stw	ra,32(sp)
 402c4a4:	df000715 	stw	fp,28(sp)
 402c4a8:	df000704 	addi	fp,sp,28
 402c4ac:	e13ffc15 	stw	r4,-16(fp)
 402c4b0:	e17ffd15 	stw	r5,-12(fp)
 402c4b4:	e1bffe15 	stw	r6,-8(fp)
 402c4b8:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 402c4bc:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 402c4c0:	e0bffc17 	ldw	r2,-16(fp)
 402c4c4:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 402c4c8:	e1bfff17 	ldw	r6,-4(fp)
 402c4cc:	008100f4 	movhi	r2,1027
 402c4d0:	10b21004 	addi	r2,r2,-14272
 402c4d4:	d8800015 	stw	r2,0(sp)
 402c4d8:	e13ffa17 	ldw	r4,-24(fp)
 402c4dc:	e17ffe17 	ldw	r5,-8(fp)
 402c4e0:	e1c00217 	ldw	r7,8(fp)
 402c4e4:	4028e840 	call	4028e84 <alt_flash_program_block>
 402c4e8:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 402c4ec:	e0bffb17 	ldw	r2,-20(fp)
}
 402c4f0:	e037883a 	mov	sp,fp
 402c4f4:	dfc00117 	ldw	ra,4(sp)
 402c4f8:	df000017 	ldw	fp,0(sp)
 402c4fc:	dec00204 	addi	sp,sp,8
 402c500:	f800283a 	ret

0402c504 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 402c504:	defff804 	addi	sp,sp,-32
 402c508:	dfc00715 	stw	ra,28(sp)
 402c50c:	df000615 	stw	fp,24(sp)
 402c510:	df000604 	addi	fp,sp,24
 402c514:	e13ffe15 	stw	r4,-8(fp)
 402c518:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 402c51c:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 402c520:	e0bffe17 	ldw	r2,-8(fp)
 402c524:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 402c528:	e0bffa17 	ldw	r2,-24(fp)
 402c52c:	10c03317 	ldw	r3,204(r2)
 402c530:	e0bffa17 	ldw	r2,-24(fp)
 402c534:	11000a17 	ldw	r4,40(r2)
 402c538:	01415544 	movi	r5,1365
 402c53c:	01802a84 	movi	r6,170
 402c540:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 402c544:	e0bffa17 	ldw	r2,-24(fp)
 402c548:	10c03317 	ldw	r3,204(r2)
 402c54c:	e0bffa17 	ldw	r2,-24(fp)
 402c550:	11000a17 	ldw	r4,40(r2)
 402c554:	0140aa84 	movi	r5,682
 402c558:	01801544 	movi	r6,85
 402c55c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 402c560:	e0bffa17 	ldw	r2,-24(fp)
 402c564:	10c03317 	ldw	r3,204(r2)
 402c568:	e0bffa17 	ldw	r2,-24(fp)
 402c56c:	11000a17 	ldw	r4,40(r2)
 402c570:	01415544 	movi	r5,1365
 402c574:	01802004 	movi	r6,128
 402c578:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 402c57c:	e0bffa17 	ldw	r2,-24(fp)
 402c580:	10c03317 	ldw	r3,204(r2)
 402c584:	e0bffa17 	ldw	r2,-24(fp)
 402c588:	11000a17 	ldw	r4,40(r2)
 402c58c:	01415544 	movi	r5,1365
 402c590:	01802a84 	movi	r6,170
 402c594:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 402c598:	e0bffa17 	ldw	r2,-24(fp)
 402c59c:	10c03317 	ldw	r3,204(r2)
 402c5a0:	e0bffa17 	ldw	r2,-24(fp)
 402c5a4:	11000a17 	ldw	r4,40(r2)
 402c5a8:	0140aa84 	movi	r5,682
 402c5ac:	01801544 	movi	r6,85
 402c5b0:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 402c5b4:	e0bffa17 	ldw	r2,-24(fp)
 402c5b8:	11803517 	ldw	r6,212(r2)
 402c5bc:	e0bffa17 	ldw	r2,-24(fp)
 402c5c0:	10800a17 	ldw	r2,40(r2)
 402c5c4:	1007883a 	mov	r3,r2
 402c5c8:	e0bfff17 	ldw	r2,-4(fp)
 402c5cc:	1889883a 	add	r4,r3,r2
 402c5d0:	01400c04 	movi	r5,48
 402c5d4:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 402c5d8:	0109c404 	movi	r4,10000
 402c5dc:	40285e80 	call	40285e8 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 402c5e0:	00800c84 	movi	r2,50
 402c5e4:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 402c5e8:	e0bffa17 	ldw	r2,-24(fp)
 402c5ec:	10800a17 	ldw	r2,40(r2)
 402c5f0:	1007883a 	mov	r3,r2
 402c5f4:	e0bfff17 	ldw	r2,-4(fp)
 402c5f8:	1885883a 	add	r2,r3,r2
 402c5fc:	10800023 	ldbuio	r2,0(r2)
 402c600:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 402c604:	0100fa04 	movi	r4,1000
 402c608:	40285e80 	call	40285e8 <usleep>
    timeout--;
 402c60c:	e0bffb17 	ldw	r2,-20(fp)
 402c610:	10bfffc4 	addi	r2,r2,-1
 402c614:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 402c618:	e0bffd03 	ldbu	r2,-12(fp)
 402c61c:	10803fcc 	andi	r2,r2,255
 402c620:	1080020c 	andi	r2,r2,8
 402c624:	1004c03a 	cmpne	r2,r2,zero
 402c628:	1000031e 	bne	r2,zero,402c638 <alt_erase_block_amd+0x134>
 402c62c:	e0bffb17 	ldw	r2,-20(fp)
 402c630:	10800048 	cmpgei	r2,r2,1
 402c634:	103fec1e 	bne	r2,zero,402c5e8 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 402c638:	e0bffa17 	ldw	r2,-24(fp)
 402c63c:	10803117 	ldw	r2,196(r2)
 402c640:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 402c644:	00001706 	br	402c6a4 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 402c648:	e0bffa17 	ldw	r2,-24(fp)
 402c64c:	10800a17 	ldw	r2,40(r2)
 402c650:	1007883a 	mov	r3,r2
 402c654:	e0bfff17 	ldw	r2,-4(fp)
 402c658:	1885883a 	add	r2,r3,r2
 402c65c:	10800023 	ldbuio	r2,0(r2)
 402c660:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 402c664:	e0bffd03 	ldbu	r2,-12(fp)
 402c668:	10803fcc 	andi	r2,r2,255
 402c66c:	1080201c 	xori	r2,r2,128
 402c670:	10bfe004 	addi	r2,r2,-128
 402c674:	1004803a 	cmplt	r2,r2,zero
 402c678:	10000d1e 	bne	r2,zero,402c6b0 <alt_erase_block_amd+0x1ac>
 402c67c:	e0bffd03 	ldbu	r2,-12(fp)
 402c680:	10803fcc 	andi	r2,r2,255
 402c684:	1080080c 	andi	r2,r2,32
 402c688:	1004c03a 	cmpne	r2,r2,zero
 402c68c:	1000081e 	bne	r2,zero,402c6b0 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 402c690:	0100fa04 	movi	r4,1000
 402c694:	40285e80 	call	40285e8 <usleep>
    timeout -= 1000;
 402c698:	e0bffb17 	ldw	r2,-20(fp)
 402c69c:	10bf0604 	addi	r2,r2,-1000
 402c6a0:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 402c6a4:	e0bffb17 	ldw	r2,-20(fp)
 402c6a8:	10800048 	cmpgei	r2,r2,1
 402c6ac:	103fe61e 	bne	r2,zero,402c648 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 402c6b0:	e0bffb17 	ldw	r2,-20(fp)
 402c6b4:	10800048 	cmpgei	r2,r2,1
 402c6b8:	1000031e 	bne	r2,zero,402c6c8 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 402c6bc:	00bfe304 	movi	r2,-116
 402c6c0:	e0bffc15 	stw	r2,-16(fp)
 402c6c4:	00000f06 	br	402c704 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 402c6c8:	e0bffa17 	ldw	r2,-24(fp)
 402c6cc:	10800a17 	ldw	r2,40(r2)
 402c6d0:	1007883a 	mov	r3,r2
 402c6d4:	e0bfff17 	ldw	r2,-4(fp)
 402c6d8:	1885883a 	add	r2,r3,r2
 402c6dc:	10800023 	ldbuio	r2,0(r2)
 402c6e0:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 402c6e4:	e0bffd03 	ldbu	r2,-12(fp)
 402c6e8:	10803fcc 	andi	r2,r2,255
 402c6ec:	1080201c 	xori	r2,r2,128
 402c6f0:	10bfe004 	addi	r2,r2,-128
 402c6f4:	1004803a 	cmplt	r2,r2,zero
 402c6f8:	1000021e 	bne	r2,zero,402c704 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 402c6fc:	00bffec4 	movi	r2,-5
 402c700:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 402c704:	e0bffc17 	ldw	r2,-16(fp)
}
 402c708:	e037883a 	mov	sp,fp
 402c70c:	dfc00117 	ldw	ra,4(sp)
 402c710:	df000017 	ldw	fp,0(sp)
 402c714:	dec00204 	addi	sp,sp,8
 402c718:	f800283a 	ret

0402c71c <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 402c71c:	defff804 	addi	sp,sp,-32
 402c720:	dfc00715 	stw	ra,28(sp)
 402c724:	df000615 	stw	fp,24(sp)
 402c728:	df000604 	addi	fp,sp,24
 402c72c:	e13ffd15 	stw	r4,-12(fp)
 402c730:	e17ffe15 	stw	r5,-8(fp)
 402c734:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 402c738:	e0bffd17 	ldw	r2,-12(fp)
 402c73c:	10803017 	ldw	r2,192(r2)
 402c740:	10801924 	muli	r2,r2,100
 402c744:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 402c748:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 402c74c:	e0bffd17 	ldw	r2,-12(fp)
 402c750:	10800a17 	ldw	r2,40(r2)
 402c754:	1007883a 	mov	r3,r2
 402c758:	e0bffe17 	ldw	r2,-8(fp)
 402c75c:	1885883a 	add	r2,r3,r2
 402c760:	10800023 	ldbuio	r2,0(r2)
 402c764:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 402c768:	00001706 	br	402c7c8 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 402c76c:	e0bffc03 	ldbu	r2,-16(fp)
 402c770:	10803fcc 	andi	r2,r2,255
 402c774:	10c0200c 	andi	r3,r2,128
 402c778:	e0bfff03 	ldbu	r2,-4(fp)
 402c77c:	1080200c 	andi	r2,r2,128
 402c780:	18801426 	beq	r3,r2,402c7d4 <alt_wait_for_command_to_complete_amd+0xb8>
 402c784:	e0bffc03 	ldbu	r2,-16(fp)
 402c788:	10803fcc 	andi	r2,r2,255
 402c78c:	1080080c 	andi	r2,r2,32
 402c790:	1004c03a 	cmpne	r2,r2,zero
 402c794:	10000f1e 	bne	r2,zero,402c7d4 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 402c798:	01000044 	movi	r4,1
 402c79c:	40285e80 	call	40285e8 <usleep>
    timeout--;
 402c7a0:	e0bffb17 	ldw	r2,-20(fp)
 402c7a4:	10bfffc4 	addi	r2,r2,-1
 402c7a8:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 402c7ac:	e0bffd17 	ldw	r2,-12(fp)
 402c7b0:	10800a17 	ldw	r2,40(r2)
 402c7b4:	1007883a 	mov	r3,r2
 402c7b8:	e0bffe17 	ldw	r2,-8(fp)
 402c7bc:	1885883a 	add	r2,r3,r2
 402c7c0:	10800023 	ldbuio	r2,0(r2)
 402c7c4:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 402c7c8:	e0bffb17 	ldw	r2,-20(fp)
 402c7cc:	10800048 	cmpgei	r2,r2,1
 402c7d0:	103fe61e 	bne	r2,zero,402c76c <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 402c7d4:	e0bffb17 	ldw	r2,-20(fp)
 402c7d8:	1004c03a 	cmpne	r2,r2,zero
 402c7dc:	1000031e 	bne	r2,zero,402c7ec <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 402c7e0:	00bfe304 	movi	r2,-116
 402c7e4:	e0bffa15 	stw	r2,-24(fp)
 402c7e8:	00000f06 	br	402c828 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 402c7ec:	e0bffd17 	ldw	r2,-12(fp)
 402c7f0:	10800a17 	ldw	r2,40(r2)
 402c7f4:	1007883a 	mov	r3,r2
 402c7f8:	e0bffe17 	ldw	r2,-8(fp)
 402c7fc:	1885883a 	add	r2,r3,r2
 402c800:	10800023 	ldbuio	r2,0(r2)
 402c804:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 402c808:	e0bffc03 	ldbu	r2,-16(fp)
 402c80c:	10803fcc 	andi	r2,r2,255
 402c810:	10c0200c 	andi	r3,r2,128
 402c814:	e0bfff03 	ldbu	r2,-4(fp)
 402c818:	1080200c 	andi	r2,r2,128
 402c81c:	18800226 	beq	r3,r2,402c828 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 402c820:	00bffec4 	movi	r2,-5
 402c824:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 402c828:	e0bffa17 	ldw	r2,-24(fp)
}
 402c82c:	e037883a 	mov	sp,fp
 402c830:	dfc00117 	ldw	ra,4(sp)
 402c834:	df000017 	ldw	fp,0(sp)
 402c838:	dec00204 	addi	sp,sp,8
 402c83c:	f800283a 	ret

0402c840 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 402c840:	defff904 	addi	sp,sp,-28
 402c844:	dfc00615 	stw	ra,24(sp)
 402c848:	df000515 	stw	fp,20(sp)
 402c84c:	df000504 	addi	fp,sp,20
 402c850:	e13ffd15 	stw	r4,-12(fp)
 402c854:	e17ffe15 	stw	r5,-8(fp)
 402c858:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 402c85c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 402c860:	e0bffd17 	ldw	r2,-12(fp)
 402c864:	10c03317 	ldw	r3,204(r2)
 402c868:	e0bffd17 	ldw	r2,-12(fp)
 402c86c:	11000a17 	ldw	r4,40(r2)
 402c870:	01415544 	movi	r5,1365
 402c874:	01802a84 	movi	r6,170
 402c878:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 402c87c:	e0bffd17 	ldw	r2,-12(fp)
 402c880:	10c03317 	ldw	r3,204(r2)
 402c884:	e0bffd17 	ldw	r2,-12(fp)
 402c888:	11000a17 	ldw	r4,40(r2)
 402c88c:	0140aa84 	movi	r5,682
 402c890:	01801544 	movi	r6,85
 402c894:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 402c898:	e0bffd17 	ldw	r2,-12(fp)
 402c89c:	10c03317 	ldw	r3,204(r2)
 402c8a0:	e0bffd17 	ldw	r2,-12(fp)
 402c8a4:	11000a17 	ldw	r4,40(r2)
 402c8a8:	01415544 	movi	r5,1365
 402c8ac:	01802804 	movi	r6,160
 402c8b0:	183ee83a 	callr	r3
  
  value = *src_addr;
 402c8b4:	e0bfff17 	ldw	r2,-4(fp)
 402c8b8:	10800003 	ldbu	r2,0(r2)
 402c8bc:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 402c8c0:	e13ffd17 	ldw	r4,-12(fp)
 402c8c4:	e17ffe17 	ldw	r5,-8(fp)
 402c8c8:	e1bfff17 	ldw	r6,-4(fp)
 402c8cc:	4028d200 	call	4028d20 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 402c8d0:	e1bffb03 	ldbu	r6,-20(fp)
 402c8d4:	e13ffd17 	ldw	r4,-12(fp)
 402c8d8:	e17ffe17 	ldw	r5,-8(fp)
 402c8dc:	402c71c0 	call	402c71c <alt_wait_for_command_to_complete_amd>
 402c8e0:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 402c8e4:	e0bffc17 	ldw	r2,-16(fp)
  
}
 402c8e8:	e037883a 	mov	sp,fp
 402c8ec:	dfc00117 	ldw	ra,4(sp)
 402c8f0:	df000017 	ldw	fp,0(sp)
 402c8f4:	dec00204 	addi	sp,sp,8
 402c8f8:	f800283a 	ret

0402c8fc <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 402c8fc:	defff704 	addi	sp,sp,-36
 402c900:	dfc00815 	stw	ra,32(sp)
 402c904:	df000715 	stw	fp,28(sp)
 402c908:	df000704 	addi	fp,sp,28
 402c90c:	e13ffc15 	stw	r4,-16(fp)
 402c910:	e17ffd15 	stw	r5,-12(fp)
 402c914:	e1bffe15 	stw	r6,-8(fp)
 402c918:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 402c91c:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 402c920:	e0bffc17 	ldw	r2,-16(fp)
 402c924:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 402c928:	e13ffa17 	ldw	r4,-24(fp)
 402c92c:	e17ffd17 	ldw	r5,-12(fp)
 402c930:	402caf40 	call	402caf4 <alt_unlock_block_intel>
 402c934:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 402c938:	e0bffb17 	ldw	r2,-20(fp)
 402c93c:	1004c03a 	cmpne	r2,r2,zero
 402c940:	1000091e 	bne	r2,zero,402c968 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 402c944:	e1bfff17 	ldw	r6,-4(fp)
 402c948:	008100f4 	movhi	r2,1027
 402c94c:	10b32004 	addi	r2,r2,-13184
 402c950:	d8800015 	stw	r2,0(sp)
 402c954:	e13ffa17 	ldw	r4,-24(fp)
 402c958:	e17ffe17 	ldw	r5,-8(fp)
 402c95c:	e1c00217 	ldw	r7,8(fp)
 402c960:	4028e840 	call	4028e84 <alt_flash_program_block>
 402c964:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 402c968:	e0bffb17 	ldw	r2,-20(fp)
}
 402c96c:	e037883a 	mov	sp,fp
 402c970:	dfc00117 	ldw	ra,4(sp)
 402c974:	df000017 	ldw	fp,0(sp)
 402c978:	dec00204 	addi	sp,sp,8
 402c97c:	f800283a 	ret

0402c980 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 402c980:	defff804 	addi	sp,sp,-32
 402c984:	dfc00715 	stw	ra,28(sp)
 402c988:	df000615 	stw	fp,24(sp)
 402c98c:	df000604 	addi	fp,sp,24
 402c990:	e13ffe15 	stw	r4,-8(fp)
 402c994:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 402c998:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 402c99c:	e0bffe17 	ldw	r2,-8(fp)
 402c9a0:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 402c9a4:	e0bffb17 	ldw	r2,-20(fp)
 402c9a8:	10803117 	ldw	r2,196(r2)
 402c9ac:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 402c9b0:	e13ffb17 	ldw	r4,-20(fp)
 402c9b4:	e17fff17 	ldw	r5,-4(fp)
 402c9b8:	402caf40 	call	402caf4 <alt_unlock_block_intel>
 402c9bc:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 402c9c0:	e0bffc17 	ldw	r2,-16(fp)
 402c9c4:	1004c03a 	cmpne	r2,r2,zero
 402c9c8:	1000441e 	bne	r2,zero,402cadc <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 402c9cc:	e0bffb17 	ldw	r2,-20(fp)
 402c9d0:	11803517 	ldw	r6,212(r2)
 402c9d4:	e0bffb17 	ldw	r2,-20(fp)
 402c9d8:	10800a17 	ldw	r2,40(r2)
 402c9dc:	1007883a 	mov	r3,r2
 402c9e0:	e0bfff17 	ldw	r2,-4(fp)
 402c9e4:	1889883a 	add	r4,r3,r2
 402c9e8:	01400804 	movi	r5,32
 402c9ec:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 402c9f0:	e0bffb17 	ldw	r2,-20(fp)
 402c9f4:	11803517 	ldw	r6,212(r2)
 402c9f8:	e0bffb17 	ldw	r2,-20(fp)
 402c9fc:	10800a17 	ldw	r2,40(r2)
 402ca00:	1007883a 	mov	r3,r2
 402ca04:	e0bfff17 	ldw	r2,-4(fp)
 402ca08:	1889883a 	add	r4,r3,r2
 402ca0c:	01403404 	movi	r5,208
 402ca10:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 402ca14:	e0bffb17 	ldw	r2,-20(fp)
 402ca18:	10800a17 	ldw	r2,40(r2)
 402ca1c:	1007883a 	mov	r3,r2
 402ca20:	e0bfff17 	ldw	r2,-4(fp)
 402ca24:	1885883a 	add	r2,r3,r2
 402ca28:	10800023 	ldbuio	r2,0(r2)
 402ca2c:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 402ca30:	e0bffd03 	ldbu	r2,-12(fp)
 402ca34:	10803fcc 	andi	r2,r2,255
 402ca38:	1080201c 	xori	r2,r2,128
 402ca3c:	10bfe004 	addi	r2,r2,-128
 402ca40:	1004803a 	cmplt	r2,r2,zero
 402ca44:	1000081e 	bne	r2,zero,402ca68 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 402ca48:	0100fa04 	movi	r4,1000
 402ca4c:	40285e80 	call	40285e8 <usleep>
      timeout -= 1000;
 402ca50:	e0bffa17 	ldw	r2,-24(fp)
 402ca54:	10bf0604 	addi	r2,r2,-1000
 402ca58:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 402ca5c:	e0bffa17 	ldw	r2,-24(fp)
 402ca60:	10800048 	cmpgei	r2,r2,1
 402ca64:	103feb1e 	bne	r2,zero,402ca14 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 402ca68:	e0bffa17 	ldw	r2,-24(fp)
 402ca6c:	10800048 	cmpgei	r2,r2,1
 402ca70:	1000031e 	bne	r2,zero,402ca80 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 402ca74:	00bfe304 	movi	r2,-116
 402ca78:	e0bffc15 	stw	r2,-16(fp)
 402ca7c:	00000e06 	br	402cab8 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 402ca80:	e0bffd03 	ldbu	r2,-12(fp)
 402ca84:	10803fcc 	andi	r2,r2,255
 402ca88:	10801fcc 	andi	r2,r2,127
 402ca8c:	1005003a 	cmpeq	r2,r2,zero
 402ca90:	1000091e 	bne	r2,zero,402cab8 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 402ca94:	00bffec4 	movi	r2,-5
 402ca98:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 402ca9c:	e0bffb17 	ldw	r2,-20(fp)
 402caa0:	10800a17 	ldw	r2,40(r2)
 402caa4:	1007883a 	mov	r3,r2
 402caa8:	e0bfff17 	ldw	r2,-4(fp)
 402caac:	1885883a 	add	r2,r3,r2
 402cab0:	10800023 	ldbuio	r2,0(r2)
 402cab4:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 402cab8:	e0bffb17 	ldw	r2,-20(fp)
 402cabc:	11803517 	ldw	r6,212(r2)
 402cac0:	e0bffb17 	ldw	r2,-20(fp)
 402cac4:	10800a17 	ldw	r2,40(r2)
 402cac8:	1007883a 	mov	r3,r2
 402cacc:	e0bfff17 	ldw	r2,-4(fp)
 402cad0:	1889883a 	add	r4,r3,r2
 402cad4:	01403fc4 	movi	r5,255
 402cad8:	303ee83a 	callr	r6
  }
  
  return ret_code;
 402cadc:	e0bffc17 	ldw	r2,-16(fp)
}
 402cae0:	e037883a 	mov	sp,fp
 402cae4:	dfc00117 	ldw	ra,4(sp)
 402cae8:	df000017 	ldw	fp,0(sp)
 402caec:	dec00204 	addi	sp,sp,8
 402caf0:	f800283a 	ret

0402caf4 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 402caf4:	defff904 	addi	sp,sp,-28
 402caf8:	dfc00615 	stw	ra,24(sp)
 402cafc:	df000515 	stw	fp,20(sp)
 402cb00:	df000504 	addi	fp,sp,20
 402cb04:	e13ffe15 	stw	r4,-8(fp)
 402cb08:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 402cb0c:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 402cb10:	e0bffe17 	ldw	r2,-8(fp)
 402cb14:	10803017 	ldw	r2,192(r2)
 402cb18:	10801924 	muli	r2,r2,100
 402cb1c:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 402cb20:	e0bffe17 	ldw	r2,-8(fp)
 402cb24:	11803517 	ldw	r6,212(r2)
 402cb28:	e0bffe17 	ldw	r2,-8(fp)
 402cb2c:	10800a17 	ldw	r2,40(r2)
 402cb30:	1007883a 	mov	r3,r2
 402cb34:	e0bfff17 	ldw	r2,-4(fp)
 402cb38:	1889883a 	add	r4,r3,r2
 402cb3c:	01402404 	movi	r5,144
 402cb40:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 402cb44:	e0bffe17 	ldw	r2,-8(fp)
 402cb48:	10800a17 	ldw	r2,40(r2)
 402cb4c:	1007883a 	mov	r3,r2
 402cb50:	e0bfff17 	ldw	r2,-4(fp)
 402cb54:	1885883a 	add	r2,r3,r2
 402cb58:	10800104 	addi	r2,r2,4
 402cb5c:	10800023 	ldbuio	r2,0(r2)
 402cb60:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 402cb64:	e0bffd43 	ldbu	r2,-11(fp)
 402cb68:	1080004c 	andi	r2,r2,1
 402cb6c:	10803fcc 	andi	r2,r2,255
 402cb70:	1005003a 	cmpeq	r2,r2,zero
 402cb74:	1000331e 	bne	r2,zero,402cc44 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 402cb78:	e0bffe17 	ldw	r2,-8(fp)
 402cb7c:	11803517 	ldw	r6,212(r2)
 402cb80:	e0bffe17 	ldw	r2,-8(fp)
 402cb84:	10800a17 	ldw	r2,40(r2)
 402cb88:	1007883a 	mov	r3,r2
 402cb8c:	e0bfff17 	ldw	r2,-4(fp)
 402cb90:	1889883a 	add	r4,r3,r2
 402cb94:	01401804 	movi	r5,96
 402cb98:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 402cb9c:	e0bffe17 	ldw	r2,-8(fp)
 402cba0:	11803517 	ldw	r6,212(r2)
 402cba4:	e0bffe17 	ldw	r2,-8(fp)
 402cba8:	10800a17 	ldw	r2,40(r2)
 402cbac:	1007883a 	mov	r3,r2
 402cbb0:	e0bfff17 	ldw	r2,-4(fp)
 402cbb4:	1889883a 	add	r4,r3,r2
 402cbb8:	01403404 	movi	r5,208
 402cbbc:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 402cbc0:	e0bffe17 	ldw	r2,-8(fp)
 402cbc4:	10800a17 	ldw	r2,40(r2)
 402cbc8:	1007883a 	mov	r3,r2
 402cbcc:	e0bfff17 	ldw	r2,-4(fp)
 402cbd0:	1885883a 	add	r2,r3,r2
 402cbd4:	10800023 	ldbuio	r2,0(r2)
 402cbd8:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 402cbdc:	e0bffd03 	ldbu	r2,-12(fp)
 402cbe0:	10803fcc 	andi	r2,r2,255
 402cbe4:	1080201c 	xori	r2,r2,128
 402cbe8:	10bfe004 	addi	r2,r2,-128
 402cbec:	1004803a 	cmplt	r2,r2,zero
 402cbf0:	1000081e 	bne	r2,zero,402cc14 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 402cbf4:	e0bffb17 	ldw	r2,-20(fp)
 402cbf8:	10bfffc4 	addi	r2,r2,-1
 402cbfc:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 402cc00:	01000044 	movi	r4,1
 402cc04:	40285e80 	call	40285e8 <usleep>
    }while(timeout > 0);
 402cc08:	e0bffb17 	ldw	r2,-20(fp)
 402cc0c:	10800048 	cmpgei	r2,r2,1
 402cc10:	103feb1e 	bne	r2,zero,402cbc0 <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 402cc14:	e0bffb17 	ldw	r2,-20(fp)
 402cc18:	1004c03a 	cmpne	r2,r2,zero
 402cc1c:	1000031e 	bne	r2,zero,402cc2c <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 402cc20:	00bfe304 	movi	r2,-116
 402cc24:	e0bffc15 	stw	r2,-16(fp)
 402cc28:	00000606 	br	402cc44 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 402cc2c:	e0bffd03 	ldbu	r2,-12(fp)
 402cc30:	10801fcc 	andi	r2,r2,127
 402cc34:	1005003a 	cmpeq	r2,r2,zero
 402cc38:	1000021e 	bne	r2,zero,402cc44 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 402cc3c:	00bffec4 	movi	r2,-5
 402cc40:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 402cc44:	e0bffe17 	ldw	r2,-8(fp)
 402cc48:	11803517 	ldw	r6,212(r2)
 402cc4c:	e0bffe17 	ldw	r2,-8(fp)
 402cc50:	10800a17 	ldw	r2,40(r2)
 402cc54:	1007883a 	mov	r3,r2
 402cc58:	e0bfff17 	ldw	r2,-4(fp)
 402cc5c:	1889883a 	add	r4,r3,r2
 402cc60:	01403fc4 	movi	r5,255
 402cc64:	303ee83a 	callr	r6

  return ret_code;
 402cc68:	e0bffc17 	ldw	r2,-16(fp)
}
 402cc6c:	e037883a 	mov	sp,fp
 402cc70:	dfc00117 	ldw	ra,4(sp)
 402cc74:	df000017 	ldw	fp,0(sp)
 402cc78:	dec00204 	addi	sp,sp,8
 402cc7c:	f800283a 	ret

0402cc80 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 402cc80:	defff904 	addi	sp,sp,-28
 402cc84:	dfc00615 	stw	ra,24(sp)
 402cc88:	df000515 	stw	fp,20(sp)
 402cc8c:	df000504 	addi	fp,sp,20
 402cc90:	e13ffd15 	stw	r4,-12(fp)
 402cc94:	e17ffe15 	stw	r5,-8(fp)
 402cc98:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 402cc9c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 402cca0:	e0bffd17 	ldw	r2,-12(fp)
 402cca4:	11803517 	ldw	r6,212(r2)
 402cca8:	e0bffd17 	ldw	r2,-12(fp)
 402ccac:	10800a17 	ldw	r2,40(r2)
 402ccb0:	1007883a 	mov	r3,r2
 402ccb4:	e0bffe17 	ldw	r2,-8(fp)
 402ccb8:	1889883a 	add	r4,r3,r2
 402ccbc:	01401004 	movi	r5,64
 402ccc0:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 402ccc4:	e13ffd17 	ldw	r4,-12(fp)
 402ccc8:	e17ffe17 	ldw	r5,-8(fp)
 402cccc:	e1bfff17 	ldw	r6,-4(fp)
 402ccd0:	4028d200 	call	4028d20 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 402ccd4:	e0bffd17 	ldw	r2,-12(fp)
 402ccd8:	10800a17 	ldw	r2,40(r2)
 402ccdc:	1007883a 	mov	r3,r2
 402cce0:	e0bffe17 	ldw	r2,-8(fp)
 402cce4:	1885883a 	add	r2,r3,r2
 402cce8:	10800023 	ldbuio	r2,0(r2)
 402ccec:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 402ccf0:	e0bffb03 	ldbu	r2,-20(fp)
 402ccf4:	10803fcc 	andi	r2,r2,255
 402ccf8:	1080201c 	xori	r2,r2,128
 402ccfc:	10bfe004 	addi	r2,r2,-128
 402cd00:	1004403a 	cmpge	r2,r2,zero
 402cd04:	103ff31e 	bne	r2,zero,402ccd4 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 402cd08:	e0bffb03 	ldbu	r2,-20(fp)
 402cd0c:	10801fcc 	andi	r2,r2,127
 402cd10:	1005003a 	cmpeq	r2,r2,zero
 402cd14:	1000021e 	bne	r2,zero,402cd20 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 402cd18:	00bffec4 	movi	r2,-5
 402cd1c:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 402cd20:	e0bffd17 	ldw	r2,-12(fp)
 402cd24:	11803517 	ldw	r6,212(r2)
 402cd28:	e0bffd17 	ldw	r2,-12(fp)
 402cd2c:	10800a17 	ldw	r2,40(r2)
 402cd30:	1007883a 	mov	r3,r2
 402cd34:	e0bffe17 	ldw	r2,-8(fp)
 402cd38:	1889883a 	add	r4,r3,r2
 402cd3c:	01403fc4 	movi	r5,255
 402cd40:	303ee83a 	callr	r6
  
  return ret_code;
 402cd44:	e0bffc17 	ldw	r2,-16(fp)
}
 402cd48:	e037883a 	mov	sp,fp
 402cd4c:	dfc00117 	ldw	ra,4(sp)
 402cd50:	df000017 	ldw	fp,0(sp)
 402cd54:	dec00204 	addi	sp,sp,8
 402cd58:	f800283a 	ret

0402cd5c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 402cd5c:	defffa04 	addi	sp,sp,-24
 402cd60:	dfc00515 	stw	ra,20(sp)
 402cd64:	df000415 	stw	fp,16(sp)
 402cd68:	df000404 	addi	fp,sp,16
 402cd6c:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 402cd70:	008100f4 	movhi	r2,1027
 402cd74:	10bd6c04 	addi	r2,r2,-2640
 402cd78:	10800017 	ldw	r2,0(r2)
 402cd7c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 402cd80:	00003306 	br	402ce50 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 402cd84:	e0bffd17 	ldw	r2,-12(fp)
 402cd88:	11000217 	ldw	r4,8(r2)
 402cd8c:	40275e40 	call	40275e4 <strlen>
 402cd90:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 402cd94:	e0bffd17 	ldw	r2,-12(fp)
 402cd98:	10c00217 	ldw	r3,8(r2)
 402cd9c:	e0bffc17 	ldw	r2,-16(fp)
 402cda0:	1885883a 	add	r2,r3,r2
 402cda4:	10bfffc4 	addi	r2,r2,-1
 402cda8:	10800003 	ldbu	r2,0(r2)
 402cdac:	10803fcc 	andi	r2,r2,255
 402cdb0:	1080201c 	xori	r2,r2,128
 402cdb4:	10bfe004 	addi	r2,r2,-128
 402cdb8:	10800bd8 	cmpnei	r2,r2,47
 402cdbc:	1000031e 	bne	r2,zero,402cdcc <alt_find_file+0x70>
    {
      len -= 1;
 402cdc0:	e0bffc17 	ldw	r2,-16(fp)
 402cdc4:	10bfffc4 	addi	r2,r2,-1
 402cdc8:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 402cdcc:	e0bffc17 	ldw	r2,-16(fp)
 402cdd0:	1007883a 	mov	r3,r2
 402cdd4:	e0bffe17 	ldw	r2,-8(fp)
 402cdd8:	1885883a 	add	r2,r3,r2
 402cddc:	10800003 	ldbu	r2,0(r2)
 402cde0:	10803fcc 	andi	r2,r2,255
 402cde4:	1080201c 	xori	r2,r2,128
 402cde8:	10bfe004 	addi	r2,r2,-128
 402cdec:	10800be0 	cmpeqi	r2,r2,47
 402cdf0:	10000a1e 	bne	r2,zero,402ce1c <alt_find_file+0xc0>
 402cdf4:	e0bffc17 	ldw	r2,-16(fp)
 402cdf8:	1007883a 	mov	r3,r2
 402cdfc:	e0bffe17 	ldw	r2,-8(fp)
 402ce00:	1885883a 	add	r2,r3,r2
 402ce04:	10800003 	ldbu	r2,0(r2)
 402ce08:	10803fcc 	andi	r2,r2,255
 402ce0c:	1080201c 	xori	r2,r2,128
 402ce10:	10bfe004 	addi	r2,r2,-128
 402ce14:	1004c03a 	cmpne	r2,r2,zero
 402ce18:	10000a1e 	bne	r2,zero,402ce44 <alt_find_file+0xe8>
 402ce1c:	e0bffd17 	ldw	r2,-12(fp)
 402ce20:	11000217 	ldw	r4,8(r2)
 402ce24:	e1bffc17 	ldw	r6,-16(fp)
 402ce28:	e17ffe17 	ldw	r5,-8(fp)
 402ce2c:	402cfe40 	call	402cfe4 <memcmp>
 402ce30:	1004c03a 	cmpne	r2,r2,zero
 402ce34:	1000031e 	bne	r2,zero,402ce44 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 402ce38:	e0bffd17 	ldw	r2,-12(fp)
 402ce3c:	e0bfff15 	stw	r2,-4(fp)
 402ce40:	00000806 	br	402ce64 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 402ce44:	e0bffd17 	ldw	r2,-12(fp)
 402ce48:	10800017 	ldw	r2,0(r2)
 402ce4c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 402ce50:	00c100f4 	movhi	r3,1027
 402ce54:	18fd6c04 	addi	r3,r3,-2640
 402ce58:	e0bffd17 	ldw	r2,-12(fp)
 402ce5c:	10ffc91e 	bne	r2,r3,402cd84 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 402ce60:	e03fff15 	stw	zero,-4(fp)
 402ce64:	e0bfff17 	ldw	r2,-4(fp)
}
 402ce68:	e037883a 	mov	sp,fp
 402ce6c:	dfc00117 	ldw	ra,4(sp)
 402ce70:	df000017 	ldw	fp,0(sp)
 402ce74:	dec00204 	addi	sp,sp,8
 402ce78:	f800283a 	ret

0402ce7c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 402ce7c:	defffc04 	addi	sp,sp,-16
 402ce80:	df000315 	stw	fp,12(sp)
 402ce84:	df000304 	addi	fp,sp,12
 402ce88:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 402ce8c:	00bffa04 	movi	r2,-24
 402ce90:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 402ce94:	e03ffe15 	stw	zero,-8(fp)
 402ce98:	00001e06 	br	402cf14 <alt_get_fd+0x98>
  {
    if (!alt_fd_list[i].dev)
 402ce9c:	e0bffe17 	ldw	r2,-8(fp)
 402cea0:	00c100f4 	movhi	r3,1027
 402cea4:	18fcf904 	addi	r3,r3,-3100
 402cea8:	10800324 	muli	r2,r2,12
 402ceac:	10c5883a 	add	r2,r2,r3
 402ceb0:	10800017 	ldw	r2,0(r2)
 402ceb4:	1004c03a 	cmpne	r2,r2,zero
 402ceb8:	1000131e 	bne	r2,zero,402cf08 <alt_get_fd+0x8c>
    {
      alt_fd_list[i].dev = dev;
 402cebc:	e0bffe17 	ldw	r2,-8(fp)
 402cec0:	00c100f4 	movhi	r3,1027
 402cec4:	18fcf904 	addi	r3,r3,-3100
 402cec8:	10800324 	muli	r2,r2,12
 402cecc:	10c7883a 	add	r3,r2,r3
 402ced0:	e0bfff17 	ldw	r2,-4(fp)
 402ced4:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 402ced8:	008100f4 	movhi	r2,1027
 402cedc:	10bd7004 	addi	r2,r2,-2624
 402cee0:	10c00017 	ldw	r3,0(r2)
 402cee4:	e0bffe17 	ldw	r2,-8(fp)
 402cee8:	1880040e 	bge	r3,r2,402cefc <alt_get_fd+0x80>
      {
        alt_max_fd = i;
 402ceec:	00c100f4 	movhi	r3,1027
 402cef0:	18fd7004 	addi	r3,r3,-2624
 402cef4:	e0bffe17 	ldw	r2,-8(fp)
 402cef8:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 402cefc:	e0bffe17 	ldw	r2,-8(fp)
 402cf00:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 402cf04:	00000606 	br	402cf20 <alt_get_fd+0xa4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 402cf08:	e0bffe17 	ldw	r2,-8(fp)
 402cf0c:	10800044 	addi	r2,r2,1
 402cf10:	e0bffe15 	stw	r2,-8(fp)
 402cf14:	e0bffe17 	ldw	r2,-8(fp)
 402cf18:	10800810 	cmplti	r2,r2,32
 402cf1c:	103fdf1e 	bne	r2,zero,402ce9c <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 402cf20:	e0bffd17 	ldw	r2,-12(fp)
}
 402cf24:	e037883a 	mov	sp,fp
 402cf28:	df000017 	ldw	fp,0(sp)
 402cf2c:	dec00104 	addi	sp,sp,4
 402cf30:	f800283a 	ret

0402cf34 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 402cf34:	defffb04 	addi	sp,sp,-20
 402cf38:	df000415 	stw	fp,16(sp)
 402cf3c:	df000404 	addi	fp,sp,16
 402cf40:	e13ffe15 	stw	r4,-8(fp)
 402cf44:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 402cf48:	e0bfff17 	ldw	r2,-4(fp)
 402cf4c:	10840070 	cmpltui	r2,r2,4097
 402cf50:	1000021e 	bne	r2,zero,402cf5c <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 402cf54:	00840004 	movi	r2,4096
 402cf58:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 402cf5c:	e0fffe17 	ldw	r3,-8(fp)
 402cf60:	e0bfff17 	ldw	r2,-4(fp)
 402cf64:	1885883a 	add	r2,r3,r2
 402cf68:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 402cf6c:	e0bffe17 	ldw	r2,-8(fp)
 402cf70:	e0bffd15 	stw	r2,-12(fp)
 402cf74:	00000506 	br	402cf8c <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 402cf78:	e0bffd17 	ldw	r2,-12(fp)
 402cf7c:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 402cf80:	e0bffd17 	ldw	r2,-12(fp)
 402cf84:	10800804 	addi	r2,r2,32
 402cf88:	e0bffd15 	stw	r2,-12(fp)
 402cf8c:	e0fffd17 	ldw	r3,-12(fp)
 402cf90:	e0bffc17 	ldw	r2,-16(fp)
 402cf94:	18bff836 	bltu	r3,r2,402cf78 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 402cf98:	e0bffe17 	ldw	r2,-8(fp)
 402cf9c:	108007cc 	andi	r2,r2,31
 402cfa0:	1005003a 	cmpeq	r2,r2,zero
 402cfa4:	1000021e 	bne	r2,zero,402cfb0 <alt_icache_flush+0x7c>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 402cfa8:	e0bffd17 	ldw	r2,-12(fp)
 402cfac:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 402cfb0:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 402cfb4:	e037883a 	mov	sp,fp
 402cfb8:	df000017 	ldw	fp,0(sp)
 402cfbc:	dec00104 	addi	sp,sp,4
 402cfc0:	f800283a 	ret

0402cfc4 <exit>:
 402cfc4:	defffe04 	addi	sp,sp,-8
 402cfc8:	dc400015 	stw	r17,0(sp)
 402cfcc:	000b883a 	mov	r5,zero
 402cfd0:	2023883a 	mov	r17,r4
 402cfd4:	dfc00115 	stw	ra,4(sp)
 402cfd8:	402d0240 	call	402d024 <__call_exitprocs>
 402cfdc:	8809883a 	mov	r4,r17
 402cfe0:	402d2200 	call	402d220 <_exit>

0402cfe4 <memcmp>:
 402cfe4:	31ffffc4 	addi	r7,r6,-1
 402cfe8:	3000061e 	bne	r6,zero,402d004 <memcmp+0x20>
 402cfec:	00000a06 	br	402d018 <memcmp+0x34>
 402cff0:	39ffffc4 	addi	r7,r7,-1
 402cff4:	00bfffc4 	movi	r2,-1
 402cff8:	21000044 	addi	r4,r4,1
 402cffc:	29400044 	addi	r5,r5,1
 402d000:	38800526 	beq	r7,r2,402d018 <memcmp+0x34>
 402d004:	20c00003 	ldbu	r3,0(r4)
 402d008:	28800003 	ldbu	r2,0(r5)
 402d00c:	18bff826 	beq	r3,r2,402cff0 <memcmp+0xc>
 402d010:	1885c83a 	sub	r2,r3,r2
 402d014:	f800283a 	ret
 402d018:	0005883a 	mov	r2,zero
 402d01c:	f800283a 	ret

0402d020 <register_fini>:
 402d020:	f800283a 	ret

0402d024 <__call_exitprocs>:
 402d024:	defff304 	addi	sp,sp,-52
 402d028:	008100f4 	movhi	r2,1027
 402d02c:	10bd6804 	addi	r2,r2,-2656
 402d030:	df000b15 	stw	fp,44(sp)
 402d034:	17000017 	ldw	fp,0(r2)
 402d038:	008100b4 	movhi	r2,1026
 402d03c:	109b1804 	addi	r2,r2,27744
 402d040:	1005003a 	cmpeq	r2,r2,zero
 402d044:	d8800215 	stw	r2,8(sp)
 402d048:	e0800c04 	addi	r2,fp,48
 402d04c:	dd800915 	stw	r22,36(sp)
 402d050:	dd400815 	stw	r21,32(sp)
 402d054:	dfc00c15 	stw	ra,48(sp)
 402d058:	ddc00a15 	stw	r23,40(sp)
 402d05c:	dd000715 	stw	r20,28(sp)
 402d060:	dcc00615 	stw	r19,24(sp)
 402d064:	dc800515 	stw	r18,20(sp)
 402d068:	dc400415 	stw	r17,16(sp)
 402d06c:	dc000315 	stw	r16,12(sp)
 402d070:	282d883a 	mov	r22,r5
 402d074:	d9000115 	stw	r4,4(sp)
 402d078:	d8800015 	stw	r2,0(sp)
 402d07c:	282b003a 	cmpeq	r21,r5,zero
 402d080:	e4400c17 	ldw	r17,48(fp)
 402d084:	88001226 	beq	r17,zero,402d0d0 <__call_exitprocs+0xac>
 402d088:	ddc00017 	ldw	r23,0(sp)
 402d08c:	88800117 	ldw	r2,4(r17)
 402d090:	8c802217 	ldw	r18,136(r17)
 402d094:	143fffc4 	addi	r16,r2,-1
 402d098:	80000b16 	blt	r16,zero,402d0c8 <__call_exitprocs+0xa4>
 402d09c:	9027003a 	cmpeq	r19,r18,zero
 402d0a0:	a800171e 	bne	r21,zero,402d100 <__call_exitprocs+0xdc>
 402d0a4:	9800051e 	bne	r19,zero,402d0bc <__call_exitprocs+0x98>
 402d0a8:	8409883a 	add	r4,r16,r16
 402d0ac:	2105883a 	add	r2,r4,r4
 402d0b0:	1485883a 	add	r2,r2,r18
 402d0b4:	10c02017 	ldw	r3,128(r2)
 402d0b8:	b0c01226 	beq	r22,r3,402d104 <__call_exitprocs+0xe0>
 402d0bc:	843fffc4 	addi	r16,r16,-1
 402d0c0:	00bfffc4 	movi	r2,-1
 402d0c4:	80bff61e 	bne	r16,r2,402d0a0 <__call_exitprocs+0x7c>
 402d0c8:	d8800217 	ldw	r2,8(sp)
 402d0cc:	10003226 	beq	r2,zero,402d198 <__call_exitprocs+0x174>
 402d0d0:	dfc00c17 	ldw	ra,48(sp)
 402d0d4:	df000b17 	ldw	fp,44(sp)
 402d0d8:	ddc00a17 	ldw	r23,40(sp)
 402d0dc:	dd800917 	ldw	r22,36(sp)
 402d0e0:	dd400817 	ldw	r21,32(sp)
 402d0e4:	dd000717 	ldw	r20,28(sp)
 402d0e8:	dcc00617 	ldw	r19,24(sp)
 402d0ec:	dc800517 	ldw	r18,20(sp)
 402d0f0:	dc400417 	ldw	r17,16(sp)
 402d0f4:	dc000317 	ldw	r16,12(sp)
 402d0f8:	dec00d04 	addi	sp,sp,52
 402d0fc:	f800283a 	ret
 402d100:	8409883a 	add	r4,r16,r16
 402d104:	88c00117 	ldw	r3,4(r17)
 402d108:	2105883a 	add	r2,r4,r4
 402d10c:	1445883a 	add	r2,r2,r17
 402d110:	18ffffc4 	addi	r3,r3,-1
 402d114:	11800217 	ldw	r6,8(r2)
 402d118:	1c001826 	beq	r3,r16,402d17c <__call_exitprocs+0x158>
 402d11c:	10000215 	stw	zero,8(r2)
 402d120:	303fe626 	beq	r6,zero,402d0bc <__call_exitprocs+0x98>
 402d124:	8d000117 	ldw	r20,4(r17)
 402d128:	9800121e 	bne	r19,zero,402d174 <__call_exitprocs+0x150>
 402d12c:	00c00044 	movi	r3,1
 402d130:	1c06983a 	sll	r3,r3,r16
 402d134:	90804017 	ldw	r2,256(r18)
 402d138:	1884703a 	and	r2,r3,r2
 402d13c:	10000d26 	beq	r2,zero,402d174 <__call_exitprocs+0x150>
 402d140:	90804117 	ldw	r2,260(r18)
 402d144:	1884703a 	and	r2,r3,r2
 402d148:	10000e1e 	bne	r2,zero,402d184 <__call_exitprocs+0x160>
 402d14c:	2105883a 	add	r2,r4,r4
 402d150:	1485883a 	add	r2,r2,r18
 402d154:	11400017 	ldw	r5,0(r2)
 402d158:	d9000117 	ldw	r4,4(sp)
 402d15c:	303ee83a 	callr	r6
 402d160:	88800117 	ldw	r2,4(r17)
 402d164:	a0bfc61e 	bne	r20,r2,402d080 <__call_exitprocs+0x5c>
 402d168:	b8800017 	ldw	r2,0(r23)
 402d16c:	147fd326 	beq	r2,r17,402d0bc <__call_exitprocs+0x98>
 402d170:	003fc306 	br	402d080 <__call_exitprocs+0x5c>
 402d174:	303ee83a 	callr	r6
 402d178:	003ff906 	br	402d160 <__call_exitprocs+0x13c>
 402d17c:	8c000115 	stw	r16,4(r17)
 402d180:	003fe706 	br	402d120 <__call_exitprocs+0xfc>
 402d184:	2105883a 	add	r2,r4,r4
 402d188:	1485883a 	add	r2,r2,r18
 402d18c:	11000017 	ldw	r4,0(r2)
 402d190:	303ee83a 	callr	r6
 402d194:	003ff206 	br	402d160 <__call_exitprocs+0x13c>
 402d198:	88800117 	ldw	r2,4(r17)
 402d19c:	10000b1e 	bne	r2,zero,402d1cc <__call_exitprocs+0x1a8>
 402d1a0:	89000017 	ldw	r4,0(r17)
 402d1a4:	20000a26 	beq	r4,zero,402d1d0 <__call_exitprocs+0x1ac>
 402d1a8:	b9000015 	stw	r4,0(r23)
 402d1ac:	90000226 	beq	r18,zero,402d1b8 <__call_exitprocs+0x194>
 402d1b0:	9009883a 	mov	r4,r18
 402d1b4:	4026c600 	call	4026c60 <free>
 402d1b8:	8809883a 	mov	r4,r17
 402d1bc:	4026c600 	call	4026c60 <free>
 402d1c0:	bc400017 	ldw	r17,0(r23)
 402d1c4:	883fb11e 	bne	r17,zero,402d08c <__call_exitprocs+0x68>
 402d1c8:	003fc106 	br	402d0d0 <__call_exitprocs+0xac>
 402d1cc:	89000017 	ldw	r4,0(r17)
 402d1d0:	882f883a 	mov	r23,r17
 402d1d4:	2023883a 	mov	r17,r4
 402d1d8:	883fac1e 	bne	r17,zero,402d08c <__call_exitprocs+0x68>
 402d1dc:	003fbc06 	br	402d0d0 <__call_exitprocs+0xac>

0402d1e0 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 402d1e0:	defffd04 	addi	sp,sp,-12
 402d1e4:	df000215 	stw	fp,8(sp)
 402d1e8:	df000204 	addi	fp,sp,8
 402d1ec:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 402d1f0:	e0bfff17 	ldw	r2,-4(fp)
 402d1f4:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 402d1f8:	e0bffe17 	ldw	r2,-8(fp)
 402d1fc:	1005003a 	cmpeq	r2,r2,zero
 402d200:	1000021e 	bne	r2,zero,402d20c <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 402d204:	002af070 	cmpltui	zero,zero,43969
 402d208:	00000106 	br	402d210 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 402d20c:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 402d210:	e037883a 	mov	sp,fp
 402d214:	df000017 	ldw	fp,0(sp)
 402d218:	dec00104 	addi	sp,sp,4
 402d21c:	f800283a 	ret

0402d220 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 402d220:	defffd04 	addi	sp,sp,-12
 402d224:	dfc00215 	stw	ra,8(sp)
 402d228:	df000115 	stw	fp,4(sp)
 402d22c:	df000104 	addi	fp,sp,4
 402d230:	e13fff15 	stw	r4,-4(fp)
  ALT_OS_STOP();

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 402d234:	e13fff17 	ldw	r4,-4(fp)
 402d238:	402d1e00 	call	402d1e0 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 402d23c:	003fff06 	br	402d23c <_exit+0x1c>
 402d240:	0402d020 	cmpeqi	r16,zero,2880
